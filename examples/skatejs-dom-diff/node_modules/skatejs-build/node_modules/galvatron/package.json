{
  "name": "galvatron",
  "engines": {
    "node": ">=0.12"
  },
  "version": "0.10.1",
  "description": "Library that applies pre and post transforms to CommonJS files, traces their dependencies and concatenates them.",
  "main": "index.js",
  "scripts": {
    "test": "mocha --reporter list"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/treshugart/galvatron.git"
  },
  "keywords": [
    "commonjs",
    "trace",
    "es6",
    "transpile",
    "transform",
    "compile",
    "concatenate",
    "concat",
    "global",
    "globals"
  ],
  "author": {
    "name": "Trey Shugart",
    "email": "treshugart@gmail.com",
    "url": "http://treshugart.github.io"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/treshugart/galvatron/issues"
  },
  "homepage": "https://github.com/treshugart/galvatron",
  "devDependencies": {
    "chai": "^3.4.0",
    "eslint": "^1.3.0",
    "mocha": "^2.1.0",
    "tmp": "0.0.28",
    "vinyl-fs": "^2.2.1"
  },
  "dependencies": {
    "crypto": "^0.0.3",
    "detective-amd": "^2.3.2",
    "detective-cjs": "^1.0.4",
    "detective-es6": "^1.1.0",
    "esprima": "^2.2.0",
    "glob": "^5.0.15",
    "glob-all": "^3.0.1",
    "gulp": "^3.9.0",
    "gulp-filter": "^3.0.1",
    "gulp-tap": "^0.1.3",
    "gulp-watch": "^4.1.1",
    "lodash": "^3.10.1",
    "minimatch": "^3.0.0",
    "node-source-walk": "^2.1.0",
    "ternary-stream": "^2.0.0",
    "through2": "^2.0.0",
    "vinyl": "^1.1.0",
    "vinyl-fs": "^2.2.1"
  },
  "gitHead": "2e399ebecdbcacefa09fbd6e06d7301541844ac7",
  "readme": "# Galvatron\n\nA library of streaming helpers for tracing, watching and transforming JavaScript files.\n\n## Installing\n\n```sh\nnpm install galvatron\n```\n\n## Including\n\n```js\nrequire('galvatron');\n```\n\n## Usage\n\nGalvatron is written using a combination of Gulp and Vinyl streams. That said, you don't have to use it with Gulp. You can use it with anything that understands Streams 2 and Vinyl objects.\n\n### Tracing Dependencies\n\nGalvatron will take any number of source files and trace their dependencies regardless of what module format they're using. This means you can use any combination of AMD, CommonJS or ES2015 modules within your project and Galvatron will figure out the dependency tree and insert each file into the stream.\n\nTake the following files, for example:\n\n`src/a.js`\n\n```js\nimport './b';\nexport default function () {};\n```\n\n`src/b.js`\n\n```js\ndefine(['./c'], function (c) {\n  return function () {};\n});\n```\n\n`src/c.js`\n\n```js\nvar _ = require('underscore');\nmodule.exports = function () {};\n```\n\n`node_modules/underscore/index.js`\n\n```js\n// Underscore source here.\n```\n\nIf you used `src/a.js` as your entry point, Galvatron would generate a dependency tree from this:\n\n```\n- src/a.js\n-- src/b.js\n--- src/c.js\n---- node_modules/underscore/index.js\n```\n\nAnd insert them into the stream in the order in which they'd need to be included for concatenation:\n\n1. `node_modules/underscore/index.js`\n2. `src/c.js`\n3. `src/b.js`\n4. `src/a.js`\n\nThe code to do this might look something like:\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\n\ngulp.task('dist', function () {\n  return gulp.src('src/a.js')\n    .pipe(galv.trace())\n    .pipe(gulp.dest('dist'));\n});\n```\n\nThat would trace all modules referenced by `src/a.js` regardless of module format and move them to `dist`. Elaborating on this example, say we wanted to concatenate the files together. All you'd have to do is pipe something like [gulp-concat](https://www.npmjs.com/package/gulp-concat) into the stream:\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpConcat = require('gulp-concat');\n\ngulp.task('dist', function () {\n  return gulp.src('src/a.js')\n    .pipe(galv.trace())\n    .pipe(gulpConcat('all.js'))\n    .pipe(gulp.dest('dist'));\n});\n```\n\nDoing so would create a single `dist/all.js` with all of your dependencies in their proper order.\n\n#### Path Resolution\n\nGalvatron supports the standard Node path resolution semantics of `require()`:\n\n1. [File Modules](https://nodejs.org/api/modules.html#modules_file_modules)\n2. [Loading from `node_modules` Folders](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)\n3. [Folders as Modules](https://nodejs.org/api/modules.html#modules_folders_as_modules)\n\nHowever, it also applies those same semantics to `bower_components` folders and their respective `bower.json` files.\n\n### AMD / CommonJS Shimming\n\nIn the examples above, you saw how we can move modules and concatenate them together. However, you must BYO your own shim for the module format you're using. This isn't necessary if you use the `globalize` transform. With the `globalize` transform, any module format you're using will be automatically shimmed using unique, deterministic globals.\n\nJust pipe in `galv.globalize()`:\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpConcat = require('gulp-concat');\n\ngulp.task('dist', function () {\n  return gulp.src('src/a.js')\n    .pipe(galv.trace())\n    .pipe(galv.globalize())\n    .pipe(gulpConcat('all.js'))\n    .pipe(gulp.dest('dist'));\n});\n```\n\nThe benefit of using the `globalize` transform is that your code will work anywhere, no matter what module format you use, and no matter what module format your consumers / users are using.\n\nYou can even decide that you don't want to concatenate your dependencies, or that you want to split up your batches. Since `globalize` creates deterministic global identifiers, if a module in `app.js` refers to a module in `common.js`, things will just work.\n\nFor example, if you wanted to split up your common dependencies from your app code, you could use [gulp-filter](https://www.npmjs.com/package/gulp-filter):\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpConcat = require('gulp-concat');\nvar gulpFilter = require('gulp-filter');\n\ngulp.task('dist', function () {\n  var filterCommon = gulpFilter('node_modules/**', { restore: true });\n  var filterApp = gulpFilter('src/**', { restore: true });\n  return gulp.src('src/a.js')\n    .pipe(galv.trace())\n    .pipe(galv.globalize())\n\n    // Common dependencies.\n    .pipe(filterCommon)\n    .pipe(gulpConcat('common.js'))\n    .pipe(filterCommon.restore)\n\n    // App code.\n    .pipe(filterApp)\n    .pipe(gulpConcat('app.js'))\n    .pipe(filterApp.restore)\n\n    // Write.\n    .pipe(gulp.dest('dist'));\n});\n```\n\nThat would:\n\n1. Trace.\n2. Globalize all files.\n3. Concatenate all depenencies in `node_modules` to `dist/common.js`.\n4. Concatenate all dependencies in `src` to `dist/app.js`.\n\nIt would be up to whomever is consuming these batched files to load `dist/common.js` before `dist/app.js`, though.\n\n### ES6 / ES2015 Support\n\nGalvatron knows how to trace ES2015 files, but the Globalizer won't transform them for you. That's because there's more to it than just modules. In order to transpile ES2015 all you have to do is insert your transpiler of choice. For example, Babel:\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpBabel = require('gulp-babel');\nvar gulpConcat = require('gulp-concat');\n\ngulp.task('dist', function () {\n  return gulp.src('src/index.js')\n    .pipe(galv.trace())\n    .pipe(gulpBabel())\n    .pipe(galv.globalize())\n    .pipe(gulpConcat('index.js'))\n    .pipe(gulp.dest('dist'));\n});\n```\n\nThat would:\n\n1. Trace `src/index.js`.\n2. Transpile from ES6 to ES5.\n3. Globalize.\n4. Concatenate to `dist/index.js`.\n\n### Importing Less / CSS\n\nYou can also import CSS or Less files from within JavaScript files and Galvatron's tracer will insert the files you import into the stream. It will not, however, trace the Less files' `@import` declarations because Less transpilers will do this for you.\n\n`src/index.js`\n\n```js\nimport './index.less';\n```\n\nYou can use `gulp-filter` to insert this into the same stream as your JavaScript files:\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpBabel = require('gulp-babel');\nvar gulpConcat = require('gulp-concat');\nvar gulpFilter = require('gulp-filter');\nvar gulpLess = require('gulp-less');\n\ngulp.task('dist', function () {\n  var filterLess = gulpFilter('{**/*,*}.less', { restore: true });\n  var filterJs = gulpFilter('{**/*,*}.js', { restore: true });\n  return gulp.src('src/index.js')\n    .pipe(galv.trace())\n\n    // JS.\n    .pipe(filterJs)\n    .pipe(gulpBabel())\n    .pipe(galv.globalize())\n    .pipe(gulpConcat('index.js'))\n    .pipe(filterJs.restore)\n\n    // Less.\n    .pipe(filterLess)\n    .pipe(gulpLess())\n    .pipe(gulpConcat('index.css'))\n    .pipe(filterLess.restore)\n\n    // Write.\n    .pipe(gulp.dest('dist'));\n});\n```\n\nThat would:\n\n1. Trace.\n2. Transpile, globalize and concat JS to `dist/index.js`.\n3. Transpile and concat Less to `dist/index.css`.\n\n### Importing Other Assets\n\nSimilar to importing styles, you can also import any file that exists in the file system. All Galvatron does, if it's not a JS file, is insert it into the stream. This allows you to be explicit about what resources a given module requires in order to function:\n\n```js\nimport './img.png';\n```\n\nThis is very useful for scripts that contain a template that may reference that image. Since your dependencies are declared in one spot, your build logic is simplified. For example, a simple custom element:\n\n`my-img.js`\n\n```js\nimport './img.png';\nimport './my-img.less';\n\nexport default document.registerElement('my-img', {\n  prototype: Object.create(window.HTMLElement.prototype, {\n    createdCallback: {\n      value: function () {\n        this.innerHTML = '<img src=\"img.png\">';\n      }\n    }\n  })\n});\n```\n\nHandling assets is handled in much the same way as everything else. The paths are just inserted into the stream and you can filter for them and then process them. For example, if you wanted to completely process the above component and put it in `dist`:\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpBabel = require('gulp-babel');\nvar gulpConcat = require('gulp-concat');\nvar gulpFilter = require('gulp-filter');\nvar gulpImagemin = require('gulp-concat');\nvar gulpLess = require('gulp-less');\n\ngulp.task('dist', function () {\n  var filterImg = gulpFilter('my-img.png', { restore: true });\n  var filterLess = gulpFilter('my-img.less', { restore: true });\n  var filterJs = gulpFilter('my-img.js', { restore: true });\n  return gulp.src('my-img.js')\n    .pipe(galv.trace())\n\n    // JS.\n    .pipe(filterJs)\n    .pipe(gulpBabel())\n    .pipe(galv.globalize())\n    .pipe(gulpConcat('my-img.js'))\n    .pipe(filterJs.restore)\n\n    // Less.\n    .pipe(filterLess)\n    .pipe(gulpLess())\n    .pipe(gulpConcat('my-img.css'))\n    .pipe(filterLess.restore)\n\n    // Images.\n    .pipe(filterImg)\n    .pipe(gulpImagemin())\n    .pipe(filterImg.restore)\n\n    // Write.\n    .pipe(gulp.dest('dist'));\n});\n```\n\n### Watching\n\nThere is also `watch` helper that is just syntactic sugar around `gulp.watch()`.\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpBabel = require('gulp-babel');\nvar gulpConcat = require('gulp-concat');\nvar gulpFilter = require('gulp-filter');\nvar gulpLess = require('gulp-less');\n\ngulp.task('dist', function () {\n  var filterLess = gulpFilter('src/{**/*,*}.less', { restore: true });\n  var filterJs = gulpFilter('src/{**/*,*}.js', { restore: true });\n  return gulp.src('src/index.js')\n    .pipe(galv.trace())\n\n    // JS.\n    .pipe(filterJs)\n    .pipe(gulpBabel())\n    .pipe(galv.globalize())\n    .pipe(gulpConcat('index.js'))\n    .pipe(filterJs.restore)\n\n    // Less.\n    .pipe(filterLess)\n    .pipe(gulpLess())\n    .pipe(gulpConcat('index.css'))\n    .pipe(filterLess.restore)\n\n    // Write.\n    .pipe(gulp.dest('dist'));\n});\n\ngulp.task('dist-watch', function () {\n  galv.watch('src/**', ['dist']);\n});\n```\n\nGalvatron's watcher does several things for you:\n\n1. Ensures the task is run immediately.\n2. Watches files matching your pattern.\n3. Clears the cache for the files that have changed.\n4. Re-runs the task when any of the files change.\n\n### Caching\n\nSometimes a build can take awhile. If you were watching the build in dev mode and you had to wait for a long running build to complete before you could test or view your changes, that would suck.\n\nOne of the things that `watch()` does is automatically clear any cache that may have been added for a particular file. This is so that you can cache the output of a plugin. For example, if we were watching that `dist` task with the `dist-watch` task and found that things were taking too long, all you'd have to do is cache the parts taking awhile.\n\n```js\nvar galv = require('galvatron');\nvar gulp = require('gulp');\nvar gulpBabel = require('gulp-babel');\nvar gulpConcat = require('gulp-concat');\nvar gulpFilter = require('gulp-filter');\nvar gulpLess = require('gulp-less');\n\ngulp.task('dist', function () {\n  var filterLess = gulpFilter('src/{**/*,*}.less', { restore: true });\n  var filterJs = gulpFilter('src/{**/*,*}.js', { restore: true });\n  return gulp.src('src/index.js')\n    .pipe(galv.trace())\n\n    // JS.\n    .pipe(filterJs)\n    .pipe(galv.cache('babel', gulpBabel()))\n    .pipe(galv.cache('globalize', galv.globalize()))\n    .pipe(gulpConcat('index.js'))\n    .pipe(filterJs.restore)\n\n    // Less.\n    .pipe(filterLess)\n    .pipe(galv.cache('less', gulpLess()))\n    .pipe(gulpConcat('index.css'))\n    .pipe(filterLess.restore)\n\n    // Write.\n    .pipe(gulp.dest('dist'));\n});\n\ngulp.task('dist-watch', function () {\n  galv.watch('src/**', ['dist']);\n});\n```\n\nYou can cache whatever you want, just ensure that your watch pattern is set to watch the files that you're caching.\n\n## JSX\n\nGalvatron supports JSX out of the box. You don't need to do anything to enable it.\n",
  "readmeFilename": "README.md",
  "_id": "galvatron@0.10.1",
  "_shasum": "ec59d4e7067c129382e515ecd4c69de6f721b1ca",
  "_from": "treshugart/galvatron#2e399eb",
  "_resolved": "git://github.com/treshugart/galvatron.git#2e399ebecdbcacefa09fbd6e06d7301541844ac7"
}
