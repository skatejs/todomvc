{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/index.js","webpack:///webpack/bootstrap b68d83bff7e2a2e2505a","webpack:///./src/index.js","webpack:///./~/skatejs-web-components/dist/index.js","webpack:///./~/skatejs/dist/index.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///./~/window-or-global/lib/index.js","webpack:///./src/style.js","webpack:///./~/todomvc-common/base.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/todomvc-app-css/index.css"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","getCompleted","todos","filter","todo","isCompleted","getPlural","count","getTodoMode","isEditing","_style","classes","editing","completed","_createClass","defineProperties","target","props","length","descriptor","defineProperty","key","protoProps","staticProps","_skatejs","_style2","_window","window","customElements","TodoApp","_Component","_ref","_temp","_this","_ret","_len","arguments","args","Array","_key","getPrototypeOf","apply","concat","handleChange","e","_this2","checked","todoIndex","parseFloat","getAttribute","map","currentTodoIndex","handleClear","handleRemove","preventDefault","handleSubmit","description","currentValue","handleToggle","todosLength","_getCompleted","todosCompletedLength","incompleteTodosLength","h","class","todoapp","header","onSubmit","autofocus","newTodo","name","onKeyup","link","placeholder","main","toggleAll","type","onChange","for","todoList","view","toggle","data-todo-index","destroy","onClick","edit","footer","todoCount","clearCompleted","info","href","Component","prop","string","array","fixSafari","newAttachShadow","opts","sr","oldAttachShadow","mo","observe","moOpts","HTMLElement","attachShadow","childList","subtree","MutationObserver","muts","forEach","mut","tagName","nextSibling","parentNode","removeChild","insertBefore","navigator","userAgent","safari","indexOf","safariVersion","match","safariVersions","v","patch","eval","Map","j","o","Set","C","D","bind","f","F","enableFlush","s","g","k","test","q","Error","l","b","d","get","toLowerCase","u","n","__$CE_upgraded","localName","A","document","forcePolyfill","split","L","has","set","w","observedAttributes","K","resolve","delete","M","Promise","reject","N","takeRecords","childNodes","HTMLImports","whenReady","I","__$CE_observer","add","J","disconnect","removedNodes","addedNodes","H","nodeType","Node","ELEMENT_NODE","createTreeWalker","NodeFilter","SHOW_ELEMENT","G","currentNode","nextNode","__$CE_attached","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","host","shadowRoot","rel","B","import","removeEventListener","addEventListener","console","assert","attributes","attributeOldValue","attributeFilter","hasAttribute","attributeName","oldValue","attributeNamespace","CustomElementRegistry","whenDefined","flush","polyfilled","_observeRoot","_addImport","r","createElement","t","createElementNS","Element","importNode","setAttribute","removeAttribute","CustomElements","isShadyRoot","Boolean","__localName","matchesSelector","element","selector","matches","copyOwnProperty","source","pd","getOwnPropertyDescriptor","extend","n$","getOwnPropertyNames","extendAll","sources","len","mixin","patchPrototype","proto","hasOwnProperty","patchProto","__sourceProto","__patchProto","newSplice","index","removed","addedCount","getNativeProperty","property","descriptors","enqueue","callback","scheduled","promish","then","flush$1","flushList","push","flushCount","shift","isFlushedMaxed","flushMax","escapeReplace","escapeAttr","replace","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","getOuterHTML","node","composed","attr","attrs","voidElements","getInnerHTML","TEXT_NODE","data","plaintextParents","COMMENT_NODE","error","content","child","c$","filterMutations","mutations","targetRootNode","getRootNode","mutation","mutationInScope","nodes","from","patchNode","settings","inUse","isNodePatched","patchImpl","canPatchNode","tree","saveChildNodes","unpatchNode","unpatch","__patched","pathComposer","startNode","composedPath","current","startRoot","assignedSlot","retarget","refNode","path","ancestor","lastRoot","rootIdx","refNodePath","p$","mixinComposedFlag","Base","klazz","options","event","__composed","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","retargetNonBubblingEvent","__propagationStopped","Event","AT_TARGET","lastFiredRoot","i$1","optionsOrCapture","this$1","capture","once","passive","__eventWrappers","wrapperFn","__target","__relatedTarget","relatedTarget","EventMixin","eventPhase","BUBBLING_PHASE","stopImmediatePropagation","nonBubblingEventsToRetarget","bubble","origAddEventListener","undefined","splice","origRemoveEventListener","idx","activateFocusEventOverrides","ev","ShadyDOM","hasNativeShadowDOM","force","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","common","cb","twiddle","createTextNode","observer","characterData","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","j$1","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","splices","oldIndex","searchLength","index1","index2","calculateSplices","previous","previousValue","nativeInsertBefore","nativeAppendChild","appendChild","nativeRemoveChild","arrayCopyChildNodes","parent","copy","firstChild","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","Logical","Composed","hasParentNode","saveComposedData","__dom","hasChildNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getParentNode","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","recordInsertBefore","container","ref_node","_linkNode","recordRemoveChild","$parentNode","$childNodes","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","NormalizedEvent","inType","params","createEvent","initEvent","bubbles","cancelable","Distributor","anonymous","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","p$1","_assignedSlot","parent$1","insertionPoint","prevAssignedNodes","_assignedNodes","clearAssignedSlots","needsSlotChange","anyDistributed","matchesInsertionPoint","__prevAssignedSlot","distributeNodeInto","node$1","children","setDistributedNodesOnInsertionPoint","_fireSlotChange","slot","savePrevious","slotName","trim","_distributedNodes","d$","dispatchEvent","isFinalDestination","ShadyRoot","frag","createDocumentFragment","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","update","distributionRoot","_findDistributionRoot","render","_elementNeedsDistribution","_skipUpdateInsertionPoints","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","c$1","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","s$1","next","n$1","getInsertionPointTag","DocumentFragment","list","mixinImpl","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","ipAdded","_maybeAddInsertionPoint","handled","_maybeDistribute","removeNode","distributed","logicalParent","maybeDistributeParent","_removeDistributedChildren","_removeOwnerShadyRoot","_scheduleObserver","addedNode","removedNode","schedule","removeNodeFromParent","_hasCachedOwnerRoot","__ownerShadyRoot","documentElement","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","ip$","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","isShadyRoot$$1","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","nativeSetAttribute","nativeRemoveAttribute","ShadyCSS","setElementClass","NodeMixin","parentElement","FragmentMixin","replaceChild","deep","nc","externalNode","doc","ownerDocument","isArray","textContent","tc","cn","join","text","innerHTML","ElementMixin","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","Fragment","AsyncObserver","_scheduled","callbacks","observeChildren","_callback","_observer","_node","unobserveChildren","handle","size","patchedCount","log","head","hasPrototypeDescriptors","warn","mixinForObject","mixinForNode","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","isTrusted","__composedPath","currentTarget","__relatedTargetComposedPath","stopPropagation","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","isPatched","createRootAndEnsurePatched","parse","clean","parseCss","lex","cssText","RX","comments","port","start","end","OPEN_BRACE","rules","CLOSE_BRACE","substring","parsedCssText","ss","_expandUnicodeEscapes","multipleSpaces","lastIndexOf","parsedSelector","atRule","AT_START","MEDIA_START","types","MEDIA_RULE","keyframesRule","KEYFRAMES_RULE","keyframesName","pop","VAR_START","MIXIN_RULE","STYLE_RULE","r$","code","repeat","stringify","preserveProperties","_hasMixinRules","removeCustomProps","removeCustomPropAssignment","removeCustomPropApply","customProp","mixinProp","mixinApply","varApply","parseSettings","nativeCssVariables","shimcssproperties","nativeShadow","shimshadow","toCssText","forEachRule","rulesForStyle","style","__cssRules","isKeyframesSelector","rule","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","matchMedia","rx","MEDIA_MATCH","applyCss","moniker","contextNode","createScopeStyle","applyStyle$1","after","lastHeadApplyNode","applyStylePlaceHolder","placeHolder","createComment","scope","findMatchingParen","level","processVariableAndFallback","str","inner","prefix","suffix","comma","fallback","addToBitMask","bits","parseInt","enqueueDocumentValidation","enqueued","validateDocument","readyState","requestAnimationFrame","ShadyCSS$1","updateStyles","CustomStyle","Reflect","construct","customStyles","CSS","supports","nativeCssApply","WebComponents","flags","VAR_ASSIGN","MIXIN_MATCH","VAR_CONSUMED","ANIMATION_MATCH","IS_VAR","BRACKETED","HOST_PREFIX","HOST_SUFFIX","SCOPE_NAME","StyleTransformer","dom","shouldRemoveScope","__styleScoped","_transformDom","classList","_content","_element","remove","CLASS","elementStyles","styleRules","cssBuildType","__cssBuild","css","is","extends","ext","hostScope","_calcHostScope","_calcElementScope","isScoped","CSS_CLASS_PREFIX","_rule","_transformRule","_transformComplexSelector","transformer","transformedSelector","_transformRuleCss","COMPLEX_SELECTOR_SEP","stop","NTH","SLOTTED_START","HOST","SIMPLE_SELECTOR_SEP","_transformCompoundSelector","combinator","slottedIndex","SLOTTED","_transformHostSelector","_transformSimpleSelector","slotted","SLOTTED_PAREN","paren","DIR_PAREN","before","dir","PSEUDO_PREFIX","HOST_PAREN","SIMPLE_SELECTOR_PREFIX","typeSelector","SELECTOR_NO_MATCH","documentRule","normalizeRootSelector","_transformDocumentSelector","ROOT","SCOPE_DOC_SELECTOR","RegExp","classCallCheck","createClass","toConsumableArray","arr2","StyleInfo","ast","ownStylePropertyNames","elementName","typeExtension","cssBuild","overrideStyleProperties","styleProperties","scopeSelector","customStyle","__styleInfo","styleInfo","IS_IE","StyleProperties","decorateStyles","keyframes","ruleIndex","decorateRule","collectPropertiesInCssText","propertyInfo","_keyframes","names","properties","hasProperties","collectProperties","collectCssText","rx$$1","any","exec","assign","collectConsumingCssText","reify","valueForProperty","valueForProperties","propertyValue","_p","parts","lastIndex","colon","pp","slice","applyProperties","output","applyKeyframeTransforms","keyframeTransforms","hasAnimations","transform","keyframeNamesToTransform","keyframe","propertyDataFromStyles","selectorToMatch","whenHostOrRootRule","isRoot","isHost","hostAndRootPropertiesForScope","hostProps","rootProps","transformStyles","hostSelector","rxHostSelector","hostRx","_elementKeyframeTransforms","_scopeSelector","keyframesRules","_scopeKeyframes","_keyframesRuleTransformer","keyframesNameRx","transformedKeyframesName","scopeId","_p2","applyElementScopeSelector","XSCOPE_NAME","applyElementStyle","_useCount","applyCustomStyle","templateMap","placeholderMap","ce","origDefine","clazz","StyleCache","typeMax","cache","cacheEntry","ownPropertyNames","pn","tagname","styleElement","entry","_validate","APPLY_NAME_CLEAN","INITIAL_INHERIT","MIXIN_VAR_SEP","MixinMap","_map","dependants","ApplyShim","_currentTemplate","_measureElement","_separator","_boundProduceCssProperties","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","transformRules","transformRule","__applyShimInvalid","transformCssText","_consumeCssProperties","all","getComputedStyle","getPropertyValue","mixinName","applyPos","afterApplyPos","textBeforeApply","textAfterApply","defaults$$1","_cssTextToMap","replacement","_atApplyToCssProperties","fallbacks","vars","mixinEntry","_getInitialValueForProperty","sp","out","_replaceInitialOrInherit","_this3","mixinAsProperties","mixinValues","combinedProps","oldProps","needToInvalidate","_invalidateMixinEntry","applyShim","handler","mxns","x","mxn","_i","_n","classIdx","_scope","startState","body","styleCache","scopeCounter","nativeCss","_documentOwner","_documentOwnerStyleInfo","_generateScopeSelector","getStyleAst","styleAstToString","_gatherStyles","template","styles","_getCssBuild","prepareTemplate","_prepared","_styleAst","_generateStaticStyle","_ownPropertyNames","shadowroot","_prepareHost","_cssBuild","applyStyle","overrideProps","CS","_documentDirty","findStyles","_revalidateApplyShim","_updateProperties","applyStyles","_updateNativeProperties","_applyStyleProperties","_isRootOwner","_applyToDescendants","_styleOwnerForNode","fetch","cachedScopeSelector","cachedStyle","oldScopeSelector","store","owner","ownerStyleInfo","ownerProperties","hostAndRootProps","propertyData","propertiesMatchingHost","_mixinOverrideStyles","overrides","removeProperty","setProperty","_transformCustomStyleForDocument","_applyCustomStyleToDocument","getComputedStyleValue","classString","_element$classList","_styleInfoForNode","hookFn","processHook","_customStyles","_findStyle","_applyStyle","__appliedElement","global","incrementalDom","keys","_ref$enumOnly","enumOnly","listOfKeys","getOwnPropertySymbols","def","unshift","enter","object","saved","exit","applyEvent","elem","ename","newFunc","events","$currentEventHandlers","resolveTagName","name$$1","elementOpenStart","tag","statics","overrideArgs","elementOpenEnd","newElementOpen","wrapIdomFunc","func","tnameFuncHandler","noop","wrap","stackCurrentHelper","stackChren","elementOpen$1","skips","$skip","elementClose","skip","_elem","ref$$1","ref$1","newAttr","_len2","_key2","$stackCurrentHelperProps","stackOpen","tname","props$$1","_len3","_key3","stackClose","chren","elemOrFn","newElementVoid","_len4","_key4","newElementClose","atype","_typeof","_len5","_key5","newElementOpenStart","newElementOpenEnd","ch","ctype","newText","sch","builder","_len6","tags","_key6","_len7","_key7","_len8","_key8","createSymbol","Symbol","microtaskDebounce","cbFunc","cbArgs","taskDebounce","setTimeout","getAttrMgr","mgr","$attributesMgr","AttributesManager","error$1","message","DEBUG","isUndefined","resolveAttrName","attrOption","nameOrSymbol","toString","dashCase","String","setCtorNativeProperty","Ctor","propName","getPropsMap","ctorPropsMap","propsMap","reduce","propNameOrSymbol","PropDefinition","get$2","set$2","newProps","renderer$1","getDefaultValue","propDef","getInitialValue","initial","getPropData","elemData","createNativePropertyDescriptor","beforeDefineProperty","propData","attrName","initialValue","valueFromAttribute","empty","deserialize","coerce","internalValue","serializedValue","serialize","setAttrValue","newValue","useDefaultValue","changeData","rendererDebounced","settingProp","preventDoubleCalling","_prevName","_prevOldValue","_prevNewValue","createNativePropertyDescriptors","propDefs","propDescriptors","createInitProps","propDescriptor","hasPropBeforeUpgrading","valueBeforeUpgrading","uniqueId","rand","random","createCustomEvent","detail","initCustomEvent","getValue","arg","val","toNullOrString","JSON","boolean","zeroIfEmptyOrNumberIncludesNaN","Number","number","freeze","connected","created","ctorCreateInitProps","ctorObservedAttributes","ctorProps","rendering","updated$1","symbols$1","propContext","iterator","AwaitValue","AsyncGenerator","gen","send","request","back","front","resume","settle","done","err","_invoke","return","asyncIterator","throw","await","get$1","receiver","Function","desc","getter","inherits","possibleConstructorReturn","applyDefault","symbols","attributesContext","applyProp","className","disabled","ref","firstChar","eventName","toUpperCase","elementOpen","vdom","elementVoid","namespace","__SKATE_DATA","nativeHints","native","hint","debounce","isFunction","pendingValues","lastSetValues","_syncAttrValue","_clearPendingValue","changed","currAttrValue","getOwnPropertyDescriptors","prev","curr","one","two","dash","propOptions","_name","option","optVal","props$1","objectIs","y","HTMLElement$1","_class","_class2","_HTMLElement","propDefsCount","renderCallback","created$$1","readyCallbacks","attrsOnCtor","attrsFromLinkedProps","item","resumeAttributesUpdates","attached","suspendAttributesUpdates","detached","changedExternally","onAttributeChanged","newPropVal","attributeChanged","prevProps","updated","rendered","renderer","rendererCallback","renderedCallback","updatedCallback","definition","_Base","prot","mode","patchInner","possibleFn","allKeys","TheEvent","emit","localTarget","firstPart","ready","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","Context","notifications","nodesCreated","deleted","nodesDeleted","initData","getData","getNamespace","applyAttr","el","attrNS","setAttributeNS","elStyle","applyAttributeTyped","updateAttribute","mutator","getNamespaceForTag","namespaceURI","createText","createKeyMap","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","context","patchFactory","run","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","enterNode","exitNode","patchOuter","alignWithDOM","clearUnvisitedDOM","coreElementOpen","coreElementClose","coreText","currentElement","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","_attr","elementPlaceholder","formatted","_extends","_base","_base2","_index","_index2","_document","cssBaseStyle","cssAppStyle","locals","learn","issue-count","issueCount","quote","speech-bubble","speechBubble","learn-bar","learnBar","mediaQuery","alreadyImportedModules","hidden","new-todo","toggle-all","todo-list","todo-count","filters","selected","clear-completed"],"mappings":"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","file":"dist/index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(1);\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _style = __webpack_require__(5);\n\t\n\tvar _style2 = _interopRequireDefault(_style);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */\n\t\n\tvar _window = window,\n\t    customElements = _window.customElements;\n\t\n\t\n\tfunction getCompleted(todos) {\n\t  return todos.filter(function (todo) {\n\t    return todo.isCompleted;\n\t  });\n\t}\n\t\n\tfunction getPlural(count) {\n\t  return count === 1 ? '' : 's';\n\t}\n\t\n\tfunction getTodoMode(todo) {\n\t  if (todo.isEditing) {\n\t    return _style.classes.editing;\n\t  }\n\t\n\t  if (todo.isCompleted) {\n\t    return _style.classes.completed;\n\t  }\n\t\n\t  return '';\n\t}\n\t\n\tvar TodoApp = function (_Component) {\n\t  _inherits(TodoApp, _Component);\n\t\n\t  function TodoApp() {\n\t    var _ref;\n\t\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, TodoApp);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TodoApp.__proto__ || Object.getPrototypeOf(TodoApp)).call.apply(_ref, [this].concat(args))), _this), _this.handleChange = function (e) {\n\t      var _this2 = _this,\n\t          todos = _this2.todos;\n\t      var target = e.target,\n\t          checked = e.target.checked;\n\t\n\t      var todoIndex = parseFloat(target.getAttribute('data-todo-index'));\n\t      _this.todos = todos.map(function (todo, currentTodoIndex) {\n\t        if (currentTodoIndex === todoIndex) {\n\t          todo.isCompleted = checked;\n\t        }\n\t        return todo;\n\t      });\n\t    }, _this.handleClear = function () {\n\t      _this.todos = _this.todos.filter(function (todo) {\n\t        return !todo.isCompleted;\n\t      });\n\t    }, _this.handleRemove = function (e) {\n\t      var todoIndex = parseFloat(e.target.getAttribute('data-todo-index'));\n\t      e.preventDefault();\n\t      _this.todos = _this.todos.filter(function (todo, currentTodoIndex) {\n\t        return currentTodoIndex !== todoIndex;\n\t      });\n\t    }, _this.handleSubmit = function (e) {\n\t      e.preventDefault();\n\t      _this.todos = _this.todos.concat({\n\t        isCompleted: false,\n\t        isEditing: false,\n\t        description: _this.currentValue\n\t      });\n\t      _this.currentValue = '';\n\t    }, _this.handleToggle = function (e) {\n\t      var checked = e.target.checked;\n\t\n\t      _this.todos = _this.todos.map(function (todo) {\n\t        todo.isCompleted = checked;\n\t        return todo;\n\t      });\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  _createClass(TodoApp, [{\n\t    key: 'renderCallback',\n\t    value: function renderCallback() {\n\t      var currentValue = this.currentValue,\n\t          handleChange = this.handleChange,\n\t          handleClear = this.handleClear,\n\t          handleRemove = this.handleRemove,\n\t          handleToggle = this.handleToggle,\n\t          handleSubmit = this.handleSubmit,\n\t          todos = this.todos;\n\t      var todosLength = todos.length;\n\t\n\t      var _getCompleted = getCompleted(todos),\n\t          todosCompletedLength = _getCompleted.length;\n\t\n\t      var incompleteTodosLength = todosLength - todosCompletedLength;\n\t\n\t      return [(0, _skatejs.h)(\n\t        'style',\n\t        null,\n\t        _style2.default\n\t      ), (0, _skatejs.h)(\n\t        'section',\n\t        { 'class': _style.classes.todoapp },\n\t        (0, _skatejs.h)(\n\t          'header',\n\t          { 'class': _style.classes.header },\n\t          (0, _skatejs.h)(\n\t            'h1',\n\t            null,\n\t            'todos'\n\t          ),\n\t          (0, _skatejs.h)(\n\t            'form',\n\t            { onSubmit: handleSubmit },\n\t            (0, _skatejs.h)('input', {\n\t              autofocus: true,\n\t              'class': _style.classes.newTodo,\n\t              name: 'currentValue',\n\t              onKeyup: (0, _skatejs.link)(this),\n\t              placeholder: 'What needs to be done?',\n\t              value: currentValue\n\t            })\n\t          )\n\t        ),\n\t        todosLength ? (0, _skatejs.h)(\n\t          'section',\n\t          { 'class': _style.classes.main },\n\t          (0, _skatejs.h)('input', {\n\t            'class': _style.classes.toggleAll, type: 'checkbox',\n\t            onChange: handleToggle\n\t          }),\n\t          (0, _skatejs.h)(\n\t            'label',\n\t            { 'for': 'toggle-all' },\n\t            'Mark all as complete'\n\t          ),\n\t          (0, _skatejs.h)(\n\t            'ul',\n\t            { 'class': _style.classes.todoList },\n\t            todos.map(function (todo, todoIndex) {\n\t              return (0, _skatejs.h)(\n\t                'li',\n\t                { 'class': getTodoMode(todo) },\n\t                (0, _skatejs.h)(\n\t                  'div',\n\t                  { 'class': _style.classes.view },\n\t                  (0, _skatejs.h)('input', {\n\t                    'class': _style.classes.toggle,\n\t                    checked: todo.isCompleted,\n\t                    'data-todo-index': todoIndex,\n\t                    onChange: handleChange,\n\t                    type: 'checkbox'\n\t                  }),\n\t                  (0, _skatejs.h)(\n\t                    'label',\n\t                    null,\n\t                    todo.description\n\t                  ),\n\t                  (0, _skatejs.h)('button', {\n\t                    'class': _style.classes.destroy,\n\t                    'data-todo-index': todoIndex,\n\t                    onClick: handleRemove\n\t                  })\n\t                ),\n\t                (0, _skatejs.h)('input', { 'class': _style.classes.edit, value: 'Create a TodoMVC template' })\n\t              );\n\t            })\n\t          )\n\t        ) : '',\n\t        todosLength ? (0, _skatejs.h)(\n\t          'footer',\n\t          { 'class': _style.classes.footer },\n\t          (0, _skatejs.h)(\n\t            'span',\n\t            { 'class': _style.classes.todoCount },\n\t            (0, _skatejs.h)(\n\t              'strong',\n\t              null,\n\t              incompleteTodosLength\n\t            ),\n\t            ' item' + getPlural(incompleteTodosLength) + ' left'\n\t          ),\n\t          todosCompletedLength ? (0, _skatejs.h)(\n\t            'button',\n\t            {\n\t              'class': _style.classes.clearCompleted,\n\t              onClick: handleClear\n\t            },\n\t            'Clear completed'\n\t          ) : ''\n\t        ) : ''\n\t      ), (0, _skatejs.h)(\n\t        'footer',\n\t        { 'class': _style.classes.info },\n\t        (0, _skatejs.h)(\n\t          'p',\n\t          null,\n\t          'Double-click to edit a todo'\n\t        ),\n\t        (0, _skatejs.h)(\n\t          'p',\n\t          null,\n\t          'Created by the ',\n\t          (0, _skatejs.h)(\n\t            'a',\n\t            { href: 'https://github.com/skatejs/skatejs' },\n\t            'SkateJS Team'\n\t          )\n\t        ),\n\t        (0, _skatejs.h)(\n\t          'p',\n\t          null,\n\t          'Part of ',\n\t          (0, _skatejs.h)(\n\t            'a',\n\t            { href: 'http://todomvc.com' },\n\t            'TodoMVC'\n\t          )\n\t        )\n\t      )];\n\t    }\n\t  }]);\n\t\n\t  return TodoApp;\n\t}(_skatejs.Component);\n\t\n\tTodoApp.props = {\n\t  currentValue: _skatejs.prop.string(),\n\t  todos: _skatejs.prop.array()\n\t};\n\t\n\t\n\tcustomElements.define('todo-app', TodoApp);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"skatejsWebComponents\"] = factory();\n\t\telse\n\t\t\troot[\"skatejsWebComponents\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\t// We load the Safari fix first because the custom element polyfill overrides\n\t\t// attachShadow() to observe the shadow root.\n\t\t__webpack_require__(1);\n\t\t\n\t\t// We have to include this first so that it can patch native.\n\t\t__webpack_require__(2);\n\t\t\n\t\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t\t// ShadyDOM polyfill be loaded first.\n\t\t__webpack_require__(3);\n\t\t__webpack_require__(4);\n\t\t__webpack_require__(5);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\tvar _window = window,\n\t\t    HTMLElement = _window.HTMLElement,\n\t\t    MutationObserver = _window.MutationObserver,\n\t\t    navigator = _window.navigator;\n\t\tvar userAgent = navigator.userAgent;\n\t\t\n\t\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\t\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\t\tvar safariVersions = [0, 1].map(function (v) {\n\t\t  return '10.0.' + v;\n\t\t}).concat(['10.0']);\n\t\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\t\n\t\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\t\tfunction fixSafari() {\n\t\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\t\n\t\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t\t  // element as this is the only scenario where styles aren't recalculated.\n\t\t  var moOpts = { childList: true, subtree: true };\n\t\t  var mo = new MutationObserver(function (muts) {\n\t\t    muts.forEach(function (mut) {\n\t\t      var target = mut.target;\n\t\t\n\t\t      if (target.tagName === 'STYLE') {\n\t\t        var nextSibling = target.nextSibling,\n\t\t            parentNode = target.parentNode;\n\t\t\n\t\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t\t        // as it seems that doesn't trigger a recalc.\n\t\t\n\t\t        parentNode.removeChild(target);\n\t\t        parentNode.insertBefore(target, nextSibling);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t\n\t\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t\t  function newAttachShadow(opts) {\n\t\t    var sr = oldAttachShadow.call(this, opts);\n\t\t    mo.observe(sr, moOpts);\n\t\t    return sr;\n\t\t  }\n\t\t\n\t\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t\t    // Ensure polyfills can override it (hoping they call it back).\n\t\t    configurable: true,\n\t\t    enumerable: true,\n\t\t    value: newAttachShadow,\n\t\t    writable: true\n\t\t  });\n\t\t}\n\t\t\n\t\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t\t// fixes the bug.\n\t\tif (patch) {\n\t\t  fixSafari();\n\t\t}\n\t\t\n\t\texports.default = patch;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t\n\t\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\t/*\n\t\t\n\t\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\t Code distributed by Google as part of the polymer project is also\n\t\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\t\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\t\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\t\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\t\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\t\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\t\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\t\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\t\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\t\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\t\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\t\n\t\t//# sourceMappingURL=custom-elements.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar settings = window.ShadyDOM || {};\n\t\t\n\t\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\t\n\t\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\t\n\t\tfunction isShadyRoot(obj) {\n\t\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t\t}\n\t\t\n\t\tvar p = Element.prototype;\n\t\tvar matches = p.matches || p.matchesSelector ||\n\t\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tfunction matchesSelector(element, selector) {\n\t\t  return matches.call(element, selector);\n\t\t}\n\t\t\n\t\tfunction copyOwnProperty(name, source, target) {\n\t\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t\t  if (pd) {\n\t\t    Object.defineProperty(target, name, pd);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction extend(target, source) {\n\t\t  if (target && source) {\n\t\t    var n$ = Object.getOwnPropertyNames(source);\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t\t      copyOwnProperty(n, source, target);\n\t\t    }\n\t\t  }\n\t\t  return target || source;\n\t\t}\n\t\t\n\t\tfunction extendAll(target) {\n\t\t  var sources = [], len = arguments.length - 1;\n\t\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\t\n\t\t  for (var i=0; i < sources.length; i++) {\n\t\t    extend(target, sources[i]);\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tfunction mixin(target, source) {\n\t\t  for (var i in source) {\n\t\t    target[i] = source[i];\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t\t  obj.__proto__ = proto;\n\t\t  return obj;\n\t\t}\n\t\t\n\t\tfunction patchPrototype(obj, mixin) {\n\t\t  var proto = Object.getPrototypeOf(obj);\n\t\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t\t    var patchProto = Object.create(proto);\n\t\t    patchProto.__sourceProto = proto;\n\t\t    extend(patchProto, mixin);\n\t\t    proto.__patchProto = patchProto;\n\t\t  }\n\t\t  setPrototypeOf(obj, proto.__patchProto);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvar common = {};\n\t\t\n\t\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\t\tvar promish;\n\t\tif (window.Promise) {\n\t\t  promish = Promise.resolve();\n\t\t} else {\n\t\t  promish = {\n\t\t    then: function(cb) {\n\t\t      var twiddle = document.createTextNode('');\n\t\t      var observer = new MutationObserver(function() {\n\t\t        observer.disconnect();\n\t\t        cb();\n\t\t      });\n\t\t      observer.observe(twiddle, {characterData: true});\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction newSplice(index, removed, addedCount) {\n\t\t  return {\n\t\t    index: index,\n\t\t    removed: removed,\n\t\t    addedCount: addedCount\n\t\t  };\n\t\t}\n\t\t\n\t\tvar EDIT_LEAVE = 0;\n\t\tvar EDIT_UPDATE = 1;\n\t\tvar EDIT_ADD = 2;\n\t\tvar EDIT_DELETE = 3;\n\t\t\n\t\tvar ArraySplice = {\n\t\t\n\t\t  // Note: This function is *based* on the computation of the Levenshtein\n\t\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t\t  // edits - not one. With Array splices, an update is really a delete\n\t\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t\t  // maximum array items in the original array. For example:\n\t\t  //\n\t\t  //   'xxxx123' -> '123yyyy'\n\t\t  //\n\t\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t\t  // leaves the substring '123' intact.\n\t\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t\t                              old, oldStart, oldEnd) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // \"Deletion\" columns\n\t\t    var rowCount = oldEnd - oldStart + 1;\n\t\t    var columnCount = currentEnd - currentStart + 1;\n\t\t    var distances = new Array(rowCount);\n\t\t\n\t\t    // \"Addition\" rows. Initialize null column.\n\t\t    for (var i = 0; i < rowCount; i++) {\n\t\t      distances[i] = new Array(columnCount);\n\t\t      distances[i][0] = i;\n\t\t    }\n\t\t\n\t\t    // Initialize null row\n\t\t    for (var j = 0; j < columnCount; j++)\n\t\t      distances[0][j] = j;\n\t\t\n\t\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t\t        else {\n\t\t          var north = distances[i$1 - 1][j$1] + 1;\n\t\t          var west = distances[i$1][j$1 - 1] + 1;\n\t\t          distances[i$1][j$1] = north < west ? north : west;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t\n\t\t    return distances;\n\t\t  },\n\t\t\n\t\t  // This starts at the final weight, and walks \"backward\" by finding\n\t\t  // the minimum previous weight recursively until the origin of the weight\n\t\t  // matrix.\n\t\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t\t    var i = distances.length - 1;\n\t\t    var j = distances[0].length - 1;\n\t\t    var current = distances[i][j];\n\t\t    var edits = [];\n\t\t    while (i > 0 || j > 0) {\n\t\t      if (i == 0) {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        continue;\n\t\t      }\n\t\t      if (j == 0) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        continue;\n\t\t      }\n\t\t      var northWest = distances[i - 1][j - 1];\n\t\t      var west = distances[i - 1][j];\n\t\t      var north = distances[i][j - 1];\n\t\t\n\t\t      var min;\n\t\t      if (west < north)\n\t\t        min = west < northWest ? west : northWest;\n\t\t      else\n\t\t        min = north < northWest ? north : northWest;\n\t\t\n\t\t      if (min == northWest) {\n\t\t        if (northWest == current) {\n\t\t          edits.push(EDIT_LEAVE);\n\t\t        } else {\n\t\t          edits.push(EDIT_UPDATE);\n\t\t          current = northWest;\n\t\t        }\n\t\t        i--;\n\t\t        j--;\n\t\t      } else if (min == west) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        current = west;\n\t\t      } else {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        current = north;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    edits.reverse();\n\t\t    return edits;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t   * Splice Projection functions:\n\t\t   *\n\t\t   * A splice map is a representation of how a previous array of items\n\t\t   * was transformed into a new array of items. Conceptually it is a list of\n\t\t   * tuples of\n\t\t   *\n\t\t   *   <index, removed, addedCount>\n\t\t   *\n\t\t   * which are kept in ascending index order of. The tuple represents that at\n\t\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t\t   * from |index|, |addedCount| items were added.\n\t\t   */\n\t\t\n\t\t  /**\n\t\t   * Lacking individual splice mutation information, the minimal set of\n\t\t   * splices can be synthesized given the previous state and final state of an\n\t\t   * array. The basic approach is to calculate the edit distance matrix and\n\t\t   * choose the shortest path through it.\n\t\t   *\n\t\t   * Complexity: O(l * p)\n\t\t   *   l: The length of the current array\n\t\t   *   p: The length of the old array\n\t\t   */\n\t\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t\t                        old, oldStart, oldEnd) {\n\t\t    var prefixCount = 0;\n\t\t    var suffixCount = 0;\n\t\t    var splice;\n\t\t\n\t\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t\t    if (currentStart == 0 && oldStart == 0)\n\t\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\t\n\t\t    if (currentEnd == current.length && oldEnd == old.length)\n\t\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\t\n\t\t    currentStart += prefixCount;\n\t\t    oldStart += prefixCount;\n\t\t    currentEnd -= suffixCount;\n\t\t    oldEnd -= suffixCount;\n\t\t\n\t\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t\t      return [];\n\t\t\n\t\t    if (currentStart == currentEnd) {\n\t\t      splice = newSplice(currentStart, [], 0);\n\t\t      while (oldStart < oldEnd)\n\t\t        splice.removed.push(old[oldStart++]);\n\t\t\n\t\t      return [ splice ];\n\t\t    } else if (oldStart == oldEnd)\n\t\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\t\n\t\t    var ops = this.spliceOperationsFromEditDistances(\n\t\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t\t                               old, oldStart, oldEnd));\n\t\t\n\t\t    splice = undefined;\n\t\t    var splices = [];\n\t\t    var index = currentStart;\n\t\t    var oldIndex = oldStart;\n\t\t    for (var i = 0; i < ops.length; i++) {\n\t\t      switch(ops[i]) {\n\t\t        case EDIT_LEAVE:\n\t\t          if (splice) {\n\t\t            splices.push(splice);\n\t\t            splice = undefined;\n\t\t          }\n\t\t\n\t\t          index++;\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_UPDATE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_ADD:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t          break;\n\t\t        case EDIT_DELETE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    if (splice) {\n\t\t      splices.push(splice);\n\t\t    }\n\t\t    return splices;\n\t\t  },\n\t\t\n\t\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i = 0; i < searchLength; i++)\n\t\t      if (!this$1.equals(current[i], old[i]))\n\t\t        return i;\n\t\t    return searchLength;\n\t\t  },\n\t\t\n\t\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t\t    var index1 = current.length;\n\t\t    var index2 = old.length;\n\t\t    var count = 0;\n\t\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t\t      count++;\n\t\t\n\t\t    return count;\n\t\t  },\n\t\t\n\t\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t\t                            previous.length);\n\t\t  },\n\t\t\n\t\t  equals: function equals(currentValue, previousValue) {\n\t\t    return currentValue === previousValue;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t\t// for now this is stuck on `utils`\n\t\t//import {patchNode} from './patch'\n\t\t// native add/remove\n\t\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\t\tvar nativeAppendChild = Element.prototype.appendChild;\n\t\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\t\n\t\t/**\n\t\t * `tree` is a dom manipulation library used by ShadyDom to\n\t\t * manipulate composed and logical trees.\n\t\t */\n\t\tvar tree = {\n\t\t\n\t\t  // sad but faster than slice...\n\t\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopy: function arrayCopy(a$) {\n\t\t    var l = a$.length;\n\t\t    var copy = new Array(l);\n\t\t    for (var i=0; i < l; i++) {\n\t\t      copy[i] = a$[i];\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes(node) {\n\t\t    tree.Logical.saveChildNodes(node);\n\t\t    if (!tree.Composed.hasParentNode(node)) {\n\t\t      tree.Composed.saveComposedData(node);\n\t\t      //tree.Composed.saveParentNode(node);\n\t\t    }\n\t\t    tree.Composed.saveChildNodes(node);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\ttree.Logical = {\n\t\t\n\t\t  hasParentNode: function hasParentNode(node) {\n\t\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes(node) {\n\t\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes(node) {\n\t\t    // note: we're distinguishing here between undefined and false-y:\n\t\t    // hasChildNodes uses undefined check to see if this element has logical\n\t\t    // children; the false-y check indicates whether or not we should rebuild\n\t\t    // the cached childNodes array.\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      tree.Composed.getChildNodes(node);\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes(node) {\n\t\t    if (!node.__dom.childNodes) {\n\t\t      node.__dom.childNodes = [];\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        node.__dom.childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.childNodes;\n\t\t  },\n\t\t\n\t\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t\t  // element will store firstChild/lastChild, and in case (2), the element\n\t\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t\t  // the mere existence of __dom is not enough to know if the requested\n\t\t  // logical data is available and instead we do an explicit undefined check.\n\t\t  getParentNode: function getParentNode(node) {\n\t\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      this._getFirstElementChild(node) :\n\t\t      tree.Composed.getFirstElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t\t    var n = node.__dom.firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t\t      this._getLastElementChild(node) :\n\t\t      tree.Composed.getLastElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild(node) {\n\t\t    var n = node.__dom.lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t\t      this._getNextElementSibling(node) :\n\t\t      tree.Composed.getNextElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t\t      this._getPreviousElementSibling(node) :\n\t\t      tree.Composed.getPreviousElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  // Capture the list of light children. It's important to do this before we\n\t\t  // start transforming the DOM into \"rendered\" state.\n\t\t  // Children may be added to this list dynamically. It will be treated as the\n\t\t  // source of truth for the light children of the element. This element's\n\t\t  // actual children will be treated as the rendered state once this function\n\t\t  // has been called.\n\t\t  saveChildNodes: function saveChildNodes$1(node) {\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.firstChild;\n\t\t      node.__dom.lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        n.__dom = n.__dom || {};\n\t\t        n.__dom.parentNode = node;\n\t\t        n.__dom.nextSibling = c$[i+1] || null;\n\t\t        n.__dom.previousSibling = c$[i-1] || null;\n\t\t        common.patchNode(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t\t  // already been distributed.\n\t\t  // NOTE: ensure `node` is patched...\n\t\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var c$ = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1._linkNode(c$[i], container, ref_node);\n\t\t      }\n\t\t      // cleanup logical dom in doc fragment.\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t\t      node.__dom.childNodes = null;\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t\t    common.patchNode(node);\n\t\t    ref_node = ref_node || null;\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t\t      container.__dom.lastChild;\n\t\t    if (node.__dom.previousSibling) {\n\t\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.nextSibling = ref_node;\n\t\t    if (node.__dom.nextSibling) {\n\t\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.lastChild = node;\n\t\t      if (!container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.firstChild) {\n\t\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.lastChild) {\n\t\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.previousSibling;\n\t\t    var n = node.__dom.nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.previousSibling = p;\n\t\t    }\n\t\t    // When an element is removed, logical data is no longer tracked.\n\t\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t\t    // from `null` which is set if info is null.\n\t\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t\t      node.__dom.nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t// TODO(sorvell): composed tree manipulation is made available\n\t\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t\t// to the tree for optional patching pluggability.\n\t\ttree.Composed = {\n\t\t\n\t\t  hasParentNode: function hasParentNode$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes$1(node) {\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes$1(node) {\n\t\t    if (!node.__dom.$childNodes) {\n\t\t      node.__dom.$childNodes = [];\n\t\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t\t        node.__dom.$childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getParentNode: function getParentNode$1(node) {\n\t\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t\t      (!node.__patched && node.parentNode);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t\t    return node.__patched ? this._getFirstElementChild(node) :\n\t\t      node.firstElementChild;\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t\t    var n = node.__dom.$firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild$1(node) {\n\t\t    return node.__patched ? this._getLastElementChild(node) :\n\t\t      node.lastElementChild;\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t\t    var n = node.__dom.$lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t\t    return node.__patched ? this._getNextElementSibling(node) :\n\t\t      node.nextElementSibling;\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t\t      node.previousElementSibling;\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes$2(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.$firstChild = node.firstChild;\n\t\t      node.__dom.$lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        this$1.saveComposedData(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveComposedData: function saveComposedData(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    if (node.__dom.$parentNode === undefined) {\n\t\t      node.__dom.$parentNode = node.parentNode;\n\t\t    }\n\t\t    if (node.__dom.$nextSibling === undefined) {\n\t\t      node.__dom.$nextSibling = node.nextSibling;\n\t\t    }\n\t\t    if (node.__dom.$previousSibling === undefined) {\n\t\t      node.__dom.$previousSibling = node.previousSibling;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.$childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      // TODO(sorvell): remember this for patching:\n\t\t      // the act of setting this info can affect patched nodes\n\t\t      // getters; therefore capture childNodes before patching.\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        this$1._linkNode(n, container, ref_node);\n\t\t      }\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t\t      container.__dom.$lastChild;\n\t\t    if (node.__dom.$previousSibling) {\n\t\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.$nextSibling = ref_node;\n\t\t    if (node.__dom.$nextSibling) {\n\t\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.$parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.$lastChild = node;\n\t\t      if (!container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.$firstChild) {\n\t\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.$lastChild) {\n\t\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.$previousSibling;\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.$nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.$previousSibling = p;\n\t\t    }\n\t\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t\t      node.__dom.$nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  clearChildNodes: function clearChildNodes(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = this.getChildNodes(node);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      this$1.recordRemoveChild(c, node);\n\t\t      nativeRemoveChild.call(node, c)\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveParentNode: function saveParentNode(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    node.__dom.$parentNode = node.parentNode;\n\t\t  },\n\t\t\n\t\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    // remove from current location.\n\t\t    this._addChild(parentNode, newChild, refChild);\n\t\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t\t  },\n\t\t\n\t\t  appendChild: function appendChild(parentNode, newChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._addChild(parentNode, newChild);\n\t\t    return nativeAppendChild.call(parentNode, newChild);\n\t\t  },\n\t\t\n\t\t  removeChild: function removeChild(parentNode, node) {\n\t\t    var currentParent = this.getParentNode(node);\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._removeChild(parentNode, node);\n\t\t    if (currentParent === parentNode) {\n\t\t      return nativeRemoveChild.call(parentNode, node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var oldParent = this.getParentNode(newChild);\n\t\t    if (oldParent) {\n\t\t      this._removeChild(oldParent, newChild);\n\t\t    }\n\t\t    if (isFrag) {\n\t\t      var c$ = this.getChildNodes(newChild);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        var c = c$[i];\n\t\t        // unlink document fragment children\n\t\t        this$1._removeChild(newChild, c);\n\t\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t\t      }\n\t\t    } else {\n\t\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeChild: function _removeChild(parentNode, node) {\n\t\t    this.recordRemoveChild(node, parentNode);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\t// for testing...\n\t\tvar descriptors = {};\n\t\tfunction getNativeProperty(element, property) {\n\t\t  if (!descriptors[property]) {\n\t\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t\t      HTMLElement.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Element.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Node.prototype, property);\n\t\t  }\n\t\t  return descriptors[property].get.call(element);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// NOTE: normalize event contruction where necessary (IE11)\n\t\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t\t  function(inType, params) {\n\t\t    params = params || {};\n\t\t    var e = document.createEvent('Event');\n\t\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t\t    return e;\n\t\t  };\n\t\t\n\t\tvar Distributor = (function () {\n\t\t  function anonymous(root) {\n\t\t    this.root = root;\n\t\t    this.insertionPointTag = 'slot';\n\t\t  }\n\t\t\n\t\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t\t    return Boolean(this.root._insertionPoints &&\n\t\t      this.root._insertionPoints.length);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t\t    return node.localName && node.localName == this.insertionPointTag;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distribute = function distribute () {\n\t\t    if (this.hasInsertionPoint()) {\n\t\t      return this.distributePool(this.root, this.collectPool());\n\t\t    }\n\t\t    return [];\n\t\t  };\n\t\t\n\t\t  // Gather the pool of nodes that should be distributed. We will combine\n\t\t  // these with the \"content root\" to arrive at the composed tree.\n\t\t  anonymous.prototype.collectPool = function collectPool () {\n\t\t    return tree.arrayCopy(\n\t\t      tree.Logical.getChildNodes(this.root.host));\n\t\t  };\n\t\t\n\t\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t\t  // instead elements are distributed into storage\n\t\t  // array where applicable.\n\t\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var dirtyRoots = [];\n\t\t    var p$ = this.root._insertionPoints;\n\t\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t\t      this$1.distributeInsertionPoint(p, pool);\n\t\t      // provoke redistribution on insertion point parents\n\t\t      // must do this on all candidate hosts since distribution in this\n\t\t      // scope invalidates their distribution.\n\t\t      // only get logical parent.\n\t\t      var parent = tree.Logical.getParentNode(p);\n\t\t      if (parent && parent.shadyRoot &&\n\t\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t\t        dirtyRoots.push(parent.shadyRoot);\n\t\t      }\n\t\t    }\n\t\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t\t      var p$1 = pool[i$1];\n\t\t      if (p$1) {\n\t\t        p$1._assignedSlot = undefined;\n\t\t        // remove undistributed elements from physical dom.\n\t\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t\t        if (parent$1) {\n\t\t          tree.Composed.removeChild(parent$1, p$1);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return dirtyRoots;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t\t    if (prevAssignedNodes) {\n\t\t      this.clearAssignedSlots(insertionPoint, true);\n\t\t    }\n\t\t    insertionPoint._assignedNodes = [];\n\t\t    var needsSlotChange = false;\n\t\t    // distribute nodes from the pool that this selector matches\n\t\t    var anyDistributed = false;\n\t\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t\t      node=pool[i];\n\t\t      // skip nodes that were already used\n\t\t      if (!node) {\n\t\t        continue;\n\t\t      }\n\t\t      // distribute this node if it matches\n\t\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node, insertionPoint)\n\t\t        // remove this node from the pool\n\t\t        pool[i] = undefined;\n\t\t        // since at least one node matched, we won't need fallback content\n\t\t        anyDistributed = true;\n\t\t      }\n\t\t    }\n\t\t    // Fallback content if nothing was distributed here\n\t\t    if (!anyDistributed) {\n\t\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t\t      for (var j = 0, node$1; j < children.length; j++) {\n\t\t        node$1 = children[j];\n\t\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t\t      }\n\t\t    }\n\t\t    // we're already dirty if a node was newly added to the slot\n\t\t    // and we're also dirty if the assigned count decreased.\n\t\t    if (prevAssignedNodes) {\n\t\t      // TODO(sorvell): the tracking of previously assigned slots\n\t\t      // could instead by done with a Set and then we could\n\t\t      // avoid needing to iterate here to clear the info.\n\t\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t\t      }\n\t\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t\t        needsSlotChange = true;\n\t\t      }\n\t\t    }\n\t\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t\t    if (needsSlotChange) {\n\t\t      this._fireSlotChange(insertionPoint);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t\t    var n$ = slot._assignedNodes;\n\t\t    if (n$) {\n\t\t      for (var i=0; i < n$.length; i++) {\n\t\t        var n = n$[i];\n\t\t        if (savePrevious) {\n\t\t          n.__prevAssignedSlot = n._assignedSlot;\n\t\t        }\n\t\t        // only clear if it was previously set to this slot;\n\t\t        // this helps ensure that if the node has otherwise been distributed\n\t\t        // ignore it.\n\t\t        if (n._assignedSlot === slot) {\n\t\t          n._assignedSlot = null;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t\t    var slotName = insertionPoint.getAttribute('name');\n\t\t    slotName = slotName ? slotName.trim() : '';\n\t\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t\t    slot = slot ? slot.trim() : '';\n\t\t    return (slot == slotName);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t\t    insertionPoint._assignedNodes.push(child);\n\t\t    child._assignedSlot = insertionPoint;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n$ = insertionPoint._assignedNodes;\n\t\t    insertionPoint._distributedNodes = [];\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t\t      if (this$1.isInsertionPoint(n)) {\n\t\t        var d$ = n._distributedNodes;\n\t\t        if (d$) {\n\t\t          for (var j=0; j < d$.length; j++) {\n\t\t            insertionPoint._distributedNodes.push(d$[j]);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        insertionPoint._distributedNodes.push(n$[i]);\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t\t    // Safari tech preview does not bubble but chrome does\n\t\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t\t    if (insertionPoint._assignedSlot) {\n\t\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t\t    return !(insertionPoint._assignedSlot);\n\t\t  };\n\t\t\n\t\t  return anonymous;\n\t\t}())\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t\t  polyfill across browsers.\n\t\t*/\n\t\tvar ShadyRoot = function ShadyRoot(host) {\n\t\t  if (!host) {\n\t\t    throw 'Must provide a host';\n\t\t  }\n\t\t  // NOTE: this strange construction is necessary because\n\t\t  // DocumentFragment cannot be subclassed on older browsers.\n\t\t  var frag = document.createDocumentFragment();\n\t\t  frag.__proto__ = ShadyFragmentMixin;\n\t\t  frag._init(host);\n\t\t  return frag;\n\t\t};\n\t\t\n\t\tvar ShadyMixin = {\n\t\t\n\t\t  _init: function _init(host) {\n\t\t    // NOTE: set a fake local name so this element can be\n\t\t    // distinguished from a DocumentFragment when patching.\n\t\t    // FF doesn't allow this to be `localName`\n\t\t    this.__localName = 'ShadyRoot';\n\t\t    // root <=> host\n\t\t    host.shadyRoot = this;\n\t\t    this.host = host;\n\t\t    // logical dom setup\n\t\t    tree.Logical.saveChildNodes(host);\n\t\t    tree.Logical.saveChildNodes(this);\n\t\t    // state flags\n\t\t    this._clean = true;\n\t\t    this._hasRendered = false;\n\t\t    this._distributor = new Distributor(this);\n\t\t    this.update();\n\t\t  },\n\t\t\n\t\t  // async render the \"top\" distributor (this is all that is needed to\n\t\t  // distribute this host).\n\t\t  update: function update() {\n\t\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t\t    if (distributionRoot._clean) {\n\t\t      distributionRoot._clean = false;\n\t\t      enqueue(function() {\n\t\t        distributionRoot.render();\n\t\t      });\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t\t  // this should only return a shadowRoot.\n\t\t  // returns the host that's the top of this host's distribution tree\n\t\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t\t    var root = element.shadyRoot;\n\t\t    while (element && this._elementNeedsDistribution(element)) {\n\t\t      root = element.getRootNode();\n\t\t      element = root && root.host;\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  // Return true if a host's children includes\n\t\t  // an insertion point that selects selectively\n\t\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = tree.Logical.getChildNodes(element);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t\t        return element.getRootNode();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  render: function render() {\n\t\t    if (!this._clean) {\n\t\t      this._clean = true;\n\t\t      if (!this._skipUpdateInsertionPoints) {\n\t\t        this.updateInsertionPoints();\n\t\t      } else if (!this._hasRendered) {\n\t\t        this._insertionPoints = [];\n\t\t      }\n\t\t      this._skipUpdateInsertionPoints = false;\n\t\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t\t      // that would avoid distribution for initial render if\n\t\t      // no insertion points exist. We cannot currently do this because\n\t\t      // it relies on elements being in the physical shadowRoot element\n\t\t      // so that native methods will be used. The current append code\n\t\t      // simply provokes distribution in this case and does not put the\n\t\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t\t      // consider if the special processing is worth the perf gain.\n\t\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t\t      //   tree.Composed.clearChildNodes(this.host);\n\t\t      //   tree.Composed.appendChild(this.host, this);\n\t\t      // } else {\n\t\t      // logical\n\t\t      this.distribute();\n\t\t      // physical\n\t\t      this.compose();\n\t\t      this._hasRendered = true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  forceRender: function forceRender() {\n\t\t    this._clean = false;\n\t\t    this.render();\n\t\t  },\n\t\t\n\t\t  distribute: function distribute() {\n\t\t    var dirtyRoots = this._distributor.distribute();\n\t\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t\t      dirtyRoots[i].forceRender();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  updateInsertionPoints: function updateInsertionPoints() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var i$ = this.__insertionPoints;\n\t\t    // if any insertion points have been removed, clear their distribution info\n\t\t    if (i$) {\n\t\t      for (var i=0, c; i < i$.length; i++) {\n\t\t        c = i$[i];\n\t\t        if (c.getRootNode() !== this$1) {\n\t\t          this$1._distributor.clearAssignedSlots(c);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t\t    // ensure insertionPoints's and their parents have logical dom info.\n\t\t    // save logical tree info\n\t\t    // a. for shadyRoot\n\t\t    // b. for insertion points (fallback)\n\t\t    // c. for parents of insertion points\n\t\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t\t      c$1 = i$[i$1];\n\t\t      tree.Logical.saveChildNodes(c$1);\n\t\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  get _insertionPoints() {\n\t\t    if (!this.__insertionPoints) {\n\t\t      this.updateInsertionPoints();\n\t\t    }\n\t\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t\t  },\n\t\t\n\t\t  set _insertionPoints(insertionPoints) {\n\t\t    this.__insertionPoints = insertionPoints;\n\t\t  },\n\t\t\n\t\t  hasInsertionPoint: function hasInsertionPoint() {\n\t\t    return this._distributor.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  compose: function compose() {\n\t\t    // compose self\n\t\t    // note: it's important to mark this clean before distribution\n\t\t    // so that attachment that provokes additional distribution (e.g.\n\t\t    // adding something to your parentNode) works\n\t\t    this._composeTree();\n\t\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t\t    // (these seem unnecessary)\n\t\t  },\n\t\t\n\t\t  // Reify dom such that it is at its correct rendering position\n\t\t  // based on logical distribution.\n\t\t  _composeTree: function _composeTree() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t\t    var p$ = this._insertionPoints || [];\n\t\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t\t      parent = tree.Logical.getParentNode(p);\n\t\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // Returns the list of nodes which should be rendered inside `node`.\n\t\t  _composeNode: function _composeNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var children = [];\n\t\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t\t    for (var i = 0; i < c$.length; i++) {\n\t\t      var child = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t\t        var distributedNodes = child._distributedNodes ||\n\t\t          (child._distributedNodes = []);\n\t\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t\t          var distributedNode = distributedNodes[j];\n\t\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t\t            children.push(distributedNode);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        children.push(child);\n\t\t      }\n\t\t    }\n\t\t    return children;\n\t\t  },\n\t\t\n\t\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t\t    return this._distributor.isFinalDestination(\n\t\t      insertionPoint, node);\n\t\t  },\n\t\t\n\t\t  // Ensures that the rendered node list inside `container` is `children`.\n\t\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t\t    var composed = tree.Composed.getChildNodes(container);\n\t\t    var splices = calculateSplices(children, composed);\n\t\t    // process removals\n\t\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t\t        // check if the node is still where we expect it is before trying\n\t\t        // to remove it; this can happen if we move a node and\n\t\t        // then schedule its previous host for distribution resulting in\n\t\t        // the node being removed here.\n\t\t        if (tree.Composed.getParentNode(n) === container) {\n\t\t          tree.Composed.removeChild(container, n);\n\t\t        }\n\t\t        composed.splice(s.index + d, 1);\n\t\t      }\n\t\t      d -= s.addedCount;\n\t\t    }\n\t\t    // process adds\n\t\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t\t      next = composed[s$1.index];\n\t\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t\t        n$1 = children[j$1];\n\t\t        tree.Composed.insertBefore(container, n$1, next);\n\t\t        // TODO(sorvell): is this splice strictly needed?\n\t\t        composed.splice(j$1, 0, n$1);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  getInsertionPointTag: function getInsertionPointTag() {\n\t\t    return this._distributor.insertionPointTag;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\t\textend(ShadyFragmentMixin, ShadyMixin);\n\t\t\n\t\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\t\n\t\t// function upgradeLogicalChildren(children) {\n\t\t//   if (needsUpgrade && children) {\n\t\t//     for (let i=0; i < children.length; i++) {\n\t\t//       CustomElements.upgrade(children[i]);\n\t\t//     }\n\t\t//   }\n\t\t// }\n\t\t\n\t\t// render enqueuer/flusher\n\t\tvar customElements = window.customElements;\n\t\tvar flushList = [];\n\t\tvar scheduled;\n\t\tvar flushCount = 0;\n\t\tvar flushMax = 100;\n\t\tfunction enqueue(callback) {\n\t\t  if (!scheduled) {\n\t\t    scheduled = true;\n\t\t    promish.then(flush$1);\n\t\t  }\n\t\t  flushList.push(callback);\n\t\t}\n\t\t\n\t\tfunction flush$1() {\n\t\t  scheduled = false;\n\t\t  flushCount++;\n\t\t  while (flushList.length) {\n\t\t    flushList.shift()();\n\t\t  }\n\t\t  if (customElements && customElements.flush) {\n\t\t    customElements.flush();\n\t\t  }\n\t\t  // continue flushing after elements are upgraded...\n\t\t  var isFlushedMaxed = (flushCount > flushMax);\n\t\t  if (flushList.length && !isFlushedMaxed) {\n\t\t      flush$1();\n\t\t  }\n\t\t  flushCount = 0;\n\t\t  if (isFlushedMaxed) {\n\t\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t\t  }\n\t\t}\n\t\t\n\t\tflush$1.list = flushList;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// Cribbed from ShadowDOM polyfill\n\t\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t\t/////////////////////////////////////////////////////////////////////////////\n\t\t// innerHTML and outerHTML\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\t\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\t\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\t\n\t\tfunction escapeReplace(c) {\n\t\t  switch (c) {\n\t\t    case '&':\n\t\t      return '&amp;';\n\t\t    case '<':\n\t\t      return '&lt;';\n\t\t    case '>':\n\t\t      return '&gt;';\n\t\t    case '\"':\n\t\t      return '&quot;';\n\t\t    case '\\u00A0':\n\t\t      return '&nbsp;';\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction escapeAttr(s) {\n\t\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction escapeData(s) {\n\t\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction makeSet(arr) {\n\t\t  var set = {};\n\t\t  for (var i = 0; i < arr.length; i++) {\n\t\t    set[arr[i]] = true;\n\t\t  }\n\t\t  return set;\n\t\t}\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\t\tvar voidElements = makeSet([\n\t\t  'area',\n\t\t  'base',\n\t\t  'br',\n\t\t  'col',\n\t\t  'command',\n\t\t  'embed',\n\t\t  'hr',\n\t\t  'img',\n\t\t  'input',\n\t\t  'keygen',\n\t\t  'link',\n\t\t  'meta',\n\t\t  'param',\n\t\t  'source',\n\t\t  'track',\n\t\t  'wbr'\n\t\t]);\n\t\t\n\t\tvar plaintextParents = makeSet([\n\t\t  'style',\n\t\t  'script',\n\t\t  'xmp',\n\t\t  'iframe',\n\t\t  'noembed',\n\t\t  'noframes',\n\t\t  'plaintext',\n\t\t  'noscript'\n\t\t]);\n\t\t\n\t\tfunction getOuterHTML(node, parentNode, composed) {\n\t\t  switch (node.nodeType) {\n\t\t    case Node.ELEMENT_NODE: {\n\t\t      var tagName = node.localName;\n\t\t      var s = '<' + tagName;\n\t\t      var attrs = node.attributes;\n\t\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t\t      }\n\t\t      s += '>';\n\t\t      if (voidElements[tagName]) {\n\t\t        return s;\n\t\t      }\n\t\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t\t    }\n\t\t    case Node.TEXT_NODE: {\n\t\t      var data = node.data;\n\t\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t\t        return data;\n\t\t      }\n\t\t      return escapeData(data);\n\t\t    }\n\t\t    case Node.COMMENT_NODE: {\n\t\t      return '<!--' + node.data + '-->';\n\t\t    }\n\t\t    default: {\n\t\t      window.console.error(node);\n\t\t      throw new Error('not implemented');\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction getInnerHTML(node, composed) {\n\t\t  if (node.localName === 'template') {\n\t\t    node = node.content;\n\t\t  }\n\t\t  var s = '';\n\t\t  var c$ = composed ? composed(node) : node.childNodes;\n\t\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t\t    s += getOuterHTML(child, node, composed);\n\t\t  }\n\t\t  return s;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar mixinImpl = {\n\t\t\n\t\t  // Try to add node. Record logical info, track insertion points, perform\n\t\t  // distribution iff needed. Return true if the add is handled.\n\t\t  addNode: function addNode(container, node, ref_node) {\n\t\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t\t    if (ownerRoot) {\n\t\t      // optimization: special insertion point tracking\n\t\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t\t      }\n\t\t      // note: we always need to see if an insertion point is added\n\t\t      // since this saves logical tree info; however, invalidation state\n\t\t      // needs\n\t\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t\t      // invalidate insertion points IFF not already invalid!\n\t\t      if (ipAdded) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t      }\n\t\t    }\n\t\t    if (tree.Logical.hasChildNodes(container)) {\n\t\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t\t    }\n\t\t    // if not distributing and not adding to host, do a fast path addition\n\t\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t\t      container.shadyRoot;\n\t\t    return handled;\n\t\t  },\n\t\t\n\t\t  // Try to remove node: update logical info and perform distribution iff\n\t\t  // needed. Return true if the removal has been handled.\n\t\t  // note that it's possible for both the node's host and its parent\n\t\t  // to require distribution... both cases are handled here.\n\t\t  removeNode: function removeNode(node) {\n\t\t    // important that we want to do this only if the node has a logical parent\n\t\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t\t      tree.Logical.getParentNode(node);\n\t\t    var distributed;\n\t\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t\t    if (logicalParent) {\n\t\t      // distribute node's parent iff needed\n\t\t      distributed = this.maybeDistributeParent(node);\n\t\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t\t      // remove node from root and distribute it iff needed\n\t\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    this._removeOwnerShadyRoot(node);\n\t\t    return distributed;\n\t\t  },\n\t\t\n\t\t\n\t\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t\t    var observer = node.__dom && node.__dom.observer;\n\t\t    if (observer) {\n\t\t      if (addedNode) {\n\t\t        observer.addedNodes.push(addedNode);\n\t\t      }\n\t\t      if (removedNode) {\n\t\t        observer.removedNodes.push(removedNode);\n\t\t      }\n\t\t      observer.schedule();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t\t    if (parent) {\n\t\t      this._scheduleObserver(parent, null, node);\n\t\t      this.removeNode(node);\n\t\t    } else {\n\t\t      this._removeOwnerShadyRoot(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t\t  },\n\t\t\n\t\t  getRootNode: function getRootNode$1(node) {\n\t\t    if (!node || !node.nodeType) {\n\t\t      return;\n\t\t    }\n\t\t    var root = node.__ownerShadyRoot;\n\t\t    if (root === undefined) {\n\t\t      if (isShadyRoot(node)) {\n\t\t        root = node;\n\t\t      } else {\n\t\t        var parent = tree.Logical.getParentNode(node);\n\t\t        root = parent ? this.getRootNode(parent) : node;\n\t\t      }\n\t\t      // memo-ize result for performance but only memo-ize\n\t\t      // result if node is in the document. This avoids a problem where a root\n\t\t      // can be cached while an element is inside a fragment.\n\t\t      // If this happens and we cache the result, the value can become stale\n\t\t      // because for perf we avoid processing the subtree of added fragments.\n\t\t      if (document.documentElement.contains(node)) {\n\t\t        node.__ownerShadyRoot = root;\n\t\t      }\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t\t    var root = this.getRootNode(node);\n\t\t    if (isShadyRoot(root)) {\n\t\t      return root;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t\t    // <content> children but since this case is assumed to be exceedingly\n\t\t    // rare, we avoid the cost and will address with some specific api\n\t\t    // when the need arises.  For now, the user must call\n\t\t    // distributeContent(true), which updates insertion points manually\n\t\t    // and forces distribution.\n\t\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t\t      !node.__noInsertionPoint &&\n\t\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t\t    var wrappedContent = fragContent &&\n\t\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t\t    // There are 3 possible cases where a distribution may need to occur:\n\t\t    // 1. <content> being inserted (the host of the shady root where\n\t\t    //    content is inserted needs distribution)\n\t\t    // 2. children being inserted into parent with a shady root (parent\n\t\t    //    needs distribution)\n\t\t    // 3. container is an insertionPoint\n\t\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t\t      if (ownerRoot) {\n\t\t        // note, insertion point list update is handled after node\n\t\t        // mutations are complete\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    var needsDist = this._nodeNeedsDistribution(container);\n\t\t    if (needsDist) {\n\t\t      container.shadyRoot.update();\n\t\t    }\n\t\t    // Return true when distribution will fully handle the composition\n\t\t    // Note that if a content was being inserted that was wrapped by a node,\n\t\t    // and the parent does not need distribution, return false to allow\n\t\t    // the nodes to be added directly, after which children may be\n\t\t    // distributed and composed into the wrapping node(s)\n\t\t    return needsDist || (hasContent && !wrappedContent);\n\t\t  },\n\t\t\n\t\t  /* note: parent argument is required since node may have an out\n\t\t  of date parent at this point; returns true if a <content> is being added */\n\t\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var added;\n\t\t    var insertionPointTag = root.getInsertionPointTag();\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t\t      !node.__noInsertionPoint) {\n\t\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        np = tree.Logical.getParentNode(n);\n\t\t        // don't allow node's parent to be fragment itself\n\t\t        if (np === node) {\n\t\t          np = parent;\n\t\t        }\n\t\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t\t        added = added || na;\n\t\t      }\n\t\t    } else if (node.localName === insertionPointTag) {\n\t\t      tree.Logical.saveChildNodes(parent);\n\t\t      tree.Logical.saveChildNodes(node);\n\t\t      added = true;\n\t\t    }\n\t\t    return added;\n\t\t  },\n\t\t\n\t\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t\t    return node && node.shadyRoot &&\n\t\t      node.shadyRoot.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var hostNeedsDist;\n\t\t    var ip$ = root._insertionPoints;\n\t\t    for (var i=0; i<ip$.length; i++) {\n\t\t      var insertionPoint = ip$[i];\n\t\t      if (this$1._contains(container, insertionPoint)) {\n\t\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t\t        for (var j=0; j<dc$.length; j++) {\n\t\t          hostNeedsDist = true;\n\t\t          var node = dc$[j];\n\t\t          var parent = tree.Composed.getParentNode(node);\n\t\t          if (parent) {\n\t\t            tree.Composed.removeChild(parent, node);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return hostNeedsDist;\n\t\t  },\n\t\t\n\t\t  _contains: function _contains(container, node) {\n\t\t    while (node) {\n\t\t      if (node == container) {\n\t\t        return true;\n\t\t      }\n\t\t      node = tree.Logical.getParentNode(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // optimization: only reset the tree if node is actually in a root\n\t\t    if (this._hasCachedOwnerRoot(node)) {\n\t\t      var c$ = tree.Logical.getChildNodes(node);\n\t\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t\t        this$1._removeOwnerShadyRoot(n);\n\t\t      }\n\t\t    }\n\t\t    node.__ownerShadyRoot = undefined;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): This will fail if distribution that affects this\n\t\t  // question is pending; this is expected to be exceedingly rare, but if\n\t\t  // the issue comes up, we can force a flush in this case.\n\t\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t\t    var root = this.getRootNode(insertionPoint);\n\t\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t\t      // means that we're composed to this spot.\n\t\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t\t        return n;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  clearNode: function clearNode(node) {\n\t\t    while (node.firstChild) {\n\t\t      node.removeChild(node.firstChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t\t    var parent = tree.Logical.getParentNode(node);\n\t\t    if (this._nodeNeedsDistribution(parent)) {\n\t\t      parent.shadyRoot.update();\n\t\t      return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t\t    if (name === 'slot') {\n\t\t      this.maybeDistributeParent(node);\n\t\t    } else if (node.localName === 'slot' && name === 'name') {\n\t\t      var root = this.ownerShadyRootForNode(node);\n\t\t      if (root) {\n\t\t        root.update();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t\t  // but it's also generally useful to recurse through the element tree\n\t\t  // and is used by Polymer's styling system.\n\t\t  query: function query(node, matcher, halter) {\n\t\t    var list = [];\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t    return list;\n\t\t  },\n\t\t\n\t\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t\t          this$1._queryElement(c, matcher, halter, list)) {\n\t\t        return true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t\t    var result = matcher(node);\n\t\t    if (result) {\n\t\t      list.push(node);\n\t\t    }\n\t\t    if (halter && halter(result)) {\n\t\t      return result;\n\t\t    }\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t  },\n\t\t\n\t\t  activeElementForNode: function activeElementForNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var active = document.activeElement;\n\t\t    if (!active) {\n\t\t      return null;\n\t\t    }\n\t\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t\t    if (node !== document) {\n\t\t      // If this node isn't a document or shady root, then it doesn't have\n\t\t      // an active element.\n\t\t      if (!isShadyRoot$$1) {\n\t\t        return null;\n\t\t      }\n\t\t      // If this shady root's host is the active element or the active\n\t\t      // element is not a descendant of the host (in the composed tree),\n\t\t      // then it doesn't have an active element.\n\t\t      if (node.host === active ||\n\t\t          !node.host.contains(active)) {\n\t\t        return null;\n\t\t      }\n\t\t    }\n\t\t    // This node is either the document or a shady root of which the active\n\t\t    // element is a (composed) descendant of its host; iterate upwards to\n\t\t    // find the active element's most shallow host within it.\n\t\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t\t    while (activeRoot && activeRoot !== node) {\n\t\t      active = activeRoot.host;\n\t\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t\t    }\n\t\t    if (node === document) {\n\t\t      // This node is the document, so activeRoot should be null.\n\t\t      return activeRoot ? null : active;\n\t\t    } else {\n\t\t      // This node is a non-document shady root, and it should be\n\t\t      // activeRoot.\n\t\t      return activeRoot === node ? active : null;\n\t\t    }\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar nativeCloneNode = Element.prototype.cloneNode;\n\t\tvar nativeImportNode = Document.prototype.importNode;\n\t\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\t\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\t\n\t\tvar setAttribute = function(attr, value) {\n\t\t  if (window.ShadyCSS && attr === 'class') {\n\t\t    window.ShadyCSS.setElementClass(this, value);\n\t\t  } else {\n\t\t    nativeSetAttribute.call(this, attr, value);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar NodeMixin = {};\n\t\t\n\t\tObject.defineProperties(NodeMixin, {\n\t\t\n\t\t  parentElement: {\n\t\t    get: function get() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  parentNode: {\n\t\t    get: function get$1() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextSibling: {\n\t\t    get: function get$2() {\n\t\t      return tree.Logical.getNextSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousSibling: {\n\t\t    get: function get$3() {\n\t\t      return tree.Logical.getPreviousSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextElementSibling: {\n\t\t    get: function get$4() {\n\t\t      return tree.Logical.getNextElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousElementSibling: {\n\t\t    get: function get$5() {\n\t\t      return tree.Logical.getPreviousElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  assignedSlot: {\n\t\t    get: function get$6() {\n\t\t      return this._assignedSlot;\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tvar FragmentMixin = {\n\t\t\n\t\t  appendChild: function appendChild(node) {\n\t\t    return this.insertBefore(node);\n\t\t  },\n\t\t\n\t\t  // cases in which we may not be able to just do standard native call\n\t\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t\t  // has an insertion point)\n\t\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t\t  // container to container.host.\n\t\t  // 3. node is <content> (host of container needs distribution)\n\t\t  insertBefore: function insertBefore(node, ref_node) {\n\t\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t\t        'of this node');\n\t\t    }\n\t\t    // remove node from its current position iff it's in a tree.\n\t\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var parent = tree.Logical.getParentNode(node);\n\t\t      mixinImpl.removeNodeFromParent(node, parent);\n\t\t    }\n\t\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t\t      if (ref_node) {\n\t\t        // if ref_node is an insertion point replace with first distributed node\n\t\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t\t        if (root) {\n\t\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t\t        }\n\t\t      }\n\t\t      // if adding to a shadyRoot, add to host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host : this;\n\t\t      if (ref_node) {\n\t\t        tree.Composed.insertBefore(container, node, ref_node);\n\t\t      } else {\n\t\t        tree.Composed.appendChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t    Removes the given `node` from the element's `lightChildren`.\n\t\t    This method also performs dom composition.\n\t\t  */\n\t\t  removeChild: function removeChild(node) {\n\t\t    if (tree.Logical.getParentNode(node) !== this) {\n\t\t      throw Error('The node to be removed is not a child of this node: ' +\n\t\t        node);\n\t\t    }\n\t\t    if (!mixinImpl.removeNode(node)) {\n\t\t      // if removing from a shadyRoot, remove form host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host :\n\t\t        this;\n\t\t      // not guaranteed to physically be in container; e.g.\n\t\t      // undistributed nodes.\n\t\t      var parent = tree.Composed.getParentNode(node);\n\t\t      if (container === parent) {\n\t\t        tree.Composed.removeChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, null, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  replaceChild: function replaceChild(node, ref_node) {\n\t\t    this.insertBefore(node, ref_node);\n\t\t    this.removeChild(ref_node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t\t  querySelector: function querySelector(selector) {\n\t\t    // match selector and halt on first result.\n\t\t    var result = mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    }, function(n) {\n\t\t      return Boolean(n);\n\t\t    })[0];\n\t\t    return result || null;\n\t\t  },\n\t\t\n\t\t  querySelectorAll: function querySelectorAll(selector) {\n\t\t    return mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    });\n\t\t  },\n\t\t\n\t\t  cloneNode: function cloneNode(deep) {\n\t\t    if (this.localName == 'template') {\n\t\t      return nativeCloneNode.call(this, deep);\n\t\t    } else {\n\t\t      var n = nativeCloneNode.call(this, false);\n\t\t      if (deep) {\n\t\t        var c$ = this.childNodes;\n\t\t        for (var i=0, nc; i < c$.length; i++) {\n\t\t          nc = c$[i].cloneNode(true);\n\t\t          n.appendChild(nc);\n\t\t        }\n\t\t      }\n\t\t      return n;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  importNode: function importNode(externalNode, deep) {\n\t\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t\t    var doc = this instanceof Document ? this :\n\t\t      this.ownerDocument;\n\t\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t\t    if (deep) {\n\t\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t\t      common.patchNode(n);\n\t\t      for (var i=0, nc; i < c$.length; i++) {\n\t\t        nc = doc.importNode(c$[i], true);\n\t\t        n.appendChild(nc);\n\t\t      }\n\t\t    }\n\t\t    return n;\n\t\t  }\n\t\t};\n\t\t\n\t\tObject.defineProperties(FragmentMixin, {\n\t\t\n\t\t  childNodes: {\n\t\t    get: function get$7() {\n\t\t      var c$ = tree.Logical.getChildNodes(this);\n\t\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  children: {\n\t\t    get: function get$8() {\n\t\t      if (tree.Logical.hasChildNodes(this)) {\n\t\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t\t        });\n\t\t      } else {\n\t\t        return tree.arrayCopyChildren(this);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstChild: {\n\t\t    get: function get$9() {\n\t\t      return tree.Logical.getFirstChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastChild: {\n\t\t    get: function get$10() {\n\t\t      return tree.Logical.getLastChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstElementChild: {\n\t\t    get: function get$11() {\n\t\t      return tree.Logical.getFirstElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastElementChild: {\n\t\t    get: function get$12() {\n\t\t      return tree.Logical.getLastElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t\t  // textContent / innerHTML\n\t\t  textContent: {\n\t\t    get: function get$13() {\n\t\t      if (this.childNodes) {\n\t\t        var tc = [];\n\t\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t\t            tc.push(c.textContent);\n\t\t          }\n\t\t        }\n\t\t        return tc.join('');\n\t\t      }\n\t\t      return '';\n\t\t    },\n\t\t    set: function set(text) {\n\t\t      mixinImpl.clearNode(this);\n\t\t      if (text) {\n\t\t        this.appendChild(document.createTextNode(text));\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  innerHTML: {\n\t\t    get: function get$14() {\n\t\t      return getInnerHTML(this);\n\t\t    },\n\t\t    set: function set$1(text) {\n\t\t      var this$1 = this;\n\t\t\n\t\t      mixinImpl.clearNode(this);\n\t\t      var d = document.createElement('div');\n\t\t      d.innerHTML = text;\n\t\t      // here, appendChild may move nodes async so we cannot rely\n\t\t      // on node position when copying\n\t\t      var c$ = tree.arrayCopyChildNodes(d);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1.appendChild(c$[i]);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar ElementMixin = {\n\t\t\n\t\t  // TODO(sorvell): should only exist on <slot>\n\t\t  assignedNodes: function assignedNodes(options) {\n\t\t    return (options && options.flatten ? this._distributedNodes :\n\t\t      this._assignedNodes) || [];\n\t\t  },\n\t\t\n\t\t\n\t\t  setAttribute: function setAttribute$1(name, value) {\n\t\t    setAttribute.call(this, name, value);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  },\n\t\t\n\t\t  removeAttribute: function removeAttribute(name) {\n\t\t    nativeRemoveAttribute.call(this, name);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tObject.defineProperties(ElementMixin, {\n\t\t\n\t\t  shadowRoot: {\n\t\t    get: function get$15() {\n\t\t      return this.shadyRoot;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  slot: {\n\t\t    get: function get$16() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set$2(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar activeElementDescriptor = {\n\t\t  get: function get$17() {\n\t\t    return mixinImpl.activeElementForNode(this);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar ActiveElementMixin = {};\n\t\tObject.defineProperties(ActiveElementMixin, {\n\t\t  activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar UnderActiveElementMixin = {};\n\t\tObject.defineProperties(UnderActiveElementMixin, {\n\t\t  _activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar Mixins = {\n\t\t\n\t\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\t\n\t\t  Fragment: extendAll({__patched: 'Fragment'},\n\t\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\t\n\t\t  Element: extendAll({__patched: 'Element'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\t\n\t\t  // Note: activeElement cannot be patched on document!\n\t\t  Document: extendAll({__patched: 'Document'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\t\n\t\t};\n\t\t\n\t\tvar getRootNode = function(node) {\n\t\t  return mixinImpl.getRootNode(node);\n\t\t}\n\t\t\n\t\tfunction filterMutations(mutations, target) {\n\t\t  var targetRootNode = getRootNode(target);\n\t\t  return mutations.filter(function(mutation) {\n\t\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t\t    if (mutationInScope && mutation.addedNodes) {\n\t\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t\t        return (targetRootNode === getRootNode(n));\n\t\t      });\n\t\t      Object.defineProperty(mutation, 'addedNodes', {\n\t\t        value: nodes,\n\t\t        configurable: true\n\t\t      });\n\t\t    }\n\t\t    return mutationInScope &&\n\t\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t\t  });\n\t\t}\n\t\t\n\t\t// const promise = Promise.resolve();\n\t\t\n\t\tvar AsyncObserver = function AsyncObserver() {\n\t\t  this._scheduled = false;\n\t\t  this.addedNodes = [];\n\t\t  this.removedNodes = [];\n\t\t  this.callbacks = new Set();\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.schedule = function schedule () {\n\t\t    var this$1 = this;\n\t\t\n\t\t  if (!this._scheduled) {\n\t\t    this._scheduled = true;\n\t\t    promish.then(function () {\n\t\t      this$1.flush();\n\t\t    });\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.flush = function flush () {\n\t\t  if (this._scheduled) {\n\t\t    this._scheduled = false;\n\t\t    var mutations = this.takeRecords();\n\t\t    if (mutations.length) {\n\t\t      this.callbacks.forEach(function(cb) {\n\t\t        cb(mutations);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t\t    var mutations = [{\n\t\t      addedNodes: this.addedNodes,\n\t\t      removedNodes: this.removedNodes\n\t\t    }];\n\t\t    this.addedNodes = [];\n\t\t    this.removedNodes = [];\n\t\t    return mutations;\n\t\t  }\n\t\t  return [];\n\t\t};\n\t\t\n\t\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t\t// directly so that users do not have to fork their code.\n\t\t// Supporting the entire api may be challenging: e.g. filtering out\n\t\t// removed nodes in the wrong scope and seeing non-distributing\n\t\t// subtree child mutations.\n\t\tvar observeChildren = function(node, callback) {\n\t\t  common.patchNode(node);\n\t\t  if (!node.__dom.observer) {\n\t\t    node.__dom.observer = new AsyncObserver();\n\t\t  }\n\t\t  node.__dom.observer.callbacks.add(callback);\n\t\t  var observer = node.__dom.observer;\n\t\t  return {\n\t\t    _callback: callback,\n\t\t    _observer: observer,\n\t\t    _node: node,\n\t\t    takeRecords: function takeRecords() {\n\t\t      return observer.takeRecords()\n\t\t    }\n\t\t  };\n\t\t}\n\t\t\n\t\tvar unobserveChildren = function(handle) {\n\t\t  var observer = handle && handle._observer;\n\t\t  if (observer) {\n\t\t    observer.callbacks.delete(handle._callback);\n\t\t    if (!observer.callbacks.size) {\n\t\t      handle._node.__dom.observer = null;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tvar patchedCount = 0;\n\t\t\n\t\tvar log = false;\n\t\t\n\t\tvar patchImpl = {\n\t\t\n\t\t  canPatchNode: function(node) {\n\t\t    switch (node) {\n\t\t      case document.head:\n\t\t      case document.documentElement:\n\t\t        return false;\n\t\t      default:\n\t\t        return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t\t    window.Node.prototype, 'textContent')),\n\t\t\n\t\t  patch: function(node) {\n\t\t    patchedCount++;\n\t\t    log && window.console.warn('patch node', node);\n\t\t    if (this.hasPrototypeDescriptors) {\n\t\t      patchPrototype(node, this.mixinForObject(node));\n\t\t    } else {\n\t\t      window.console.warn('Patching instance rather than prototype', node);\n\t\t      extend(node, this.mixinForNode(node));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  mixinForObject: function(obj) {\n\t\t    switch (obj.nodeType) {\n\t\t      case Node.ELEMENT_NODE:\n\t\t        return Mixins.Element;\n\t\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t\t        return Mixins.Fragment;\n\t\t      case Node.DOCUMENT_NODE:\n\t\t        return Mixins.Document;\n\t\t      case Node.TEXT_NODE:\n\t\t      case Node.COMMENT_NODE:\n\t\t        return Mixins.Node;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  unpatch: function(obj) {\n\t\t    if (obj.__sourceProto) {\n\t\t      obj.__proto__ = obj.__sourceProto;\n\t\t\n\t\t    }\n\t\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction patchNode(node) {\n\t\t  if (!settings.inUse) {\n\t\t    return;\n\t\t  }\n\t\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t\t    tree.saveChildNodes(node);\n\t\t    patchImpl.patch(node);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction unpatchNode(node) {\n\t\t  patchImpl.unpatch(node);\n\t\t}\n\t\t\n\t\tfunction isNodePatched(node) {\n\t\t  return Boolean(node.__patched);\n\t\t}\n\t\t\n\t\t// TODO(sorvell): fake export\n\t\tcommon.patchNode = patchNode;\n\t\tcommon.isNodePatched = isNodePatched;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar origAddEventListener = Element.prototype.addEventListener;\n\t\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\t\n\t\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\t\tvar alwaysComposed = {\n\t\t  blur: true,\n\t\t  focus: true,\n\t\t  focusin: true,\n\t\t  focusout: true,\n\t\t  click: true,\n\t\t  dblclick: true,\n\t\t  mousedown: true,\n\t\t  mouseenter: true,\n\t\t  mouseleave: true,\n\t\t  mousemove: true,\n\t\t  mouseout: true,\n\t\t  mouseover: true,\n\t\t  mouseup: true,\n\t\t  wheel: true,\n\t\t  beforeinput: true,\n\t\t  input: true,\n\t\t  keydown: true,\n\t\t  keyup: true,\n\t\t  compositionstart: true,\n\t\t  compositionupdate: true,\n\t\t  compositionend: true,\n\t\t  touchstart: true,\n\t\t  touchend: true,\n\t\t  touchmove: true,\n\t\t  touchcancel: true,\n\t\t  pointerover: true,\n\t\t  pointerenter: true,\n\t\t  pointerdown: true,\n\t\t  pointermove: true,\n\t\t  pointerup: true,\n\t\t  pointercancel: true,\n\t\t  pointerout: true,\n\t\t  pointerleave: true,\n\t\t  gotpointercapture: true,\n\t\t  lostpointercapture: true,\n\t\t  dragstart: true,\n\t\t  drag: true,\n\t\t  dragenter: true,\n\t\t  dragleave: true,\n\t\t  dragover: true,\n\t\t  drop: true,\n\t\t  dragend: true,\n\t\t  DOMActivate: true,\n\t\t  DOMFocusIn: true,\n\t\t  DOMFocusOut: true,\n\t\t  keypress: true\n\t\t};\n\t\t\n\t\tfunction pathComposer(startNode, composed) {\n\t\t  var composedPath = [];\n\t\t  var current = startNode;\n\t\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t\t  while (current) {\n\t\t    composedPath.push(current);\n\t\t    if (current.assignedSlot) {\n\t\t      current = current.assignedSlot;\n\t\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t\t      current = current.host;\n\t\t    } else {\n\t\t      current = current.parentNode;\n\t\t    }\n\t\t  }\n\t\t  // event composedPath includes window when startNode's ownerRoot is document\n\t\t  if (composedPath[composedPath.length - 1] === document) {\n\t\t    composedPath.push(window);\n\t\t  }\n\t\t  return composedPath;\n\t\t}\n\t\t\n\t\tfunction retarget(refNode, path) {\n\t\t  if (!isShadyRoot) {\n\t\t    return refNode;\n\t\t  }\n\t\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t\t  var refNodePath = pathComposer(refNode, true);\n\t\t  var p$ = path;\n\t\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t\t    ancestor = p$[i];\n\t\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t\t    if (root !== lastRoot) {\n\t\t      rootIdx = refNodePath.indexOf(root);\n\t\t      lastRoot = root;\n\t\t    }\n\t\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t\t      return ancestor;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tvar EventMixin = {\n\t\t\n\t\t  __patched: 'Event',\n\t\t\n\t\t  get composed() {\n\t\t    if (this.isTrusted && this.__composed === undefined) {\n\t\t      this.__composed = alwaysComposed[this.type];\n\t\t    }\n\t\t    return this.__composed || false;\n\t\t  },\n\t\t\n\t\t  composedPath: function composedPath() {\n\t\t    if (!this.__composedPath) {\n\t\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t\t    }\n\t\t    return this.__composedPath;\n\t\t  },\n\t\t\n\t\t  get target() {\n\t\t    return retarget(this.currentTarget, this.composedPath());\n\t\t  },\n\t\t\n\t\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t\t  get relatedTarget() {\n\t\t    if (!this.__relatedTarget) {\n\t\t      return null;\n\t\t    }\n\t\t    if (!this.__relatedTargetComposedPath) {\n\t\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t\t    }\n\t\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t\t  },\n\t\t  stopPropagation: function stopPropagation() {\n\t\t    Event.prototype.stopPropagation.call(this);\n\t\t    this.__propagationStopped = true;\n\t\t  },\n\t\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t\t    Event.prototype.stopImmediatePropagation.call(this);\n\t\t    this.__immediatePropagationStopped = true;\n\t\t    this.__propagationStopped = true;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction mixinComposedFlag(Base) {\n\t\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t\t  // try to do `Base.call` with a dom construtor.\n\t\t  var klazz = function(type, options) {\n\t\t    var event = new Base(type, options);\n\t\t    event.__composed = options && Boolean(options.composed);\n\t\t    return event;\n\t\t  }\n\t\t  // put constructor properties on subclass\n\t\t  mixin(klazz, Base);\n\t\t  klazz.prototype = Base.prototype;\n\t\t  return klazz;\n\t\t}\n\t\t\n\t\tvar nonBubblingEventsToRetarget = {\n\t\t  focus: true,\n\t\t  blur: true\n\t\t};\n\t\t\n\t\tfunction fireHandlers(event, node, phase) {\n\t\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t\t    node.__handlers[event.type][phase];\n\t\t  if (hs) {\n\t\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t\t      fn.call(node, event);\n\t\t      if (event.__immediatePropagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction retargetNonBubblingEvent(e) {\n\t\t  var path = e.composedPath();\n\t\t  var node;\n\t\t  // override `currentTarget` to let patched `target` calculate correctly\n\t\t  Object.defineProperty(e, 'currentTarget', {\n\t\t    get: function() {\n\t\t      return node;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t  for (var i = path.length - 1; i >= 0; i--) {\n\t\t    node = path[i];\n\t\t    // capture phase fires all capture handlers\n\t\t    fireHandlers(e, node, 'capture');\n\t\t    if (e.__propagationStopped) {\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t\n\t\t  // set the event phase to `AT_TARGET` as in spec\n\t\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\t\n\t\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t\t  // keep track of the last seen owner root\n\t\t  var lastFiredRoot;\n\t\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t\t    node = path[i$1];\n\t\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t\t      fireHandlers(e, node, 'bubble');\n\t\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t\t      if (node !== window) {\n\t\t        lastFiredRoot = node.getRootNode();\n\t\t      }\n\t\t      if (e.__propagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t\t  // It's more efficient to store the node/type/options information as Array in\n\t\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  if (fn.__eventWrappers) {\n\t\t    // Stop if the wrapper function has already been created.\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    fn.__eventWrappers = [];\n\t\t  }\n\t\t\n\t\t  var wrapperFn = function(e) {\n\t\t    // Support `once` option.\n\t\t    if (once) {\n\t\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t\t    }\n\t\t    if (!e.__target) {\n\t\t      e.__target = e.target;\n\t\t      e.__relatedTarget = e.relatedTarget;\n\t\t      patchPrototype(e, EventMixin);\n\t\t    }\n\t\t    // There are two critera that should stop events from firing on this node\n\t\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t\t        if (e.target === e.relatedTarget) {\n\t\t          e.stopImmediatePropagation();\n\t\t          return;\n\t\t        }\n\t\t      }\n\t\t      return fn(e);\n\t\t    }\n\t\t  };\n\t\t  // Store the wrapper information.\n\t\t  fn.__eventWrappers.push({\n\t\t    node: this,\n\t\t    type: type,\n\t\t    capture: capture,\n\t\t    once: once,\n\t\t    passive: passive,\n\t\t    wrapperFn: wrapperFn\n\t\t  });\n\t\t\n\t\t  if (nonBubblingEventsToRetarget[type]) {\n\t\t    this.__handlers = this.__handlers || {};\n\t\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t\t  } else {\n\t\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  // Search the wrapped function.\n\t\t  var wrapperFn = undefined;\n\t\t  if (fn.__eventWrappers) {\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t\t        // Cleanup.\n\t\t        if (!fn.__eventWrappers.length) {\n\t\t          fn.__eventWrappers = undefined;\n\t\t        }\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t\n\t\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t\t      this.__handlers && this.__handlers[type]) {\n\t\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t\t    var idx = arr.indexOf(wrapperFn);\n\t\t    if (idx > -1) {\n\t\t      arr.splice(idx, 1);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction activateFocusEventOverrides() {\n\t\t  for (var ev in nonBubblingEventsToRetarget) {\n\t\t    window.addEventListener(ev, function(e) {\n\t\t      if (!e.__target) {\n\t\t        e.__target = e.target;\n\t\t        e.__relatedTarget = e.relatedTarget;\n\t\t        patchPrototype(e, EventMixin);\n\t\t        retargetNonBubblingEvent(e);\n\t\t        e.stopImmediatePropagation();\n\t\t      }\n\t\t    }, true);\n\t\t  }\n\t\t}\n\t\t\n\t\t\n\t\tvar PatchedEvent = mixinComposedFlag(Event);\n\t\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\t\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tif (settings.inUse) {\n\t\t\n\t\t  window.ShadyDOM = {\n\t\t    tree: tree,\n\t\t    getNativeProperty: getNativeProperty,\n\t\t    patch: patchNode,\n\t\t    isPatched: isNodePatched,\n\t\t    unpatch: unpatchNode,\n\t\t    isShadyRoot: isShadyRoot,\n\t\t    enqueue: enqueue,\n\t\t    flush: flush$1,\n\t\t    inUse: settings.inUse,\n\t\t    filterMutations: filterMutations,\n\t\t    observeChildren: observeChildren,\n\t\t    unobserveChildren: unobserveChildren\n\t\t  };\n\t\t\n\t\t  var createRootAndEnsurePatched = function(node) {\n\t\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t\t    // a timing problem with gathering composed children.\n\t\t    // (1) currently the child list is crawled and patched when patching occurs\n\t\t    // (this needs to change)\n\t\t    // (2) we can only patch when an element has received its parsed children\n\t\t    // because we cannot detect them when inserted by parser.\n\t\t    // let ancestor = node;\n\t\t    // while (ancestor) {\n\t\t    //   patchNode(ancestor);\n\t\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t\t    // }\n\t\t    patchNode(node);\n\t\t    var root = new ShadyRoot(node);\n\t\t    patchNode(root);\n\t\t    return root;\n\t\t  }\n\t\t\n\t\t  Element.prototype.attachShadow = function() {\n\t\t    return createRootAndEnsurePatched(this);\n\t\t  }\n\t\t\n\t\t  Node.prototype.addEventListener = addEventListener;\n\t\t  Node.prototype.removeEventListener = removeEventListener;\n\t\t  Event = PatchedEvent;\n\t\t  CustomEvent = PatchedCustomEvent;\n\t\t  MouseEvent = PatchedMouseEvent;\n\t\t  activateFocusEventOverrides();\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t\t    get: function get() {\n\t\t      return document.documentElement.contains(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Node.prototype.getRootNode = function(options) {\n\t\t    return getRootNode(this, options);\n\t\t  }\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'slot', {\n\t\t    get: function get$1() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t\t    get: function get$2() {\n\t\t      return this._assignedSlot || null;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Element.prototype.setAttribute = setAttribute;\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'className', {\n\t\t    get: function get$3() {\n\t\t      return this.getAttribute('class');\n\t\t    },\n\t\t    set: function set$1(value) {\n\t\t      this.setAttribute('class', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t\t  // via appendChild. This either needs to be expanded or contracted.\n\t\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t\t  //   patchNode(this);\n\t\t  //   return this.appendChild(node);\n\t\t  // }\n\t\t\n\t\t}\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadydom.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tExtremely simple css parser. Intended to be not more than what we need\n\t\tand definitely not necessarily correct =).\n\t\t*/\n\t\t\n\t\t// given a string of css, return a simple rule tree\n\t\t\n\t\tfunction parse(text) {\n\t\t  text = clean(text);\n\t\t  return parseCss(lex(text), text);\n\t\t}\n\t\t\n\t\t// remove stuff we don't care about that may hinder parsing\n\t\tfunction clean(cssText) {\n\t\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t\t}\n\t\t\n\t\t// super simple {...} lexer that returns a node tree\n\t\tfunction lex(text) {\n\t\t  var root = {\n\t\t    start: 0,\n\t\t    end: text.length\n\t\t  };\n\t\t  var n = root;\n\t\t  for (var i = 0, l = text.length; i < l; i++) {\n\t\t    if (text[i] === OPEN_BRACE) {\n\t\t      if (!n.rules) {\n\t\t        n.rules = [];\n\t\t      }\n\t\t      var p = n;\n\t\t      var previous = p.rules[p.rules.length - 1];\n\t\t      n = {\n\t\t        start: i + 1,\n\t\t        parent: p,\n\t\t        previous: previous\n\t\t      };\n\t\t      p.rules.push(n);\n\t\t    } else if (text[i] === CLOSE_BRACE) {\n\t\t      n.end = i + 1;\n\t\t      n = n.parent || root;\n\t\t    }\n\t\t  }\n\t\t  return root;\n\t\t}\n\t\t\n\t\t// add selectors/cssText to node tree\n\t\tfunction parseCss(node, text) {\n\t\t  var t = text.substring(node.start, node.end - 1);\n\t\t  node.parsedCssText = node.cssText = t.trim();\n\t\t  if (node.parent) {\n\t\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t\t    t = text.substring(ss, node.start - 1);\n\t\t    t = _expandUnicodeEscapes(t);\n\t\t    t = t.replace(RX.multipleSpaces, ' ');\n\t\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t\t    // helps with mixin syntax\n\t\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t\t    var s = node.parsedSelector = node.selector = t.trim();\n\t\t    node.atRule = s.indexOf(AT_START) === 0;\n\t\t    // note, support a subset of rule types...\n\t\t    if (node.atRule) {\n\t\t      if (s.indexOf(MEDIA_START) === 0) {\n\t\t        node.type = types.MEDIA_RULE;\n\t\t      } else if (s.match(RX.keyframesRule)) {\n\t\t        node.type = types.KEYFRAMES_RULE;\n\t\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t\t      }\n\t\t    } else {\n\t\t      if (s.indexOf(VAR_START) === 0) {\n\t\t        node.type = types.MIXIN_RULE;\n\t\t      } else {\n\t\t        node.type = types.STYLE_RULE;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      parseCss(r, text);\n\t\t    }\n\t\t  }\n\t\t  return node;\n\t\t}\n\t\t\n\t\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t\t// expanded form that doesn't require trailing space `\\000033`\n\t\tfunction _expandUnicodeEscapes(s) {\n\t\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t\t    var code = arguments[1],\n\t\t        repeat = 6 - code.length;\n\t\t    while (repeat--) {\n\t\t      code = '0' + code;\n\t\t    }\n\t\t    return '\\\\' + code;\n\t\t  });\n\t\t}\n\t\t\n\t\t// stringify parsed css.\n\t\tfunction stringify(node, preserveProperties, text) {\n\t\t  text = text || '';\n\t\t  // calc rule cssText\n\t\t  var cssText = '';\n\t\t  if (node.cssText || node.rules) {\n\t\t    var r$ = node.rules;\n\t\t    if (r$ && !_hasMixinRules(r$)) {\n\t\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t        cssText = stringify(r, preserveProperties, cssText);\n\t\t      }\n\t\t    } else {\n\t\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t\t      cssText = cssText.trim();\n\t\t      if (cssText) {\n\t\t        cssText = '  ' + cssText + '\\n';\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  // emit rule if there is cssText\n\t\t  if (cssText) {\n\t\t    if (node.selector) {\n\t\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t\t    }\n\t\t    text += cssText;\n\t\t    if (node.selector) {\n\t\t      text += CLOSE_BRACE + '\\n\\n';\n\t\t    }\n\t\t  }\n\t\t  return text;\n\t\t}\n\t\t\n\t\tfunction _hasMixinRules(rules) {\n\t\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t\t}\n\t\t\n\t\tfunction removeCustomProps(cssText) {\n\t\t  cssText = removeCustomPropAssignment(cssText);\n\t\t  return removeCustomPropApply(cssText);\n\t\t}\n\t\t\n\t\tfunction removeCustomPropAssignment(cssText) {\n\t\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t\t}\n\t\t\n\t\tfunction removeCustomPropApply(cssText) {\n\t\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t\t}\n\t\t\n\t\tvar types = {\n\t\t  STYLE_RULE: 1,\n\t\t  KEYFRAMES_RULE: 7,\n\t\t  MEDIA_RULE: 4,\n\t\t  MIXIN_RULE: 1000\n\t\t};\n\t\t\n\t\tvar OPEN_BRACE = '{';\n\t\tvar CLOSE_BRACE = '}';\n\t\t\n\t\t// helper regexp's\n\t\tvar RX = {\n\t\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t\t  port: /@import[^;]*;/gim,\n\t\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t\t  multipleSpaces: /\\s+/g\n\t\t};\n\t\t\n\t\tvar VAR_START = '--';\n\t\tvar MEDIA_START = '@media';\n\t\tvar AT_START = '@';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\t\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\t\n\t\t// experimental support for native @apply\n\t\tfunction detectNativeApply() {\n\t\t  var style = document.createElement('style');\n\t\t  style.textContent = '.foo { @apply --foo }';\n\t\t  document.head.appendChild(style);\n\t\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t\t  document.head.removeChild(style);\n\t\t  return nativeCssApply;\n\t\t}\n\t\t\n\t\tvar nativeCssApply = false && detectNativeApply();\n\t\t\n\t\tfunction parseSettings(settings) {\n\t\t  if (settings) {\n\t\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t\t  }\n\t\t}\n\t\t\n\t\tif (window.ShadyCSS) {\n\t\t  parseSettings(window.ShadyCSS);\n\t\t} else if (window.WebComponents) {\n\t\t  parseSettings(window.WebComponents.flags);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction toCssText(rules, callback) {\n\t\t  if (typeof rules === 'string') {\n\t\t    rules = parse(rules);\n\t\t  }\n\t\t  if (callback) {\n\t\t    forEachRule(rules, callback);\n\t\t  }\n\t\t  return stringify(rules, nativeCssVariables);\n\t\t}\n\t\t\n\t\tfunction rulesForStyle(style) {\n\t\t  if (!style.__cssRules && style.textContent) {\n\t\t    style.__cssRules = parse(style.textContent);\n\t\t  }\n\t\t  return style.__cssRules;\n\t\t}\n\t\t\n\t\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t\t// like a normal selector but is not (it has nothing to do with scoping\n\t\t// for example).\n\t\tfunction isKeyframesSelector(rule) {\n\t\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t\t}\n\t\t\n\t\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t\t  if (!node) {\n\t\t    return;\n\t\t  }\n\t\t  var skipRules = false;\n\t\t  if (onlyActiveRules) {\n\t\t    if (node.type === types.MEDIA_RULE) {\n\t\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t\t      if (matchMedia) {\n\t\t        // if rule is a non matching @media rule, skip subrules\n\t\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t\t          skipRules = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  if (node.type === types.STYLE_RULE) {\n\t\t    styleRuleCallback(node);\n\t\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t\t    keyframesRuleCallback(node);\n\t\t  } else if (node.type === types.MIXIN_RULE) {\n\t\t    skipRules = true;\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$ && !skipRules) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t// add a string of cssText to the document.\n\t\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t\t  var style = createScopeStyle(cssText, moniker);\n\t\t  return applyStyle$1(style, target, contextNode);\n\t\t}\n\t\t\n\t\tfunction applyStyle$1(style, target, contextNode) {\n\t\t  target = target || document.head;\n\t\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t\t  lastHeadApplyNode = style;\n\t\t  return target.insertBefore(style, after);\n\t\t}\n\t\t\n\t\tfunction createScopeStyle(cssText, moniker) {\n\t\t  var style = document.createElement('style');\n\t\t  if (moniker) {\n\t\t    style.setAttribute('scope', moniker);\n\t\t  }\n\t\t  style.textContent = cssText;\n\t\t  return style;\n\t\t}\n\t\t\n\t\tvar lastHeadApplyNode = null;\n\t\t\n\t\t// insert a comment node as a styling position placeholder.\n\t\tfunction applyStylePlaceHolder(moniker) {\n\t\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t\t  var scope = document.head;\n\t\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t\t  lastHeadApplyNode = placeHolder;\n\t\t  return placeHolder;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t// cssBuildTypeForModule: function (module) {\n\t\t//   let dm = Polymer.DomModule.import(module);\n\t\t//   if (dm) {\n\t\t//     return getCssBuildType(dm);\n\t\t//   }\n\t\t// },\n\t\t//\n\t\t\n\t\t\n\t\t// Walk from text[start] matching parens\n\t\t// returns position of the outer end paren\n\t\tfunction findMatchingParen(text, start) {\n\t\t  var level = 0;\n\t\t  for (var i = start, l = text.length; i < l; i++) {\n\t\t    if (text[i] === '(') {\n\t\t      level++;\n\t\t    } else if (text[i] === ')') {\n\t\t      if (--level === 0) {\n\t\t        return i;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return -1;\n\t\t}\n\t\t\n\t\tfunction processVariableAndFallback(str, callback) {\n\t\t  // find 'var('\n\t\t  var start = str.indexOf('var(');\n\t\t  if (start === -1) {\n\t\t    // no var?, everything is prefix\n\t\t    return callback(str, '', '', '');\n\t\t  }\n\t\t  //${prefix}var(${inner})${suffix}\n\t\t  var end = findMatchingParen(str, start + 3);\n\t\t  var inner = str.substring(start + 4, end);\n\t\t  var prefix = str.substring(0, start);\n\t\t  // suffix may have other variables\n\t\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t\t  var comma = inner.indexOf(',');\n\t\t  // value and fallback args should be trimmed to match in property lookup\n\t\t  if (comma === -1) {\n\t\t    // variable, no fallback\n\t\t    return callback(prefix, inner.trim(), '', suffix);\n\t\t  }\n\t\t  // var(${value},${fallback})\n\t\t  var value = inner.substring(0, comma).trim();\n\t\t  var fallback = inner.substring(comma + 1).trim();\n\t\t  return callback(prefix, value, fallback, suffix);\n\t\t}\n\t\t\n\t\tvar rx = {\n\t\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t\t  IS_VAR: /^--/,\n\t\t  BRACKETED: /\\{[^}]*\\}/g,\n\t\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\t\n\t\t* scoping:\n\t\t\n\t\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t\t  * selectors re-written as follows:\n\t\t\n\t\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\t\n\t\t* :host -> scopeName\n\t\t\n\t\t* :host(...) -> scopeName...\n\t\t\n\t\t* ::slotted(...) -> scopeName > ...\n\t\t\n\t\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\t\n\t\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\t\n\t\t*/\n\t\tvar SCOPE_NAME = 'style-scope';\n\t\t\n\t\tvar StyleTransformer = {\n\t\t\n\t\t  // Given a node and scope name, add a scoping class to each node\n\t\t  // in the tree. This facilitates transforming css into scoped rules.\n\t\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t\t    // one time optimization to skip scoping...\n\t\t    if (node.__styleScoped) {\n\t\t      node.__styleScoped = null;\n\t\t    } else {\n\t\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t\t    if (node.classList) {\n\t\t      this.element(node, selector, shouldRemoveScope);\n\t\t    }\n\t\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t\t    if (c$) {\n\t\t      for (var i = 0; i < c$.length; i++) {\n\t\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  element: function element(_element, scope, shouldRemoveScope) {\n\t\t    // note: if using classes, we add both the general 'style-scope' class\n\t\t    // as well as the specific scope. This enables easy filtering of all\n\t\t    // `style-scope` elements\n\t\t    if (scope) {\n\t\t      // note: svg on IE does not have classList so fallback to class\n\t\t      if (_element.classList) {\n\t\t        if (shouldRemoveScope) {\n\t\t          _element.classList.remove(SCOPE_NAME);\n\t\t          _element.classList.remove(scope);\n\t\t        } else {\n\t\t          _element.classList.add(SCOPE_NAME);\n\t\t          _element.classList.add(scope);\n\t\t        }\n\t\t      } else if (_element.getAttribute) {\n\t\t        var c = _element.getAttribute(CLASS);\n\t\t        if (shouldRemoveScope) {\n\t\t          if (c) {\n\t\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t\t          }\n\t\t        } else {\n\t\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t\t    var cssBuildType = element.__cssBuild;\n\t\t    // no need to shim selectors if settings.useNativeShadow, also\n\t\t    // a shady css build will already have transformed selectors\n\t\t    // NOTE: This method may be called as part of static or property shimming.\n\t\t    // When there is a targeted build it will not be called for static shimming,\n\t\t    // but when the property shim is used it is called and should opt out of\n\t\t    // static shimming work when a proper build exists.\n\t\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t\t    return cssText.trim();\n\t\t  },\n\t\t\n\t\t  // Given a string of cssText and a scoping string (scope), returns\n\t\t  // a string of scoped css where each selector is transformed to include\n\t\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t\t  // (e.g. :host) to use the scoping selector.\n\t\t  css: function css(rules, scope, ext, callback) {\n\t\t    var hostScope = this._calcHostScope(scope, ext);\n\t\t    scope = this._calcElementScope(scope);\n\t\t    var self = this;\n\t\t    return toCssText(rules, function (rule) {\n\t\t      if (!rule.isScoped) {\n\t\t        self.rule(rule, scope, hostScope);\n\t\t        rule.isScoped = true;\n\t\t      }\n\t\t      if (callback) {\n\t\t        callback(rule, scope, hostScope);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _calcElementScope: function _calcElementScope(scope) {\n\t\t    if (scope) {\n\t\t      return CSS_CLASS_PREFIX + scope;\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t\t    return ext ? '[is=' + scope + ']' : scope;\n\t\t  },\n\t\t\n\t\t  rule: function rule(_rule, scope, hostScope) {\n\t\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  // transforms a css rule to a scoped rule.\n\t\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t\t    // against selectors (e.g. when calculating style properties)\n\t\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t\t    // we want to skip transformation of rules that appear in keyframes,\n\t\t    // because they are keyframe selectors, not element selectors.\n\t\t    if (!isKeyframesSelector(rule)) {\n\t\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t\t      }\n\t\t    }\n\t\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t\t  },\n\t\t\n\t\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t\t    var _this = this;\n\t\t\n\t\t    var stop = false;\n\t\t    selector = selector.trim();\n\t\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t\t    });\n\t\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t\t      if (!stop) {\n\t\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t\t        stop = stop || info.stop;\n\t\t        c = info.combinator;\n\t\t        s = info.value;\n\t\t      }\n\t\t      return c + s;\n\t\t    });\n\t\t    return selector;\n\t\t  },\n\t\t\n\t\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t\t    // replace :host with host scoping class\n\t\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t\t    if (selector.indexOf(HOST) >= 0) {\n\t\t      selector = this._transformHostSelector(selector, hostScope);\n\t\t      // replace other selectors with scoping class\n\t\t    } else if (slottedIndex !== 0) {\n\t\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t\t    }\n\t\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t\t    // also ignore left-side combinator\n\t\t    var slotted = false;\n\t\t    if (slottedIndex >= 0) {\n\t\t      combinator = '';\n\t\t      slotted = true;\n\t\t    }\n\t\t    // process scope jumping selectors up to the scope jump and then stop\n\t\t    var stop = void 0;\n\t\t    if (slotted) {\n\t\t      stop = true;\n\t\t      if (slotted) {\n\t\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t\t          return ' > ' + paren;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t\t    });\n\t\t    return { value: selector, combinator: combinator, stop: stop };\n\t\t  },\n\t\t\n\t\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t\t    p$[0] += scope;\n\t\t    return p$.join(PSEUDO_PREFIX);\n\t\t  },\n\t\t\n\t\t  // :host(...) -> scopeName...\n\t\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t\t    var m = selector.match(HOST_PAREN);\n\t\t    var paren = m && m[2].trim() || '';\n\t\t    if (paren) {\n\t\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t\t        // paren starts with a type selector\n\t\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t\t        // if the type selector is our hostScope then avoid pre-pending it\n\t\t        if (typeSelector === hostScope) {\n\t\t          return paren;\n\t\t          // otherwise, this selector should not match in this scope so\n\t\t          // output a bogus selector.\n\t\t        } else {\n\t\t          return SELECTOR_NO_MATCH;\n\t\t        }\n\t\t      } else {\n\t\t        // make sure to do a replace here to catch selectors like:\n\t\t        // `:host(.foo)::before`\n\t\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t\t          return hostScope + paren;\n\t\t        });\n\t\t      }\n\t\t      // if no paren, do a straight :host replacement.\n\t\t      // TODO(sorvell): this should not strictly be necessary but\n\t\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t\t      // which have been improperly used under Shady DOM. This should be\n\t\t      // deprecated.\n\t\t    } else {\n\t\t      return selector.replace(HOST, hostScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  documentRule: function documentRule(rule) {\n\t\t    // reset selector in case this is redone.\n\t\t    rule.selector = rule.parsedSelector;\n\t\t    this.normalizeRootSelector(rule);\n\t\t    this._transformRule(rule, this._transformDocumentSelector);\n\t\t  },\n\t\t\n\t\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t\t    if (rule.selector === ROOT) {\n\t\t      rule.selector = 'html';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t\t  },\n\t\t  SCOPE_NAME: SCOPE_NAME\n\t\t};\n\t\t\n\t\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\t\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\t\tvar COMPLEX_SELECTOR_SEP = ',';\n\t\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\t\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\t\tvar HOST = ':host';\n\t\tvar ROOT = ':root';\n\t\tvar SLOTTED = '::slotted';\n\t\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t\t// NOTE: this supports 1 nested () pair for things like\n\t\t// :host(:not([selected]), more general support requires\n\t\t// parsing which seems like overkill\n\t\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\t// similar to HOST_PAREN\n\t\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\t\tvar CSS_CLASS_PREFIX = '.';\n\t\tvar PSEUDO_PREFIX = ':';\n\t\tvar CLASS = 'class';\n\t\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\t\n\t\tvar classCallCheck = function (instance, Constructor) {\n\t\t  if (!(instance instanceof Constructor)) {\n\t\t    throw new TypeError(\"Cannot call a class as a function\");\n\t\t  }\n\t\t};\n\t\t\n\t\tvar createClass = function () {\n\t\t  function defineProperties(target, props) {\n\t\t    for (var i = 0; i < props.length; i++) {\n\t\t      var descriptor = props[i];\n\t\t      descriptor.enumerable = descriptor.enumerable || false;\n\t\t      descriptor.configurable = true;\n\t\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return function (Constructor, protoProps, staticProps) {\n\t\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t\t    return Constructor;\n\t\t  };\n\t\t}();\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar set$1 = function set$1(object, property, value, receiver) {\n\t\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\t\n\t\t  if (desc === undefined) {\n\t\t    var parent = Object.getPrototypeOf(object);\n\t\t\n\t\t    if (parent !== null) {\n\t\t      set$1(parent, property, value, receiver);\n\t\t    }\n\t\t  } else if (\"value\" in desc && desc.writable) {\n\t\t    desc.value = value;\n\t\t  } else {\n\t\t    var setter = desc.set;\n\t\t\n\t\t    if (setter !== undefined) {\n\t\t      setter.call(receiver, value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return value;\n\t\t};\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar toConsumableArray = function (arr) {\n\t\t  if (Array.isArray(arr)) {\n\t\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\t\n\t\t    return arr2;\n\t\t  } else {\n\t\t    return Array.from(arr);\n\t\t  }\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar StyleInfo = function () {\n\t\t  createClass(StyleInfo, null, [{\n\t\t    key: 'get',\n\t\t    value: function get(node) {\n\t\t      return node.__styleInfo;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'set',\n\t\t    value: function set(node, styleInfo) {\n\t\t      node.__styleInfo = styleInfo;\n\t\t      return styleInfo;\n\t\t    }\n\t\t  }]);\n\t\t\n\t\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t\t    classCallCheck(this, StyleInfo);\n\t\t\n\t\t    this.styleRules = ast || null;\n\t\t    this.placeholder = placeholder || null;\n\t\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t\t    this.overrideStyleProperties = {};\n\t\t    this.elementName = elementName || '';\n\t\t    this.cssBuild = cssBuild || '';\n\t\t    this.typeExtension = typeExtension || '';\n\t\t    this.styleProperties = null;\n\t\t    this.scopeSelector = null;\n\t\t    this.customStyle = null;\n\t\t  }\n\t\t\n\t\t  return StyleInfo;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO: dedupe with shady\n\t\tvar p = window.Element.prototype;\n\t\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\t\n\t\tvar StyleProperties = {\n\t\t\n\t\t  // decorates styles with rule info and returns an array of used style\n\t\t  // property names\n\t\t  decorateStyles: function decorateStyles(rules) {\n\t\t    var self = this,\n\t\t        props = {},\n\t\t        keyframes = [],\n\t\t        ruleIndex = 0;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      self.decorateRule(rule);\n\t\t      // mark in-order position of ast rule in styles block, used for cache key\n\t\t      rule.index = ruleIndex++;\n\t\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t\t    }, function onKeyframesRule(rule) {\n\t\t      keyframes.push(rule);\n\t\t    });\n\t\t    // Cache all found keyframes rules for later reference:\n\t\t    rules._keyframes = keyframes;\n\t\t    // return this list of property names *consumes* in these styles.\n\t\t    var names = [];\n\t\t    for (var i in props) {\n\t\t      names.push(i);\n\t\t    }\n\t\t    return names;\n\t\t  },\n\t\t\n\t\t  // decorate a single rule with property info\n\t\t  decorateRule: function decorateRule(rule) {\n\t\t    if (rule.propertyInfo) {\n\t\t      return rule.propertyInfo;\n\t\t    }\n\t\t    var info = {},\n\t\t        properties = {};\n\t\t    var hasProperties = this.collectProperties(rule, properties);\n\t\t    if (hasProperties) {\n\t\t      info.properties = properties;\n\t\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t\t      rule.rules = null;\n\t\t    }\n\t\t    info.cssText = this.collectCssText(rule);\n\t\t    rule.propertyInfo = info;\n\t\t    return info;\n\t\t  },\n\t\t\n\t\t  // collects the custom properties from a rule's cssText\n\t\t  collectProperties: function collectProperties(rule, properties) {\n\t\t    var info = rule.propertyInfo;\n\t\t    if (info) {\n\t\t      if (info.properties) {\n\t\t        Object.assign(properties, info.properties);\n\t\t        return true;\n\t\t      }\n\t\t    } else {\n\t\t      var m = void 0,\n\t\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t\t      var cssText = rule.parsedCssText;\n\t\t      var value = void 0;\n\t\t      var any = void 0;\n\t\t      while (m = rx$$1.exec(cssText)) {\n\t\t        // note: group 2 is var, 3 is mixin\n\t\t        value = (m[2] || m[3]).trim();\n\t\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t\t        if (value !== 'inherit' || value !== 'unset') {\n\t\t          properties[m[1].trim()] = value;\n\t\t        }\n\t\t        any = true;\n\t\t      }\n\t\t      return any;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // returns cssText of properties that consume variables/mixins\n\t\t  collectCssText: function collectCssText(rule) {\n\t\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t\t  },\n\t\t\n\t\t  // NOTE: we support consumption inside mixin assignment\n\t\t  // but not production, so strip out {...}\n\t\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t\t  },\n\t\t\n\t\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t\t    var m = void 0;\n\t\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t\t      var name = m[1];\n\t\t      // This regex catches all variable names, and following non-whitespace char\n\t\t      // If next char is not ':', then variable is a consumer\n\t\t      if (m[2] !== ':') {\n\t\t        props[name] = true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // turns custom properties into realized values.\n\t\t  reify: function reify(props) {\n\t\t    // big perf optimization here: reify only *own* properties\n\t\t    // since this object has __proto__ of the element's scope properties\n\t\t    var names = Object.getOwnPropertyNames(props);\n\t\t    for (var i = 0, n; i < names.length; i++) {\n\t\t      n = names[i];\n\t\t      props[n] = this.valueForProperty(props[n], props);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // given a property value, returns the reified value\n\t\t  // a property value may be:\n\t\t  // (1) a literal value like: red or 5px;\n\t\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t\t  // var(--a, var(--b));\n\t\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t\t  valueForProperty: function valueForProperty(property, props) {\n\t\t    var _this = this;\n\t\t\n\t\t    // case (1) default\n\t\t    // case (3) defines a mixin and we have to reify the internals\n\t\t    if (property) {\n\t\t      if (property.indexOf(';') >= 0) {\n\t\t        property = this.valueForProperties(property, props);\n\t\t      } else {\n\t\t        (function () {\n\t\t          // case (2) variable\n\t\t          var self = _this;\n\t\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t\t            if (!value) {\n\t\t              return prefix + suffix;\n\t\t            }\n\t\t            var propertyValue = self.valueForProperty(props[value], props);\n\t\t            // if value is \"initial\", then the variable should be treated as unset\n\t\t            if (!propertyValue || propertyValue === 'initial') {\n\t\t              // fallback may be --a or var(--a) or literal\n\t\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t\t              // for use with native css variables.\n\t\t              // Since we have full control, we can use `inherit` directly.\n\t\t              propertyValue = 'inherit';\n\t\t            }\n\t\t            return prefix + (propertyValue || '') + suffix;\n\t\t          };\n\t\t          property = processVariableAndFallback(property, fn);\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\t    return property && property.trim() || '';\n\t\t  },\n\t\t\n\t\t  // note: we do not yet support mixin within mixin\n\t\t  valueForProperties: function valueForProperties(property, props) {\n\t\t    var parts = property.split(';');\n\t\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t\t      if (_p = parts[i]) {\n\t\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t\t        if (m) {\n\t\t          _p = this.valueForProperty(props[m[1]], props);\n\t\t        } else {\n\t\t          var colon = _p.indexOf(':');\n\t\t          if (colon !== -1) {\n\t\t            var pp = _p.substring(colon);\n\t\t            pp = pp.trim();\n\t\t            pp = this.valueForProperty(pp, props) || pp;\n\t\t            _p = _p.substring(0, colon) + pp;\n\t\t          }\n\t\t        }\n\t\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t\t        // strip trailing ;\n\t\t        _p.slice(0, -1) : _p || '';\n\t\t      }\n\t\t    }\n\t\t    return parts.join(';');\n\t\t  },\n\t\t\n\t\t  applyProperties: function applyProperties(rule, props) {\n\t\t    var output = '';\n\t\t    // dynamically added sheets may not be decorated so ensure they are.\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (rule.propertyInfo.cssText) {\n\t\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t\t  // functions which take in cssText and spit out transformed cssText.\n\t\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t\t    var input = rule.cssText;\n\t\t    var output = rule.cssText;\n\t\t    if (rule.hasAnimations == null) {\n\t\t      // Cache whether or not the rule has any animations to begin with:\n\t\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t\t    }\n\t\t    // If there are no animations referenced, we can skip transforms:\n\t\t    if (rule.hasAnimations) {\n\t\t      var transform = void 0;\n\t\t      // If we haven't transformed this rule before, we iterate over all\n\t\t      // transforms:\n\t\t      if (rule.keyframeNamesToTransform == null) {\n\t\t        rule.keyframeNamesToTransform = [];\n\t\t        for (var keyframe in keyframeTransforms) {\n\t\t          transform = keyframeTransforms[keyframe];\n\t\t          output = transform(input);\n\t\t          // If the transform actually changed the CSS text, we cache the\n\t\t          // transform name for future use:\n\t\t          if (input !== output) {\n\t\t            input = output;\n\t\t            rule.keyframeNamesToTransform.push(keyframe);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        // If we already have a list of keyframe names that apply to this\n\t\t        // rule, we apply only those keyframe name transforms:\n\t\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t\t          input = transform(input);\n\t\t        }\n\t\t        output = input;\n\t\t      }\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Test if the rules in these styles matches the given `element` and if so,\n\t\t  // collect any custom properties into `props`.\n\t\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t\t    var props = {},\n\t\t        self = this;\n\t\t    // generates a unique key for these matches\n\t\t    var o = [];\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t\t      // time to only include ones that have properties\n\t\t      if (!rule.propertyInfo) {\n\t\t        self.decorateRule(rule);\n\t\t      }\n\t\t      // match element against transformedSelector: selector may contain\n\t\t      // unwanted uniquification and parsedSelector does not directly match\n\t\t      // for :host selectors.\n\t\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t\t          self.collectProperties(rule, props);\n\t\t          // produce numeric key for these matches for lookup\n\t\t          addToBitMask(rule.index, o);\n\t\t        }\n\t\t      }\n\t\t    }, null, true);\n\t\t    return { properties: props, key: o };\n\t\t  },\n\t\t\n\t\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (!rule.propertyInfo.properties) {\n\t\t      return;\n\t\t    }\n\t\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t\t    var parsedSelector = rule.parsedSelector;\n\t\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t\t    // build info is either in scope (when scope is an element) or in the style\n\t\t    // when scope is the default scope; note: this allows default scope to have\n\t\t    // mixed mode built and unbuilt styles.\n\t\t    if (cssBuild === 'shady') {\n\t\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t\t    }\n\t\t    if (cssBuild === 'shadow') {\n\t\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t      isHost = isHost && !isRoot;\n\t\t    }\n\t\t    if (!isRoot && !isHost) {\n\t\t      return;\n\t\t    }\n\t\t    var selectorToMatch = hostScope;\n\t\t    if (isHost) {\n\t\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t\t      if (nativeShadow && !rule.transformedSelector) {\n\t\t        // transform :host into a matchable selector\n\t\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t\t      }\n\t\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t\t    }\n\t\t    callback({\n\t\t      selector: selectorToMatch,\n\t\t      isHost: isHost,\n\t\t      isRoot: isRoot\n\t\t    });\n\t\t  },\n\t\t\n\t\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t\t    var hostProps = {},\n\t\t        rootProps = {},\n\t\t        self = this;\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    var cssBuild = rules && rules.__cssBuild;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t\t        var element = scope._element || scope;\n\t\t        if (matchesSelector.call(element, info.selector)) {\n\t\t          if (info.isHost) {\n\t\t            self.collectProperties(rule, hostProps);\n\t\t          } else {\n\t\t            self.collectProperties(rule, rootProps);\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }, null, true);\n\t\t    return { rootProps: rootProps, hostProps: hostProps };\n\t\t  },\n\t\t\n\t\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t\t    var self = this;\n\t\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t\t    var rules = StyleInfo.get(element).styleRules;\n\t\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t\t      self.applyProperties(rule, properties);\n\t\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t\t        // is not necessary to apply them in ShadowDOM.\n\t\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t\t    var keyframesRules = rules._keyframes;\n\t\t    var keyframeTransforms = {};\n\t\t    if (!nativeShadow && keyframesRules) {\n\t\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t\t      // advance for the current scope. This allows us to catch keyframes\n\t\t      // rules that appear anywhere in the stylesheet:\n\t\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t\t      }\n\t\t    }\n\t\t    return keyframeTransforms;\n\t\t  },\n\t\t\n\t\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t\t  // particular scoped keyframes rule.\n\t\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t\t    return function (cssText) {\n\t\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t\t    };\n\t\t  },\n\t\t\n\t\t  // Transforms `@keyframes` names to be unique for the current host.\n\t\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t\t  },\n\t\t\n\t\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t\t  // have low specificity. They are overrideable by class selectors but,\n\t\t  // unfortunately, not by type selectors (e.g. overriding via\n\t\t  // `.special` is ok, but not by `x-foo`).\n\t\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    var selector = rule.transformedSelector;\n\t\t    var scope = '.' + scopeId;\n\t\t    var parts = selector.split(',');\n\t\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t\t    }\n\t\t    rule.selector = parts.join(',');\n\t\t  },\n\t\t\n\t\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t\t    var c = element.getAttribute('class') || '';\n\t\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t\t    if (c !== v) {\n\t\t      element.setAttribute('class', v);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t\t    // calculate cssText to apply\n\t\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t\t    // if shady and we have a cached style that is not style, decrement\n\t\t    var styleInfo = StyleInfo.get(element);\n\t\t    var s = styleInfo.customStyle;\n\t\t    if (s && !nativeShadow && s !== style) {\n\t\t      s._useCount--;\n\t\t      if (s._useCount <= 0 && s.parentNode) {\n\t\t        s.parentNode.removeChild(s);\n\t\t      }\n\t\t    }\n\t\t    // apply styling always under native or if we generated style\n\t\t    // or the cached style is not in document(!)\n\t\t    if (nativeShadow) {\n\t\t      // update existing style only under native\n\t\t      if (styleInfo.customStyle) {\n\t\t        styleInfo.customStyle.textContent = cssText;\n\t\t        style = styleInfo.customStyle;\n\t\t        // otherwise, if we have css to apply, do so\n\t\t      } else if (cssText) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t\t      }\n\t\t    } else {\n\t\t      // shady and no cache hit\n\t\t      if (!style) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        if (cssText) {\n\t\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t\t        }\n\t\t        // shady and cache hit but not in document\n\t\t      } else if (!style.parentNode) {\n\t\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t\t      }\n\t\t    }\n\t\t    // ensure this style is our custom style and increment its use count.\n\t\t    if (style) {\n\t\t      style._useCount = style._useCount || 0;\n\t\t      // increment use count if we changed styles\n\t\t      if (styleInfo.customStyle != style) {\n\t\t        style._useCount++;\n\t\t      }\n\t\t      styleInfo.customStyle = style;\n\t\t    }\n\t\t    // @media rules may be stale in IE 10 and 11\n\t\t    if (IS_IE) {\n\t\t      style.textContent = style.textContent;\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t\n\t\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t\t    var rules = rulesForStyle(style);\n\t\t    var self = this;\n\t\t    style.textContent = toCssText(rules, function (rule) {\n\t\t      var css = rule.cssText = rule.parsedCssText;\n\t\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t\t        // remove property assignments\n\t\t        // so next function isn't confused\n\t\t        // NOTE: we have 3 categories of css:\n\t\t        // (1) normal properties,\n\t\t        // (2) custom property assignments (--foo: red;),\n\t\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t\t        // are not and this makes this case unique.\n\t\t        css = removeCustomPropAssignment(css);\n\t\t        // replace with reified properties, scenario is same as mixin\n\t\t        rule.cssText = self.valueForProperties(css, properties);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  rx: rx,\n\t\t  XSCOPE_NAME: 'x-scope'\n\t\t};\n\t\t\n\t\tfunction addToBitMask(n, bits) {\n\t\t  var o = parseInt(n / 32);\n\t\t  var v = 1 << n % 32;\n\t\t  bits[o] = (bits[o] || 0) | v;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar templateMap = {};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar placeholderMap = {};\n\t\t\n\t\tvar ce = window.customElements;\n\t\tif (ce && !nativeShadow) {\n\t\t  (function () {\n\t\t    var origDefine = ce.define;\n\t\t    ce.define = function (name, clazz, options) {\n\t\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t\t      return origDefine.call(ce, name, clazz, options);\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\tvar StyleCache = function () {\n\t\t  function StyleCache() {\n\t\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t\t    classCallCheck(this, StyleCache);\n\t\t\n\t\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t\t    this.cache = {};\n\t\t    this.typeMax = typeMax;\n\t\t  }\n\t\t\n\t\t  createClass(StyleCache, [{\n\t\t    key: '_validate',\n\t\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t\t        var pn = ownPropertyNames[idx];\n\t\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t      return true;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'store',\n\t\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t\t      var list = this.cache[tagname] || [];\n\t\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t\t      if (list.length > this.typeMax) {\n\t\t        list.shift();\n\t\t      }\n\t\t      this.cache[tagname] = list;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'fetch',\n\t\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t\t      var list = this.cache[tagname];\n\t\t      if (!list) {\n\t\t        return;\n\t\t      }\n\t\t      // reverse list for most-recent lookups\n\t\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t\t        var entry = list[idx];\n\t\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t\t          return entry;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }]);\n\t\t  return StyleCache;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/**\n\t\t * The apply shim simulates the behavior of `@apply` proposed at\n\t\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t\t * The approach is to convert a property like this:\n\t\t *\n\t\t *    --foo: {color: red; background: blue;}\n\t\t *\n\t\t * to this:\n\t\t *\n\t\t *    --foo_-_color: red;\n\t\t *    --foo_-_background: blue;\n\t\t *\n\t\t * Then where `@apply --foo` is used, that is converted to:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background);\n\t\t *\n\t\t * This approach generally works but there are some issues and limitations.\n\t\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t\t * another element sets it to:\n\t\t *\n\t\t *    --foo: { border: 2px solid red; }\n\t\t *\n\t\t * We must now ensure that the color and background from the previous setting\n\t\t * do not apply. This is accomplished by changing the property set to this:\n\t\t *\n\t\t *    --foo_-_border: 2px solid red;\n\t\t *    --foo_-_color: initial;\n\t\t *    --foo_-_background: initial;\n\t\t *\n\t\t * This works but introduces one new issue.\n\t\t * Consider this setup at the point where the `@apply` is used:\n\t\t *\n\t\t *    background: orange;\n\t\t *    @apply --foo;\n\t\t *\n\t\t * In this case the background will be unset (initial) rather than the desired\n\t\t * `orange`. We address this by altering the property set to use a fallback\n\t\t * value like this:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background, orange);\n\t\t *    border: var(--foo_-_border);\n\t\t *\n\t\t * Note that the default is retained in the property set and the `background` is\n\t\t * the desired `orange`. This leads us to a limitation.\n\t\t *\n\t\t * Limitation 1:\n\t\t\n\t\t * Only properties in the rule where the `@apply`\n\t\t * is used are considered as default values.\n\t\t * If another rule matches the element and sets `background` with\n\t\t * less specificity than the rule in which `@apply` appears,\n\t\t * the `background` will not be set.\n\t\t *\n\t\t * Limitation 2:\n\t\t *\n\t\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t\t * `@apply` properties.\n\t\t\n\t\t*/\n\t\t\n\t\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\t\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\t\n\t\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\t\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\t\n\t\t// separator used between mixin-name and mixin-property-name when producing properties\n\t\t// NOTE: plain '-' may cause collisions in user styles\n\t\tvar MIXIN_VAR_SEP = '_-_';\n\t\t\n\t\t// map of mixin to property names\n\t\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\t\n\t\tvar MixinMap = function () {\n\t\t  function MixinMap() {\n\t\t    classCallCheck(this, MixinMap);\n\t\t\n\t\t    this._map = {};\n\t\t  }\n\t\t\n\t\t  createClass(MixinMap, [{\n\t\t    key: 'set',\n\t\t    value: function set(name, props) {\n\t\t      name = name.trim();\n\t\t      this._map[name] = {\n\t\t        properties: props,\n\t\t        dependants: {}\n\t\t      };\n\t\t    }\n\t\t  }, {\n\t\t    key: 'get',\n\t\t    value: function get(name) {\n\t\t      name = name.trim();\n\t\t      return this._map[name];\n\t\t    }\n\t\t  }]);\n\t\t  return MixinMap;\n\t\t}();\n\t\t\n\t\tvar ApplyShim = function () {\n\t\t  function ApplyShim() {\n\t\t    var _this = this;\n\t\t\n\t\t    classCallCheck(this, ApplyShim);\n\t\t\n\t\t    this._currentTemplate = null;\n\t\t    this._measureElement = null;\n\t\t    this._map = new MixinMap();\n\t\t    this._separator = MIXIN_VAR_SEP;\n\t\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t\t    };\n\t\t  }\n\t\t\n\t\t  createClass(ApplyShim, [{\n\t\t    key: 'transformStyle',\n\t\t    value: function transformStyle(style, elementName) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      this.transformRules(ast, elementName);\n\t\t      return ast;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRules',\n\t\t    value: function transformRules(rules, elementName) {\n\t\t      var _this2 = this;\n\t\t\n\t\t      this._currentTemplate = templateMap[elementName];\n\t\t      forEachRule(rules, function (r) {\n\t\t        _this2.transformRule(r);\n\t\t      });\n\t\t      if (this._currentTemplate) {\n\t\t        this._currentTemplate.__applyShimInvalid = false;\n\t\t      }\n\t\t      this._currentTemplate = null;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRule',\n\t\t    value: function transformRule(rule) {\n\t\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t\t      // :root was only used for variable assignment in property shim,\n\t\t      // but generates invalid selectors with real properties.\n\t\t      // replace with `:host > *`, which serves the same effect\n\t\t      if (rule.selector === ':root') {\n\t\t        rule.selector = ':host > *';\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformCssText',\n\t\t    value: function transformCssText(cssText) {\n\t\t      // produce variables\n\t\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t\t      // consume mixins\n\t\t      return this._consumeCssProperties(cssText);\n\t\t    }\n\t\t  }, {\n\t\t    key: '_getInitialValueForProperty',\n\t\t    value: function _getInitialValueForProperty(property) {\n\t\t      if (!this._measureElement) {\n\t\t        this._measureElement = document.createElement('meta');\n\t\t        this._measureElement.style.all = 'initial';\n\t\t        document.head.appendChild(this._measureElement);\n\t\t      }\n\t\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t\t    }\n\t\t    // replace mixin consumption with variable consumption\n\t\t\n\t\t  }, {\n\t\t    key: '_consumeCssProperties',\n\t\t    value: function _consumeCssProperties(text) {\n\t\t      var m = void 0;\n\t\t      // loop over text until all mixins with defintions have been applied\n\t\t      while (m = MIXIN_MATCH.exec(text)) {\n\t\t        var matchText = m[0];\n\t\t        var mixinName = m[1];\n\t\t        var idx = m.index;\n\t\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t\t        var applyPos = idx + matchText.indexOf('@apply');\n\t\t        var afterApplyPos = idx + matchText.length;\n\t\t        // find props defined before this @apply\n\t\t        var textBeforeApply = text.slice(0, applyPos);\n\t\t        var textAfterApply = text.slice(afterApplyPos);\n\t\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t\t        // use regex match position to replace mixin, keep linear processing time\n\t\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t\t        // move regex search to _after_ replacement\n\t\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t\t      }\n\t\t      return text;\n\t\t    }\n\t\t    // produce variable consumption at the site of mixin consumption\n\t\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t\t    // Example:\n\t\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\t\n\t\t  }, {\n\t\t    key: '_atApplyToCssProperties',\n\t\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t\t      var vars = [];\n\t\t      var mixinEntry = this._map.get(mixinName);\n\t\t      // if we depend on a mixin before it is created\n\t\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t\t      if (!mixinEntry) {\n\t\t        this._map.set(mixinName, {});\n\t\t        mixinEntry = this._map.get(mixinName);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        if (this._currentTemplate) {\n\t\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t\t        }\n\t\t        var p = void 0,\n\t\t            parts = void 0,\n\t\t            f = void 0;\n\t\t        for (p in mixinEntry.properties) {\n\t\t          f = fallbacks && fallbacks[p];\n\t\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t\t          if (f) {\n\t\t            parts.push(',', f);\n\t\t          }\n\t\t          parts.push(')');\n\t\t          vars.push(parts.join(''));\n\t\t        }\n\t\t      }\n\t\t      return vars.join('; ');\n\t\t    }\n\t\t  }, {\n\t\t    key: '_replaceInitialOrInherit',\n\t\t    value: function _replaceInitialOrInherit(property, value) {\n\t\t      var match = INITIAL_INHERIT.exec(value);\n\t\t      if (match) {\n\t\t        if (match[1]) {\n\t\t          // initial\n\t\t          // replace `initial` with the concrete initial value for this property\n\t\t          value = ApplyShim._getInitialValueForProperty(property);\n\t\t        } else {\n\t\t          // inherit\n\t\t          // with this purposfully illegal value, the variable will be invalid at\n\t\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t\t          // and for inheriting values, will behave similarly\n\t\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t\t          value = 'apply-shim-inherit';\n\t\t        }\n\t\t      }\n\t\t      return value;\n\t\t    }\n\t\t\n\t\t    // \"parse\" a mixin definition into a map of properties and values\n\t\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\t\n\t\t  }, {\n\t\t    key: '_cssTextToMap',\n\t\t    value: function _cssTextToMap(text) {\n\t\t      var props = text.split(';');\n\t\t      var property = void 0,\n\t\t          value = void 0;\n\t\t      var out = {};\n\t\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t\t        p = props[i];\n\t\t        if (p) {\n\t\t          sp = p.split(':');\n\t\t          // ignore lines that aren't definitions like @media\n\t\t          if (sp.length > 1) {\n\t\t            property = sp[0].trim();\n\t\t            // some properties may have ':' in the value, like data urls\n\t\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t\t            out[property] = value;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return out;\n\t\t    }\n\t\t  }, {\n\t\t    key: '_invalidateMixinEntry',\n\t\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t\t      for (var elementName in mixinEntry.dependants) {\n\t\t        if (elementName !== this._currentTemplate) {\n\t\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: '_produceCssProperties',\n\t\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t\t      var _this3 = this;\n\t\t\n\t\t      // handle case where property value is a mixin\n\t\t      if (valueProperty) {\n\t\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t\t          if (value && _this3._map.get(value)) {\n\t\t            valueMixin = '@apply ' + value + ';';\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      if (!valueMixin) {\n\t\t        return matchText;\n\t\t      }\n\t\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t\t      var combinedProps = mixinValues;\n\t\t      var mixinEntry = this._map.get(propertyName);\n\t\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t\t      if (oldProps) {\n\t\t        // NOTE: since we use mixin, the map of properties is updated here\n\t\t        // and this is what we want.\n\t\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t\t      } else {\n\t\t        this._map.set(propertyName, combinedProps);\n\t\t      }\n\t\t      var out = [];\n\t\t      var p = void 0,\n\t\t          v = void 0;\n\t\t      // set variables defined by current mixin\n\t\t      var needToInvalidate = false;\n\t\t      for (p in combinedProps) {\n\t\t        v = mixinValues[p];\n\t\t        // if property not defined by current mixin, set initial\n\t\t        if (v === undefined) {\n\t\t          v = 'initial';\n\t\t        }\n\t\t        if (oldProps && !(p in oldProps)) {\n\t\t          needToInvalidate = true;\n\t\t        }\n\t\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t\t      }\n\t\t      if (needToInvalidate) {\n\t\t        this._invalidateMixinEntry(mixinEntry);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        mixinEntry.properties = combinedProps;\n\t\t      }\n\t\t      // because the mixinMap is global, the mixin might conflict with\n\t\t      // a different scope's simple variable definition:\n\t\t      // Example:\n\t\t      // some style somewhere:\n\t\t      // --mixin1:{ ... }\n\t\t      // --mixin2: var(--mixin1);\n\t\t      // some other element:\n\t\t      // --mixin1: 10px solid red;\n\t\t      // --foo: var(--mixin1);\n\t\t      // In this case, we leave the original variable definition in place.\n\t\t      if (valueProperty) {\n\t\t        prefix = matchText + ';' + prefix;\n\t\t      }\n\t\t      return prefix + out.join('; ') + ';';\n\t\t    }\n\t\t  }]);\n\t\t  return ApplyShim;\n\t\t}();\n\t\t\n\t\tvar applyShim = new ApplyShim();\n\t\twindow['ApplyShim'] = applyShim;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar flush = function flush() {};\n\t\t\n\t\tif (!nativeShadow) {\n\t\t  (function () {\n\t\t    var handler = function handler(mxns) {\n\t\t      for (var x = 0; x < mxns.length; x++) {\n\t\t        var mxn = mxns[x];\n\t\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t\t          var n = mxn.addedNodes[i];\n\t\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t\t            var root = n.getRootNode();\n\t\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t              // may no longer be in a shadowroot\n\t\t              var host = root.host;\n\t\t              if (host) {\n\t\t                var scope = host.is || host.localName;\n\t\t                StyleTransformer.dom(n, scope);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t\t          var _n = mxn.removedNodes[_i];\n\t\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t\t            if (classIdx >= 0) {\n\t\t              // NOTE: relies on the scoping class always being adjacent to the\n\t\t              // SCOPE_NAME class.\n\t\t              var _scope = _n.classList[classIdx + 1];\n\t\t              if (_scope) {\n\t\t                StyleTransformer.dom(_n, _scope, true);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    };\n\t\t\n\t\t    var observer = new MutationObserver(handler);\n\t\t    var startState = 'interactive';\n\t\t\n\t\t    var start = function start() {\n\t\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t\t    };\n\t\t    if (window.HTMLImports) {\n\t\t      window.HTMLImports.whenReady(start);\n\t\t    } else if (document.readyState === startState) {\n\t\t      requestAnimationFrame(start);\n\t\t    } else {\n\t\t      document.addEventListener('readystatechange', function () {\n\t\t        if (document.readyState === startState) {\n\t\t          start();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t\n\t\t    flush = function flush() {\n\t\t      handler(observer.takeRecords());\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(dfreedm): consider spliting into separate global\n\t\tvar styleCache = new StyleCache();\n\t\t\n\t\tvar ShadyCSS = {\n\t\t  flush: flush,\n\t\t  scopeCounter: {},\n\t\t  nativeShadow: nativeShadow,\n\t\t  nativeCss: nativeCssVariables,\n\t\t  nativeCssApply: nativeCssApply,\n\t\t  _documentOwner: document.documentElement,\n\t\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t\t    return name + '-' + id;\n\t\t  },\n\t\t  getStyleAst: function getStyleAst(style) {\n\t\t    return rulesForStyle(style);\n\t\t  },\n\t\t  styleAstToString: function styleAstToString(ast) {\n\t\t    return toCssText(ast);\n\t\t  },\n\t\t  _gatherStyles: function _gatherStyles(template) {\n\t\t    var styles = template.content.querySelectorAll('style');\n\t\t    var cssText = [];\n\t\t    for (var i = 0; i < styles.length; i++) {\n\t\t      var s = styles[i];\n\t\t      cssText.push(s.textContent);\n\t\t      s.parentNode.removeChild(s);\n\t\t    }\n\t\t    return cssText.join('').trim();\n\t\t  },\n\t\t  _getCssBuild: function _getCssBuild(template) {\n\t\t    var style = template.content.querySelector('style');\n\t\t    if (!style) {\n\t\t      return '';\n\t\t    }\n\t\t    return style.getAttribute('css-build') || '';\n\t\t  },\n\t\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t\t    if (template._prepared) {\n\t\t      return;\n\t\t    }\n\t\t    template._prepared = true;\n\t\t    template.name = elementName;\n\t\t    template.extends = typeExtension;\n\t\t    templateMap[elementName] = template;\n\t\t    var cssBuild = this._getCssBuild(template);\n\t\t    var cssText = this._gatherStyles(template);\n\t\t    var info = {\n\t\t      is: elementName,\n\t\t      extends: typeExtension,\n\t\t      __cssBuild: cssBuild\n\t\t    };\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleTransformer.dom(template.content, elementName);\n\t\t    }\n\t\t    var ast = parse(cssText);\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      applyShim.transformRules(ast, elementName);\n\t\t    }\n\t\t    template._styleAst = ast;\n\t\t\n\t\t    var ownPropertyNames = [];\n\t\t    if (!this.nativeCss) {\n\t\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t\t    }\n\t\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t\t      var root = this.nativeShadow ? template.content : null;\n\t\t      var placeholder = placeholderMap[elementName];\n\t\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t\t      template._style = style;\n\t\t    }\n\t\t    template._ownPropertyNames = ownPropertyNames;\n\t\t  },\n\t\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t\t    if (cssText.length) {\n\t\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t\t    }\n\t\t  },\n\t\t  _prepareHost: function _prepareHost(host) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var typeExtension = void 0;\n\t\t    if (is !== host.localName) {\n\t\t      typeExtension = host.localName;\n\t\t    }\n\t\t    var placeholder = placeholderMap[is];\n\t\t    var template = templateMap[is];\n\t\t    var ast = void 0;\n\t\t    var ownStylePropertyNames = void 0;\n\t\t    var cssBuild = void 0;\n\t\t    if (template) {\n\t\t      ast = template._styleAst;\n\t\t      ownStylePropertyNames = template._ownPropertyNames;\n\t\t      cssBuild = template._cssBuild;\n\t\t    }\n\t\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t\t  },\n\t\t  applyStyle: function applyStyle(host, overrideProps) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    if (window.CustomStyle) {\n\t\t      var CS = window.CustomStyle;\n\t\t      if (CS._documentDirty) {\n\t\t        CS.findStyles();\n\t\t        if (!this.nativeCss) {\n\t\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t\t        } else if (!this.nativeCssApply) {\n\t\t          CS._revalidateApplyShim();\n\t\t        }\n\t\t        CS.applyStyles();\n\t\t        CS._documentDirty = false;\n\t\t      }\n\t\t    }\n\t\t    var styleInfo = StyleInfo.get(host);\n\t\t    if (!styleInfo) {\n\t\t      styleInfo = this._prepareHost(host);\n\t\t    }\n\t\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t\t    if (this.nativeCss) {\n\t\t      var template = templateMap[is];\n\t\t      if (template && template.__applyShimInvalid && template._style) {\n\t\t        // update template\n\t\t        applyShim.transformRules(template._styleAst, is);\n\t\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        // update instance if native shadowdom\n\t\t        if (this.nativeShadow) {\n\t\t          var style = host.shadowRoot.querySelector('style');\n\t\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        }\n\t\t        styleInfo.styleRules = template._styleAst;\n\t\t      }\n\t\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t\t    } else {\n\t\t      this._updateProperties(host, styleInfo);\n\t\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t\t        // TODO: use caching\n\t\t        this._applyStyleProperties(host, styleInfo);\n\t\t      }\n\t\t    }\n\t\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t\t    // note: some elements may not have a root!\n\t\t    if (root) {\n\t\t      this._applyToDescendants(root);\n\t\t    }\n\t\t  },\n\t\t  _applyToDescendants: function _applyToDescendants(root) {\n\t\t    var c$ = root.children;\n\t\t    for (var i = 0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (c.shadowRoot) {\n\t\t        this.applyStyle(c);\n\t\t      }\n\t\t      this._applyToDescendants(c);\n\t\t    }\n\t\t  },\n\t\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t\t    var root = node.getRootNode();\n\t\t    var host = root.host;\n\t\t    if (host) {\n\t\t      if (StyleInfo.get(host)) {\n\t\t        return host;\n\t\t      } else {\n\t\t        return this._styleOwnerForNode(host);\n\t\t      }\n\t\t    }\n\t\t    return this._documentOwner;\n\t\t  },\n\t\t  _isRootOwner: function _isRootOwner(node) {\n\t\t    return node === this._documentOwner;\n\t\t  },\n\t\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t\t    // only generate new scope if cached style is not found\n\t\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t\t    }\n\t\t    if (!cacheEntry) {\n\t\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t\t    var owner = this._styleOwnerForNode(host);\n\t\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t\t    var props = Object.create(ownerProperties || null);\n\t\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t\t    var propertiesMatchingHost = propertyData.properties;\n\t\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t\t    StyleProperties.reify(props);\n\t\t    styleInfo.styleProperties = props;\n\t\t  },\n\t\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t\t    for (var p in overrides) {\n\t\t      var v = overrides[p];\n\t\t      // skip override props if they are not truthy or 0\n\t\t      // in order to fall back to inherited values\n\t\t      if (v || v === 0) {\n\t\t        props[p] = v;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t\t    // remove previous properties\n\t\t    for (var p in properties) {\n\t\t      // NOTE: for bc with shim, don't apply null values.\n\t\t      if (p === null) {\n\t\t        element.style.removeProperty(p);\n\t\t      } else {\n\t\t        element.style.setProperty(p, properties[p]);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  updateStyles: function updateStyles(properties) {\n\t\t    if (window.CustomStyle) {\n\t\t      window.CustomStyle._documentDirty = true;\n\t\t    }\n\t\t    this.applyStyle(this._documentOwner, properties);\n\t\t  },\n\t\t\n\t\t  /* Custom Style operations */\n\t\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t\t    var _this = this;\n\t\t\n\t\t    var ast = rulesForStyle(style);\n\t\t    forEachRule(ast, function (rule) {\n\t\t      if (nativeShadow) {\n\t\t        StyleTransformer.normalizeRootSelector(rule);\n\t\t      } else {\n\t\t        StyleTransformer.documentRule(rule);\n\t\t      }\n\t\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t\t        applyShim.transformRule(rule);\n\t\t      }\n\t\t    });\n\t\t    if (this.nativeCss) {\n\t\t      style.textContent = toCssText(ast);\n\t\t    } else {\n\t\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t\t    }\n\t\t  },\n\t\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      applyShim.transformRules(ast);\n\t\t      style.textContent = toCssText(ast);\n\t\t    }\n\t\t  },\n\t\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t\t    if (!this.nativeCss) {\n\t\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t\t    }\n\t\t  },\n\t\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t\t    var value = void 0;\n\t\t    if (!this.nativeCss) {\n\t\t      // element is either a style host, or an ancestor of a style host\n\t\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t\t      value = styleInfo.styleProperties[property];\n\t\t    }\n\t\t    // fall back to the property value from the computed styling\n\t\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t\t    // trim whitespace that can come after the `:` in css\n\t\t    // example: padding: 2px -> \" 2px\"\n\t\t    return value.trim();\n\t\t  },\n\t\t\n\t\t  // given an element and a classString, replaces\n\t\t  // the element's class with the provided classString and adds\n\t\t  // any necessary ShadyCSS static and property based scoping selectors\n\t\t  // NOTE: this method is suitable to be called in an environment in which\n\t\t  // setAttribute('class', ...) and className setter have been overridden so\n\t\t  // it cannot rely on those methods.\n\t\t  setElementClass: function setElementClass(element, classString) {\n\t\t    var _element$classList;\n\t\t\n\t\t    // use classList to clear existing classes\n\t\t    while (element.classList.length) {\n\t\t      element.classList.remove(element.classList[0]);\n\t\t    }\n\t\t    // add user classString\n\t\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t\t    // add static scoping: scope by shadyRoot\n\t\t    var root = element.getRootNode();\n\t\t    if (root.host) {\n\t\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t\t    }\n\t\t    // add property scoping: scope by special selector\n\t\t    if (!this.nativeCss) {\n\t\t      var styleInfo = StyleInfo.get(element);\n\t\t      if (styleInfo && styleInfo.scopeSelector) {\n\t\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t\t    return StyleInfo.get(node);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow['ShadyCSS'] = ShadyCSS;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\t\n\t\tExample:\n\t\t<shady-style>\n\t\t  <style>\n\t\t  ...\n\t\t  </style>\n\t\t</shady-style>\n\t\t*/\n\t\t\n\t\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\t\n\t\tvar enqueued = false;\n\t\t\n\t\tvar customStyles = [];\n\t\t\n\t\tvar hookFn = null;\n\t\t\n\t\t/*\n\t\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\t\tas all the instances will boot asynchronously after page load.\n\t\t\n\t\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t\t*/\n\t\tfunction enqueueDocumentValidation() {\n\t\t  if (enqueued) {\n\t\t    return;\n\t\t  }\n\t\t  enqueued = true;\n\t\t  if (window.HTMLImports) {\n\t\t    window.HTMLImports.whenReady(validateDocument);\n\t\t  } else if (document.readyState === 'complete') {\n\t\t    requestAnimationFrame(validateDocument);\n\t\t  } else {\n\t\t    document.addEventListener('readystatechange', function () {\n\t\t      if (document.readyState === 'complete') {\n\t\t        validateDocument();\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t}\n\t\t\n\t\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t\t// helps ensure that the first run of validateDocument will actually\n\t\t// have access to all the custom-style's created via loading imports.\n\t\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t\t// then the enqueue immediately calls validateDocument and work that could be\n\t\t// batched is not.\n\t\tenqueueDocumentValidation();\n\t\t\n\t\tfunction validateDocument() {\n\t\t  if (enqueued) {\n\t\t    ShadyCSS$1.updateStyles();\n\t\t    enqueued = false;\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction CustomStyle() {\n\t\t  /*\n\t\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t\t  CustomElement polyfill replacement that can be `.call`ed\n\t\t  */\n\t\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t\t  customStyles.push(self);\n\t\t  enqueueDocumentValidation();\n\t\t  return self;\n\t\t}\n\t\t\n\t\tObject.defineProperties(CustomStyle, {\n\t\t  /*\n\t\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t\t   The function must take a <style> element as input, and return nothing.\n\t\t  */\n\t\t  processHook: {\n\t\t    get: function get() {\n\t\t      return hookFn;\n\t\t    },\n\t\t    set: function set(fn) {\n\t\t      hookFn = fn;\n\t\t      return fn;\n\t\t    }\n\t\t  },\n\t\t  _customStyles: {\n\t\t    get: function get() {\n\t\t      return customStyles;\n\t\t    }\n\t\t  },\n\t\t  _documentDirty: {\n\t\t    get: function get() {\n\t\t      return enqueued;\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      enqueued = value;\n\t\t      return value;\n\t\t    }\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.findStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._findStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle._revalidateApplyShim = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    var s = customStyles[i];\n\t\t    if (s._style) {\n\t\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.applyStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._applyStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t\t  'constructor': {\n\t\t    value: CustomStyle,\n\t\t    configurable: true,\n\t\t    writable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.prototype._findStyle = function () {\n\t\t  if (!this._style) {\n\t\t    var style = this.querySelector('style');\n\t\t    if (!style) {\n\t\t      return;\n\t\t    }\n\t\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t\t    // which is referenced with __appliedElement.\n\t\t    // Also, we must copy over the attributes.\n\t\t    if (style.__appliedElement) {\n\t\t      for (var i = 0; i < style.attributes.length; i++) {\n\t\t        var attr = style.attributes[i];\n\t\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t\t      }\n\t\t    }\n\t\t    this._style = style.__appliedElement || style;\n\t\t    if (hookFn) {\n\t\t      hookFn(this._style);\n\t\t    }\n\t\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype._applyStyle = function () {\n\t\t  if (this._style) {\n\t\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow.customElements.define('custom-style', CustomStyle);\n\t\twindow['CustomStyle'] = CustomStyle;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/*\n\t\tSmall module to load ShadyCSS and CustomStyle together\n\t\t*/\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadycss.min.js.map\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n\t  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n\t}(this, (function (exports,incrementalDom,root) {\n\t\n\troot = 'default' in root ? root['default'] : root;\n\t\n\tfunction keys() {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  var _ref$enumOnly = _ref.enumOnly;\n\t  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\t\n\t  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n\t  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n\t}\n\t\n\t// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n\t// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\n\tvar assign = (function (obj) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  args.forEach(function (arg) {\n\t    return keys(arg).forEach(function (name) {\n\t      return obj[name] = arg[name];\n\t    });\n\t  }); // eslint-disable-line no-return-assign\n\t  return obj;\n\t});\n\t\n\tvar empty = function (val) {\n\t  return typeof val === 'undefined' || val === null;\n\t};\n\t\n\t/**\n\t * Attributes value can only be null or string;\n\t */\n\tvar toNullOrString = function toNullOrString(val) {\n\t  return empty(val) ? null : String(val);\n\t};\n\t\n\tfunction create(def) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args.unshift({}, def);\n\t    return assign.apply(undefined, args);\n\t  };\n\t}\n\t\n\tvar array = create({\n\t  coerce: function coerce(val) {\n\t    return Array.isArray(val) ? val : empty(val) ? null : [val];\n\t  },\n\t  default: function _default() {\n\t    return [];\n\t  },\n\t  deserialize: function deserialize(val) {\n\t    return empty(val) ? null : JSON.parse(val);\n\t  },\n\t  serialize: JSON.stringify\n\t});\n\t\n\tvar boolean = create({\n\t  coerce: function coerce(val) {\n\t    return !!val;\n\t  },\n\t  default: false,\n\t  // todo: 'false' string must deserialize to false for angular 1.x to work\n\t  // This breaks one existing test.\n\t  // deserialize: val => !(val === null || val === 'false'),\n\t  deserialize: function deserialize(val) {\n\t    return !(val === null);\n\t  },\n\t  serialize: function serialize(val) {\n\t    return val ? '' : null;\n\t  }\n\t});\n\t\n\t// defaults empty to 0 and allows NaN\n\tvar zeroIfEmptyOrNumberIncludesNaN = function zeroIfEmptyOrNumberIncludesNaN(val) {\n\t  return empty(val) ? 0 : Number(val);\n\t};\n\t\n\tvar number = create({\n\t  default: 0,\n\t  coerce: zeroIfEmptyOrNumberIncludesNaN,\n\t  deserialize: zeroIfEmptyOrNumberIncludesNaN,\n\t  serialize: toNullOrString\n\t});\n\t\n\tvar string = create({\n\t  default: '',\n\t  coerce: toNullOrString,\n\t  deserialize: toNullOrString,\n\t  serialize: toNullOrString\n\t});\n\t\n\tvar prop = Object.freeze({\n\t\tcreate: create,\n\t\tarray: array,\n\t\tboolean: boolean,\n\t\tnumber: number,\n\t\tstring: string\n\t});\n\t\n\tvar connected = '____skate_connected';\n\tvar created = '____skate_created';\n\t\n\t// DEPRECATED\n\t//\n\t// This is the only \"symbol\" that must stay a string. This is because it is\n\t// relied upon across several versions. We should remove it, but ensure that\n\t// it's considered a breaking change that whatever version removes it cannot\n\t// be passed to vdom functions as tag names.\n\tvar name = '____skate_name';\n\t\n\t// Used on the Constructor\n\tvar ctorCreateInitProps = '____skate_ctor_createInitProps';\n\tvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\n\tvar ctorProps = '____skate_ctor_props';\n\tvar ctorPropsMap = '____skate_ctor_propsMap';\n\t\n\t// Used on the Element\n\tvar props = '____skate_props';\n\tvar ref$1 = '____skate_ref';\n\tvar renderer$1 = '____skate_renderer';\n\tvar rendering = '____skate_rendering';\n\tvar rendererDebounced = '____skate_rendererDebounced';\n\tvar updated$1 = '____skate_updated';\n\t\n\t// DEPRECTAED\n\t//\n\t// We should not be relying on internals for symbols as this creates version\n\t// coupling. We will move forward with platform agnostic ways of doing this.\n\t\n\t\n\tvar symbols$1 = Object.freeze({\n\t\tname: name\n\t});\n\t\n\tfunction enter(object, props) {\n\t  var saved = {};\n\t  Object.keys(props).forEach(function (key) {\n\t    saved[key] = object[key];\n\t    object[key] = props[key];\n\t  });\n\t  return saved;\n\t}\n\t\n\tfunction exit(object, saved) {\n\t  assign(object, saved);\n\t}\n\t\n\t// Decorates a function with a side effect that changes the properties of an\n\t// object during its execution, and restores them after. There is no error\n\t// handling here, if the wrapped function throws an error, properties are not\n\t// restored and all bets are off.\n\tvar propContext = function (object, props) {\n\t  return function (func) {\n\t    return function () {\n\t      var saved = enter(object, props);\n\t      var result = func.apply(undefined, arguments);\n\t      exit(object, saved);\n\t      return result;\n\t    };\n\t  };\n\t};\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\t\n\t\n\t\n\t\n\tvar asyncGenerator = function () {\n\t  function AwaitValue(value) {\n\t    this.value = value;\n\t  }\n\t\n\t  function AsyncGenerator(gen) {\n\t    var front, back;\n\t\n\t    function send(key, arg) {\n\t      return new Promise(function (resolve, reject) {\n\t        var request = {\n\t          key: key,\n\t          arg: arg,\n\t          resolve: resolve,\n\t          reject: reject,\n\t          next: null\n\t        };\n\t\n\t        if (back) {\n\t          back = back.next = request;\n\t        } else {\n\t          front = back = request;\n\t          resume(key, arg);\n\t        }\n\t      });\n\t    }\n\t\n\t    function resume(key, arg) {\n\t      try {\n\t        var result = gen[key](arg);\n\t        var value = result.value;\n\t\n\t        if (value instanceof AwaitValue) {\n\t          Promise.resolve(value.value).then(function (arg) {\n\t            resume(\"next\", arg);\n\t          }, function (arg) {\n\t            resume(\"throw\", arg);\n\t          });\n\t        } else {\n\t          settle(result.done ? \"return\" : \"normal\", result.value);\n\t        }\n\t      } catch (err) {\n\t        settle(\"throw\", err);\n\t      }\n\t    }\n\t\n\t    function settle(type, value) {\n\t      switch (type) {\n\t        case \"return\":\n\t          front.resolve({\n\t            value: value,\n\t            done: true\n\t          });\n\t          break;\n\t\n\t        case \"throw\":\n\t          front.reject(value);\n\t          break;\n\t\n\t        default:\n\t          front.resolve({\n\t            value: value,\n\t            done: false\n\t          });\n\t          break;\n\t      }\n\t\n\t      front = front.next;\n\t\n\t      if (front) {\n\t        resume(front.key, front.arg);\n\t      } else {\n\t        back = null;\n\t      }\n\t    }\n\t\n\t    this._invoke = send;\n\t\n\t    if (typeof gen.return !== \"function\") {\n\t      this.return = undefined;\n\t    }\n\t  }\n\t\n\t  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n\t    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n\t      return this;\n\t    };\n\t  }\n\t\n\t  AsyncGenerator.prototype.next = function (arg) {\n\t    return this._invoke(\"next\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.throw = function (arg) {\n\t    return this._invoke(\"throw\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.return = function (arg) {\n\t    return this._invoke(\"return\", arg);\n\t  };\n\t\n\t  return {\n\t    wrap: function (fn) {\n\t      return function () {\n\t        return new AsyncGenerator(fn.apply(this, arguments));\n\t      };\n\t    },\n\t    await: function (value) {\n\t      return new AwaitValue(value);\n\t    }\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar defineProperty = function (obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\t\n\t  return obj;\n\t};\n\t\n\tvar get$1 = function get$1(object, property, receiver) {\n\t  if (object === null) object = Function.prototype;\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent === null) {\n\t      return undefined;\n\t    } else {\n\t      return get$1(parent, property, receiver);\n\t    }\n\t  } else if (\"value\" in desc) {\n\t    return desc.value;\n\t  } else {\n\t    var getter = desc.get;\n\t\n\t    if (getter === undefined) {\n\t      return undefined;\n\t    }\n\t\n\t    return getter.call(receiver);\n\t  }\n\t};\n\t\n\tvar inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\t\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/* eslint no-plusplus: 0 */\n\t\n\tvar customElements = root.customElements;\n\tvar HTMLElement = root.HTMLElement;\n\t\n\tvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\t\n\t// A stack of children that corresponds to the current function helper being\n\t// executed.\n\tvar stackChren = [];\n\t\n\tvar $skip = '__skip';\n\tvar $currentEventHandlers = '__events';\n\tvar $stackCurrentHelperProps = '__props';\n\t\n\t// The current function helper in the stack.\n\tvar stackCurrentHelper = void 0;\n\t\n\t// This is used for the Incremental DOM overrides to keep track of what args\n\t// to pass the main elementOpen() function.\n\tvar overrideArgs = void 0;\n\t\n\t// The number of levels deep after skipping a tree.\n\tvar skips = 0;\n\t\n\tvar noop = function noop() {};\n\t\n\t// Adds or removes an event listener for an element.\n\tfunction applyEvent(elem, ename, newFunc) {\n\t  var events = elem[$currentEventHandlers];\n\t\n\t  if (!events) {\n\t    events = elem[$currentEventHandlers] = {};\n\t  }\n\t\n\t  // Undefined indicates that there is no listener yet.\n\t  if (typeof events[ename] === 'undefined') {\n\t    // We only add a single listener once. Originally this was a workaround for\n\t    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n\t    // also a simpler model for binding / unbinding events because you only\n\t    // have a single handler you need to worry about and a single place where\n\t    // you only store one event handler\n\t    elem.addEventListener(ename, function (e) {\n\t      if (events[ename]) {\n\t        events[ename].call(this, e);\n\t      }\n\t    });\n\t  }\n\t\n\t  // Not undefined indicates that we have set a listener, so default to null.\n\t  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n\t}\n\t\n\tvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n\t  // Attributes that shouldn't be applied to the DOM.\n\t  key: noop,\n\t  statics: noop,\n\t\n\t  // Attributes that *must* be set via a property on all elements.\n\t  checked: incrementalDom.applyProp,\n\t  className: incrementalDom.applyProp,\n\t  disabled: incrementalDom.applyProp,\n\t  value: incrementalDom.applyProp,\n\t\n\t  // Ref handler.\n\t  ref: function ref(elem, name$$1, value) {\n\t    elem[ref$1] = value;\n\t  },\n\t\n\t\n\t  // Skip handler.\n\t  skip: function skip(elem, name$$1, value) {\n\t    if (value) {\n\t      elem[$skip] = true;\n\t    } else {\n\t      delete elem[$skip];\n\t    }\n\t  }\n\t}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n\t  var _ref = customElements.get(elem.localName) || {\n\t    props: {},\n\t    prototype: {}\n\t  };\n\t\n\t  var props$$1 = _ref.props;\n\t  var prototype = _ref.prototype;\n\t\n\t  // TODO when refactoring properties to not have to workaround the old\n\t  // WebKit bug we can remove the \"name in props\" check below.\n\t  //\n\t  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n\t  // elements that set a property that isn't explicitly specified in \"props\"\n\t  // or \"prototype\" unless it is added to the element explicitly as a\n\t  // property prior to passing the prop to the vdom function. For example, if\n\t  // it were added in a lifecycle callback because it wouldn't have been\n\t  // upgraded yet.\n\t  //\n\t  // We prefer setting props, so we do this if there's a property matching\n\t  // name that was passed. However, certain props on SVG elements are\n\t  // readonly and error when you try to set them.\n\t\n\t  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n\t    incrementalDom.applyProp(elem, name$$1, value);\n\t    return;\n\t  }\n\t\n\t  // Explicit false removes the attribute.\n\t  if (value === false) {\n\t    applyDefault(elem, name$$1);\n\t    return;\n\t  }\n\t\n\t  // Handle built-in and custom events.\n\t  if (name$$1.indexOf('on') === 0) {\n\t    var firstChar = name$$1[2];\n\t    var eventName = void 0;\n\t\n\t    if (firstChar === '-') {\n\t      eventName = name$$1.substring(3);\n\t    } else if (firstChar === firstChar.toUpperCase()) {\n\t      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n\t    }\n\t\n\t    if (eventName) {\n\t      applyEvent(elem, eventName, value);\n\t      return;\n\t    }\n\t  }\n\t\n\t  applyDefault(elem, name$$1, value);\n\t}));\n\t\n\tfunction resolveTagName(name$$1) {\n\t  // We return falsy values as some wrapped IDOM functions allow empty values.\n\t  if (!name$$1) {\n\t    return name$$1;\n\t  }\n\t\n\t  // We try and return the cached tag name, if one exists.\n\t  if (name$$1[name]) {\n\t    return name$$1[name];\n\t  }\n\t\n\t  // If it's a custom element, we get the tag name by constructing it and\n\t  // caching it.\n\t  if (name$$1.prototype instanceof HTMLElement) {\n\t    // eslint-disable-next-line\n\t    var elem = new name$$1();\n\t    return name$$1[name] = elem.localName;\n\t  }\n\t\n\t  // Pass all other values through so IDOM gets what it's expecting.\n\t  return name$$1;\n\t}\n\t\n\t// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n\t// so it's the only function we need to execute in the context of our attributes.\n\tvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\t\n\tfunction elementOpenStart(tag) {\n\t  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t  overrideArgs = [tag, key, statics];\n\t}\n\t\n\tfunction elementOpenEnd() {\n\t  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n\t  overrideArgs = null;\n\t  return node;\n\t}\n\t\n\tfunction wrapIdomFunc(func) {\n\t  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\t\n\t  return function wrap() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args[0] = resolveTagName(args[0]);\n\t    stackCurrentHelper = null;\n\t    if (typeof args[0] === 'function') {\n\t      // If we've encountered a function, handle it according to the type of\n\t      // function that is being wrapped.\n\t      stackCurrentHelper = args[0];\n\t      return tnameFuncHandler.apply(undefined, args);\n\t    } else if (stackChren.length) {\n\t      // We pass the wrap() function in here so that when it's called as\n\t      // children, it will queue up for the next stack, if there is one.\n\t      stackChren[stackChren.length - 1].push([wrap, args]);\n\t    } else {\n\t      if (func === elementOpen$1) {\n\t        if (skips) {\n\t          return ++skips;\n\t        }\n\t\n\t        var elem = func.apply(undefined, args);\n\t\n\t        if (elem[$skip]) {\n\t          ++skips;\n\t        }\n\t\n\t        return elem;\n\t      }\n\t\n\t      if (func === incrementalDom.elementClose) {\n\t        if (skips === 1) {\n\t          incrementalDom.skip();\n\t        }\n\t\n\t        // We only want to skip closing if it's not the last closing tag in the\n\t        // skipped tree because we keep the element that initiated the skpping.\n\t        if (skips && --skips) {\n\t          return;\n\t        }\n\t\n\t        var _elem = func.apply(undefined, args);\n\t        var ref$$1 = _elem[ref$1];\n\t\n\t        // We delete so that it isn't called again for the same element. If the\n\t        // ref changes, or the element changes, this will be defined again.\n\t        delete _elem[ref$1];\n\t\n\t        // Execute the saved ref after esuring we've cleand up after it.\n\t        if (typeof ref$$1 === 'function') {\n\t          ref$$1(_elem);\n\t        }\n\t\n\t        return _elem;\n\t      }\n\t\n\t      // We must call elementOpenStart and elementOpenEnd even if we are\n\t      // skipping because they queue up attributes and then call elementClose.\n\t      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n\t        return func.apply(undefined, args);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction newAttr() {\n\t  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t    args[_key2] = arguments[_key2];\n\t  }\n\t\n\t  if (stackCurrentHelper) {\n\t    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n\t  } else if (stackChren.length) {\n\t    stackChren[stackChren.length - 1].push([newAttr, args]);\n\t  } else {\n\t    overrideArgs.push(args[0]);\n\t    overrideArgs.push(args[1]);\n\t  }\n\t}\n\t\n\tfunction stackOpen(tname, key, statics) {\n\t  var props$$1 = { key: key, statics: statics };\n\t\n\t  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n\t    attrs[_key3 - 3] = arguments[_key3];\n\t  }\n\t\n\t  for (var a = 0; a < attrs.length; a += 2) {\n\t    props$$1[attrs[a]] = attrs[a + 1];\n\t  }\n\t  tname[$stackCurrentHelperProps] = props$$1;\n\t  stackChren.push([]);\n\t}\n\t\n\tfunction stackClose(tname) {\n\t  var chren = stackChren.pop();\n\t  var props$$1 = tname[$stackCurrentHelperProps];\n\t  delete tname[$stackCurrentHelperProps];\n\t  var elemOrFn = tname(props$$1, function () {\n\t    return chren.forEach(function (args) {\n\t      return args[0].apply(args, toConsumableArray(args[1]));\n\t    });\n\t  });\n\t  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n\t}\n\t\n\t// Incremental DOM overrides\n\t// -------------------------\n\t\n\t// We must override internal functions that call internal Incremental DOM\n\t// functions because we can't override the internal references. This means\n\t// we must roughly re-implement their behaviour. Luckily, they're fairly\n\t// simple.\n\tvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\n\tvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\t\n\t// Standard open / closed overrides don't need to reproduce internal behaviour\n\t// because they are the ones referenced from *End and *Start.\n\tvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\n\tvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\t\n\t// Ensure we call our overridden functions instead of the internal ones.\n\tfunction newElementVoid(tag) {\n\t  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t    args[_key4 - 1] = arguments[_key4];\n\t  }\n\t\n\t  newElementOpen.apply(undefined, [tag].concat(args));\n\t  return newElementClose(tag);\n\t}\n\t\n\t// Text override ensures their calls can queue if using function helpers.\n\tvar newText = wrapIdomFunc(incrementalDom.text);\n\t\n\t// Convenience function for declaring an Incremental DOM element using\n\t// hyperscript-style syntax.\n\tfunction element(tname, attrs) {\n\t  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\t\n\t  // If attributes are a function, then they should be treated as children.\n\t\n\t  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n\t    chren[_key5 - 2] = arguments[_key5];\n\t  }\n\t\n\t  if (atype === 'function' || atype === 'string' || atype === 'number') {\n\t    chren.unshift(attrs);\n\t  }\n\t\n\t  // Ensure the attributes are an object. Null is considered an object so we\n\t  // have to test for this explicitly.\n\t  if (attrs === null || atype !== 'object') {\n\t    attrs = {};\n\t  }\n\t\n\t  // We open the element so we can set attrs after.\n\t  newElementOpenStart(tname, attrs.key, attrs.statics);\n\t\n\t  // Delete so special attrs don't actually get set.\n\t  delete attrs.key;\n\t  delete attrs.statics;\n\t\n\t  // Set attributes.\n\t  Object.keys(attrs).forEach(function (name$$1) {\n\t    return newAttr(name$$1, attrs[name$$1]);\n\t  });\n\t\n\t  // Close before we render the descendant tree.\n\t  newElementOpenEnd(tname);\n\t\n\t  chren.forEach(function (ch) {\n\t    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n\t    if (ctype === 'function') {\n\t      ch();\n\t    } else if (ctype === 'string' || ctype === 'number') {\n\t      newText(ch);\n\t    } else if (Array.isArray(ch)) {\n\t      ch.forEach(function (sch) {\n\t        return sch();\n\t      });\n\t    }\n\t  });\n\t\n\t  return newElementClose(tname);\n\t}\n\t\n\t// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n\t// transpiles for JSX (React.createElement() / h).\n\tfunction builder() {\n\t  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t    tags[_key6] = arguments[_key6];\n\t  }\n\t\n\t  if (tags.length === 0) {\n\t    return function () {\n\t      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n\t        args[_key7] = arguments[_key7];\n\t      }\n\t\n\t      return element.bind.apply(element, [null].concat(args));\n\t    };\n\t  }\n\t  return tags.map(function (tag) {\n\t    return function () {\n\t      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n\t        args[_key8] = arguments[_key8];\n\t      }\n\t\n\t      return element.bind.apply(element, [null, tag].concat(args));\n\t    };\n\t  });\n\t}\n\t\n\t\n\t\n\tvar vdom = Object.freeze({\n\t\telement: element,\n\t\tbuilder: builder,\n\t\tattr: newAttr,\n\t\telementClose: newElementClose,\n\t\telementOpen: newElementOpen,\n\t\telementOpenEnd: newElementOpenEnd,\n\t\telementOpenStart: newElementOpenStart,\n\t\telementVoid: newElementVoid,\n\t\ttext: newText\n\t});\n\t\n\tfunction createSymbol(description) {\n\t  return typeof Symbol === 'function' ? Symbol(description) : description;\n\t}\n\t\n\tvar data = function (element) {\n\t  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t\n\t  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n\t};\n\t\n\tvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n\t];\n\tvar native = (function (fn) {\n\t  return nativeHints.map(function (hint) {\n\t    return (fn || '').toString().indexOf([hint]) > -1;\n\t  }).reduce(function (a, b) {\n\t    return a || b;\n\t  });\n\t});\n\t\n\tvar MutationObserver = root.MutationObserver;\n\t\n\t\n\tfunction microtaskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var i = 0;\n\t  var cbArgs = [];\n\t  var elem = document.createElement('span');\n\t  var observer = new MutationObserver(function () {\n\t    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t    scheduled = false;\n\t    cbArgs = null;\n\t  });\n\t\n\t  observer.observe(elem, { childList: true });\n\t\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      elem.textContent = '' + i;\n\t      i += 1;\n\t    }\n\t  };\n\t}\n\t\n\t// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n\t// polyfill requires that the element be in the document to trigger Mutation\n\t// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n\t//\n\t// The soonest we can set the timeout for in IE is 1 as they have issues when\n\t// setting to 0.\n\tfunction taskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var cbArgs = [];\n\t  return function () {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      setTimeout(function () {\n\t        scheduled = false;\n\t        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t      }, 1);\n\t    }\n\t  };\n\t}\n\tvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\t\n\tvar isFunction = function isFunction(val) {\n\t  return typeof val === 'function';\n\t};\n\tvar isUndefined = function isUndefined(val) {\n\t  return typeof val === 'undefined';\n\t};\n\t\n\t/**\n\t * @internal\n\t * Attributes Manager\n\t *\n\t * Postpones attributes updates until when connected.\n\t */\n\t\n\tvar AttributesManager = function () {\n\t  function AttributesManager(elem) {\n\t    classCallCheck(this, AttributesManager);\n\t\n\t    this.elem = elem;\n\t    this.connected = false;\n\t    this.pendingValues = {};\n\t    this.lastSetValues = {};\n\t  }\n\t\n\t  /**\n\t   * Called from disconnectedCallback\n\t   */\n\t\n\t\n\t  createClass(AttributesManager, [{\n\t    key: 'suspendAttributesUpdates',\n\t    value: function suspendAttributesUpdates() {\n\t      this.connected = false;\n\t    }\n\t\n\t    /**\n\t     * Called from connectedCallback\n\t     */\n\t\n\t  }, {\n\t    key: 'resumeAttributesUpdates',\n\t    value: function resumeAttributesUpdates() {\n\t      var _this = this;\n\t\n\t      this.connected = true;\n\t      var names = Object.keys(this.pendingValues);\n\t      names.forEach(function (name) {\n\t        var value = _this.pendingValues[name];\n\t        // Skip if already cleared\n\t        if (!isUndefined(value)) {\n\t          delete _this.pendingValues[name];\n\t          _this._syncAttrValue(name, value);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns true if the value is different from the one set internally\n\t     * using setAttrValue()\n\t     */\n\t\n\t  }, {\n\t    key: 'onAttributeChanged',\n\t    value: function onAttributeChanged(name, value) {\n\t      value = toNullOrString(value);\n\t\n\t      // A new attribute value voids the pending one\n\t      this._clearPendingValue(name);\n\t\n\t      var changed = this.lastSetValues[name] !== value;\n\t      this.lastSetValues[name] = value;\n\t      return changed;\n\t    }\n\t\n\t    /**\n\t     * Updates or removes the attribute if value === null.\n\t     *\n\t     * When the component is not connected the value is saved and\n\t     * the attribute is only updated when the component is re-connected.\n\t     */\n\t\n\t  }, {\n\t    key: 'setAttrValue',\n\t    value: function setAttrValue(name, value) {\n\t      value = toNullOrString(value);\n\t\n\t      this.lastSetValues[name] = value;\n\t\n\t      if (this.connected) {\n\t        this._clearPendingValue(name);\n\t        this._syncAttrValue(name, value);\n\t      } else {\n\t        this.pendingValues[name] = value;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_syncAttrValue',\n\t    value: function _syncAttrValue(name, value) {\n\t      var currAttrValue = toNullOrString(this.elem.getAttribute(name));\n\t      if (value !== currAttrValue) {\n\t        if (value === null) {\n\t          this.elem.removeAttribute(name);\n\t        } else {\n\t          this.elem.setAttribute(name, value);\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_clearPendingValue',\n\t    value: function _clearPendingValue(name) {\n\t      if (name in this.pendingValues) {\n\t        delete this.pendingValues[name];\n\t      }\n\t    }\n\t  }]);\n\t  return AttributesManager;\n\t}();\n\t\n\t// Only used by getAttrMgr\n\t\n\t\n\tvar $attributesMgr = '____skate_attributesMgr';\n\t\n\t/**\n\t * @internal\n\t * Returns attribute manager instance for the given Component\n\t */\n\tfunction getAttrMgr(elem) {\n\t  var mgr = elem[$attributesMgr];\n\t  if (!mgr) {\n\t    mgr = new AttributesManager(elem);\n\t    elem[$attributesMgr] = mgr;\n\t  }\n\t  return mgr;\n\t}\n\t\n\tvar getOwnPropertyDescriptors = function () {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  return keys(obj).reduce(function (prev, curr) {\n\t    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t    return prev;\n\t  }, {});\n\t};\n\t\n\tvar dashCase = function (str) {\n\t  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t    var dash = !one || idx % 2 === 0 ? '' : '-';\n\t    return '' + one + dash + two.toLowerCase();\n\t  });\n\t};\n\t\n\tfunction error$1(message) {\n\t  var DEBUG = root.DEBUG;\n\t\n\t  if (!isUndefined(DEBUG) && DEBUG) {\n\t    console.error(message);\n\t  } else {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\t/**\n\t * @internal\n\t * Property Definition\n\t *\n\t * Internal meta data and strategies for a property.\n\t * Created from the options of a PropOptions config object.\n\t *\n\t * Once created a PropDefinition should be treated as immutable and final.\n\t * 'getPropsMap' function memoizes PropDefinitions by Component's Class.\n\t *\n\t * The 'attribute' option is normalized into the 'attrName' property.\n\t */\n\t\n\tvar PropDefinition = function () {\n\t  function PropDefinition(nameOrSymbol, propOptions) {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, PropDefinition);\n\t\n\t    this._name = nameOrSymbol;\n\t\n\t    propOptions = propOptions || {};\n\t\n\t    // default 'attrName': no linked attribute\n\t    this.attrName = null;\n\t\n\t    // default 'coerce': identity function\n\t    this.coerce = function (value) {\n\t      return value;\n\t    };\n\t\n\t    // default 'default': set prop to 'null'\n\t    this.default = null;\n\t\n\t    // default 'deserialize': return attribute's value (string or null)\n\t    this.deserialize = function (value) {\n\t      return value;\n\t    };\n\t\n\t    // default 'get': no function\n\t    this.get = null;\n\t\n\t    // 'initial' default: unspecified\n\t    // 'initial' option is truly optional and it cannot be initialized.\n\t    // Its presence is tested using: ('initial' in propDef)\n\t\n\t    // 'serialize' default: return string value or null\n\t    this.serialize = function (value) {\n\t      return empty(value) ? null : String(value);\n\t    };\n\t\n\t    // default 'set': no function\n\t    this.set = null;\n\t\n\t    // Note: option key is always a string (no symbols here)\n\t    Object.keys(propOptions).forEach(function (option) {\n\t      var optVal = propOptions[option];\n\t\n\t      // Only accept documented options and perform minimal input validation.\n\t      switch (option) {\n\t        case 'attribute':\n\t          _this.attrName = resolveAttrName(optVal, nameOrSymbol);\n\t          break;\n\t        case 'coerce':\n\t        case 'deserialize':\n\t        case 'get':\n\t        case 'serialize':\n\t        case 'set':\n\t          if (isFunction(optVal)) {\n\t            _this[option] = optVal;\n\t          } else {\n\t            error$1(option + ' must be a function.');\n\t          }\n\t          break;\n\t        case 'default':\n\t        case 'initial':\n\t          _this[option] = optVal;\n\t          break;\n\t        default:\n\t          error$1(option + ' is not a valid option. Options are: attribute, initial, default, coerce, deserialize, serialize.');\n\t          break;\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(PropDefinition, [{\n\t    key: 'name',\n\t    get: function get() {\n\t      return this._name;\n\t    }\n\t  }]);\n\t  return PropDefinition;\n\t}();\n\t\n\tfunction resolveAttrName(attrOption, nameOrSymbol) {\n\t  if ((typeof nameOrSymbol === 'undefined' ? 'undefined' : _typeof(nameOrSymbol)) === 'symbol') {\n\t    error$1(nameOrSymbol.toString() + ' symbol property cannot have an attribute.');\n\t  } else {\n\t    if (attrOption === true) {\n\t      return dashCase(String(nameOrSymbol));\n\t    }\n\t    if (typeof attrOption === 'string') {\n\t      return attrOption;\n\t    }\n\t  }\n\t  return null;\n\t}\n\t\n\t/**\n\t * This is needed to avoid IE11 \"stack size errors\" when creating\n\t * a new property on the constructor of an HTMLElement\n\t */\n\tfunction setCtorNativeProperty(Ctor, propName, value) {\n\t  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n\t}\n\t\n\t/**\n\t * Memoizes a map of PropDefinition for the given component class.\n\t * Keys in the map are the properties name which can a string or a symbol.\n\t *\n\t * The map is created from the result of: static get props\n\t */\n\tfunction getPropsMap(Ctor) {\n\t  // Must be defined on constructor and not from a superclass\n\t  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n\t    (function () {\n\t      var props$$1 = Ctor.props || {};\n\t\n\t      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n\t        result[propNameOrSymbol] = new PropDefinition(propNameOrSymbol, props$$1[propNameOrSymbol]);\n\t        return result;\n\t      }, {});\n\t      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n\t    })();\n\t  }\n\t\n\t  return Ctor[ctorPropsMap];\n\t}\n\t\n\tfunction get$2(elem) {\n\t  var props$$1 = {};\n\t\n\t  keys(getPropsMap(elem.constructor)).forEach(function (propNameOrSymbol) {\n\t    props$$1[propNameOrSymbol] = elem[propNameOrSymbol];\n\t  });\n\t\n\t  return props$$1;\n\t}\n\t\n\tfunction set$2(elem, newProps) {\n\t  assign(elem, newProps);\n\t  if (elem[renderer$1]) {\n\t    elem[renderer$1]();\n\t  }\n\t}\n\t\n\tvar props$1 = function (elem, newProps) {\n\t  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n\t};\n\t\n\tfunction getDefaultValue(elem, propDef) {\n\t  return typeof propDef.default === 'function' ? propDef.default(elem, { name: propDef.name }) : propDef.default;\n\t}\n\t\n\tfunction getInitialValue(elem, propDef) {\n\t  return typeof propDef.initial === 'function' ? propDef.initial(elem, { name: propDef.name }) : propDef.initial;\n\t}\n\t\n\tfunction getPropData(elem, name) {\n\t  var elemData = data(elem, 'props');\n\t  return elemData[name] || (elemData[name] = {});\n\t}\n\t\n\tfunction createNativePropertyDescriptor(propDef) {\n\t  var nameOrSymbol = propDef.name;\n\t\n\t  var prop = {\n\t    configurable: true,\n\t    enumerable: true\n\t  };\n\t\n\t  prop.beforeDefineProperty = function (elem) {\n\t    var propData = getPropData(elem, nameOrSymbol);\n\t    var attrName = propDef.attrName;\n\t\n\t    // Store attribute to property link.\n\t    if (attrName) {\n\t      data(elem, 'attributeLinks')[attrName] = nameOrSymbol;\n\t    }\n\t\n\t    // prop value before upgrading\n\t    var initialValue = elem[nameOrSymbol];\n\t\n\t    // Set up initial value if it wasn't specified.\n\t    var valueFromAttribute = false;\n\t    if (empty(initialValue)) {\n\t      if (attrName && elem.hasAttribute(attrName)) {\n\t        valueFromAttribute = true;\n\t        initialValue = propDef.deserialize(elem.getAttribute(attrName));\n\t      } else if ('initial' in propDef) {\n\t        initialValue = getInitialValue(elem, propDef);\n\t      } else {\n\t        initialValue = getDefaultValue(elem, propDef);\n\t      }\n\t    }\n\t\n\t    initialValue = propDef.coerce(initialValue);\n\t\n\t    propData.internalValue = initialValue;\n\t\n\t    // Reflect to attribute unless valueFromAttribute\n\t    if (!valueFromAttribute && attrName && !empty(initialValue)) {\n\t      var serializedValue = propDef.serialize(initialValue);\n\t      getAttrMgr(elem).setAttrValue(propDef.attrName, serializedValue);\n\t    }\n\t  };\n\t\n\t  prop.get = function get() {\n\t    var propData = getPropData(this, nameOrSymbol);\n\t    var internalValue = propData.internalValue;\n\t\n\t    return propDef.get ? propDef.get(this, { name: nameOrSymbol, internalValue: internalValue }) : internalValue;\n\t  };\n\t\n\t  prop.set = function set(newValue) {\n\t    var propData = getPropData(this, nameOrSymbol);\n\t\n\t    var useDefaultValue = empty(newValue);\n\t    if (useDefaultValue) {\n\t      newValue = getDefaultValue(this, propDef);\n\t    }\n\t\n\t    newValue = propDef.coerce(newValue);\n\t\n\t    if (propDef.set) {\n\t      var oldValue = propData.oldValue;\n\t\n\t\n\t      if (empty(oldValue)) {\n\t        oldValue = null;\n\t      }\n\t      var changeData = { name: nameOrSymbol, newValue: newValue, oldValue: oldValue };\n\t      propDef.set(this, changeData);\n\t    }\n\t\n\t    // Queue a re-render.\n\t    this[rendererDebounced](this);\n\t\n\t    // Update prop data so we can use it next time.\n\t    propData.internalValue = propData.oldValue = newValue;\n\t\n\t    // Link up the attribute.\n\t    if (propDef.attrName && !propData.settingProp) {\n\t      // Note: setting the prop to empty implies the default value\n\t      // and therefore no attribute should be present!\n\t      var serializedValue = useDefaultValue ? null : propDef.serialize(newValue);\n\t      getAttrMgr(this).setAttrValue(propDef.attrName, serializedValue);\n\t    }\n\t  };\n\t\n\t  return prop;\n\t}\n\t\n\tvar objectIs = (function (x, y) {\n\t  if (Object.is) {\n\t    return Object.is(x, y);\n\t  }\n\t  // SameValue algorithm\n\t  if (x === y) {\n\t    // Steps 1-5, 7-10\n\t    // Steps 6.b-6.e: +0 != -0\n\t    return x !== 0 || 1 / x === 1 / y;\n\t  } else {\n\t    // Step 6.a: NaN == NaN\n\t    return x !== x && y !== y;\n\t  }\n\t});\n\t\n\tvar HTMLElement$1 = root.HTMLElement || function () {\n\t  function _class() {\n\t    classCallCheck(this, _class);\n\t  }\n\t\n\t  return _class;\n\t}();\n\tvar _prevName = createSymbol('prevName');\n\tvar _prevOldValue = createSymbol('prevOldValue');\n\tvar _prevNewValue = createSymbol('prevNewValue');\n\t\n\tfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n\t  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n\t}\n\t\n\t// TODO remove when not catering to Safari < 10.\n\tfunction createNativePropertyDescriptors(Ctor) {\n\t  var propDefs = getPropsMap(Ctor);\n\t  return keys(propDefs).reduce(function (propDescriptors, propName) {\n\t    propDescriptors[propName] = createNativePropertyDescriptor(propDefs[propName]);\n\t    return propDescriptors;\n\t  }, {});\n\t}\n\t\n\t// TODO refactor when not catering to Safari < 10.\n\t//\n\t// We should be able to simplify this where all we do is Object.defineProperty().\n\tfunction createInitProps(Ctor) {\n\t  var propDescriptors = createNativePropertyDescriptors(Ctor);\n\t\n\t  return function (elem) {\n\t    keys(propDescriptors).forEach(function (name$$1) {\n\t      var propDescriptor = propDescriptors[name$$1];\n\t      propDescriptor.beforeDefineProperty(elem);\n\t\n\t      // We check here before defining to see if the prop was specified prior\n\t      // to upgrading.\n\t      var hasPropBeforeUpgrading = name$$1 in elem;\n\t\n\t      // This is saved prior to defining so that we can set it after it it was\n\t      // defined prior to upgrading. We don't want to invoke the getter if we\n\t      // don't need to, so we only get the value if we need to re-sync.\n\t      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\t\n\t      // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t      //\n\t      // When Webkit fixes that bug so that native property accessors can be\n\t      // retrieved, we can move defining the property to the prototype and away\n\t      // from having to do if for every instance as all other browsers support\n\t      // this.\n\t      Object.defineProperty(elem, name$$1, propDescriptor);\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We'll be removing get / set callbacks on properties. Use the\n\t      // updatedCallback() instead.\n\t      //\n\t      // We re-set the prop if it was specified prior to upgrading because we\n\t      // need to ensure set() is triggered both in polyfilled environments and\n\t      // in native where the definition may be registerd after elements it\n\t      // represents have already been created.\n\t      if (hasPropBeforeUpgrading) {\n\t        elem[name$$1] = valueBeforeUpgrading;\n\t      }\n\t    });\n\t  };\n\t}\n\t\n\tvar _class2 = function (_HTMLElement) {\n\t  inherits(_class2, _HTMLElement);\n\t  createClass(_class2, null, [{\n\t    key: 'observedAttributes',\n\t\n\t    /**\n\t     * Returns unique attribute names configured with props and\n\t     * those set on the Component constructor if any\n\t     */\n\t    get: function get() {\n\t      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n\t      var propDefs = getPropsMap(this);\n\t\n\t      // Use Object.keys to skips symbol props since they have no linked attributes\n\t      var attrsFromLinkedProps = Object.keys(propDefs).map(function (propName) {\n\t        return propDefs[propName].attrName;\n\t      }).filter(Boolean);\n\t\n\t      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n\t      return all.filter(function (item, index) {\n\t        return all.indexOf(item) === index;\n\t      });\n\t    },\n\t    set: function set(value) {\n\t      value = Array.isArray(value) ? value : [];\n\t      setCtorNativeProperty(this, 'observedAttributes', value);\n\t    }\n\t\n\t    // Returns superclass props overwritten with this Component props\n\t\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n\t    },\n\t    set: function set(value) {\n\t      setCtorNativeProperty(this, ctorProps, value);\n\t    }\n\t\n\t    // Passing args is designed to work with document-register-element. It's not\n\t    // necessary for the webcomponents/custom-element polyfill.\n\t\n\t  }]);\n\t\n\t  function _class2() {\n\t    var _ref;\n\t\n\t    classCallCheck(this, _class2);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var _this = possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\n\t\n\t    var constructor = _this.constructor;\n\t\n\t    // Used for the ready() function so it knows when it can call its callback.\n\t\n\t    _this[created] = true;\n\t\n\t    // TODO refactor to not cater to Safari < 10. This means we can depend on\n\t    // built-in property descriptors.\n\t    // Must be defined on constructor and not from a superclass\n\t    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n\t      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n\t    }\n\t\n\t    // Set up a renderer that is debounced for property sets to call directly.\n\t    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\t\n\t    // Set up property lifecycle.\n\t    var propDefsCount = keys(getPropsMap(constructor)).length;\n\t    if (propDefsCount && constructor[ctorCreateInitProps]) {\n\t      constructor[ctorCreateInitProps](_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static render()\n\t    // Note that renderCallback is an optional method!\n\t    if (!_this.renderCallback && constructor.render) {\n\t      _this.renderCallback = constructor.render.bind(constructor, _this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static created()\n\t    //\n\t    // Props should be set up before calling this.\n\t    var created$$1 = constructor.created;\n\t\n\t    if (isFunction(created$$1)) {\n\t      created$$1(_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // Feature has rarely been used.\n\t    //\n\t    // Created should be set before invoking the ready listeners.\n\t    var elemData = data(_this);\n\t    var readyCallbacks = elemData.readyCallbacks;\n\t    if (readyCallbacks) {\n\t      readyCallbacks.forEach(function (cb) {\n\t        return cb(_this);\n\t      });\n\t      delete elemData.readyCallbacks;\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  // Custom Elements v1\n\t\n\t\n\t  createClass(_class2, [{\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      // Reflect attributes pending values\n\t      getAttrMgr(this).resumeAttributesUpdates();\n\t\n\t      // Used to check whether or not the component can render.\n\t      this[connected] = true;\n\t\n\t      // Render!\n\t      this[rendererDebounced]();\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static attached()\n\t      var attached = this.constructor.attached;\n\t\n\t      if (isFunction(attached)) {\n\t        attached(this);\n\t      }\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We can remove this once all browsers support :defined.\n\t      this.setAttribute('defined', '');\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'disconnectedCallback',\n\t    value: function disconnectedCallback() {\n\t      // Suspend updating attributes until re-connected\n\t      getAttrMgr(this).suspendAttributesUpdates();\n\t\n\t      // Ensures the component can't be rendered while disconnected.\n\t      this[connected] = false;\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static detached()\n\t      var detached = this.constructor.detached;\n\t\n\t      if (isFunction(detached)) {\n\t        detached(this);\n\t      }\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n\t      // Polyfill calls this twice.\n\t      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n\t        return;\n\t      }\n\t\n\t      // Set data so we can prevent double calling if the polyfill.\n\t      this[_prevName] = name$$1;\n\t      this[_prevOldValue] = oldValue;\n\t      this[_prevNewValue] = newValue;\n\t\n\t      var propNameOrSymbol = data(this, 'attributeLinks')[name$$1];\n\t      if (propNameOrSymbol) {\n\t        var changedExternally = getAttrMgr(this).onAttributeChanged(name$$1, newValue);\n\t        if (changedExternally) {\n\t          // Sync up the property.\n\t          var propDef = getPropsMap(this.constructor)[propNameOrSymbol];\n\t          var newPropVal = newValue !== null && propDef.deserialize ? propDef.deserialize(newValue) : newValue;\n\t\n\t          var propData = data(this, 'props')[propNameOrSymbol];\n\t          propData.settingProp = true;\n\t          this[propNameOrSymbol] = newPropVal;\n\t          propData.settingProp = false;\n\t        }\n\t      }\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static attributeChanged()\n\t      var attributeChanged = this.constructor.attributeChanged;\n\t\n\t      if (isFunction(attributeChanged)) {\n\t        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n\t      }\n\t    }\n\t\n\t    // Skate\n\t\n\t  }, {\n\t    key: 'updatedCallback',\n\t    value: function updatedCallback(prevProps) {\n\t      return this.constructor.updated(this, prevProps);\n\t    }\n\t\n\t    // Skate\n\t\n\t  }, {\n\t    key: 'renderedCallback',\n\t    value: function renderedCallback() {\n\t      return this.constructor.rendered(this);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static renderer() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t    // todo: finalize how to support different rendering strategies.\n\t\n\t  }, {\n\t    key: 'rendererCallback',\n\t    value: function rendererCallback() {\n\t      // todo: cannot move code here because tests expects renderer function to still exist on constructor!\n\t      return this.constructor.renderer(this);\n\t    }\n\t\n\t    // Skate\n\t    // @internal\n\t    // Invokes the complete render lifecycle.\n\t\n\t  }, {\n\t    key: renderer$1,\n\t    value: function value() {\n\t      if (this[rendering] || !this[connected]) {\n\t        return;\n\t      }\n\t\n\t      // Flag as rendering. This prevents anything from trying to render - or\n\t      // queueing a render - while there is a pending render.\n\t      this[rendering] = true;\n\t      if (this[updated$1]() && isFunction(this.renderCallback)) {\n\t        this.rendererCallback();\n\t        this.renderedCallback();\n\t      }\n\t\n\t      this[rendering] = false;\n\t    }\n\t\n\t    // Skate\n\t    // @internal\n\t    // Calls the updatedCallback() with previous props.\n\t\n\t  }, {\n\t    key: updated$1,\n\t    value: function value() {\n\t      var prevProps = this[props];\n\t      this[props] = props$1(this);\n\t      return this.updatedCallback(prevProps);\n\t    }\n\t\n\t    // Skate\n\t\n\t  }], [{\n\t    key: 'extend',\n\t    value: function extend() {\n\t      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\t\n\t      // Create class for the user.\n\t      var Ctor = function (_Base) {\n\t        inherits(Ctor, _Base);\n\t\n\t        function Ctor() {\n\t          classCallCheck(this, Ctor);\n\t          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n\t        }\n\t\n\t        return Ctor;\n\t      }(Base);\n\t\n\t      // For inheriting from the object literal.\n\t\n\t\n\t      var opts = getOwnPropertyDescriptors(definition);\n\t      var prot = getOwnPropertyDescriptors(definition.prototype);\n\t\n\t      // Prototype is non configurable (but is writable).\n\t      delete opts.prototype;\n\t\n\t      // Pass on static and instance members from the definition.\n\t      Object.defineProperties(Ctor, opts);\n\t      Object.defineProperties(Ctor.prototype, prot);\n\t\n\t      return Ctor;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Stubbed in case any subclasses are calling it.\n\t\n\t  }, {\n\t    key: 'rendered',\n\t    value: function rendered() {}\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'renderer',\n\t    value: function renderer(elem) {\n\t      if (!elem.shadowRoot) {\n\t        elem.attachShadow({ mode: 'open' });\n\t      }\n\t      incrementalDom.patchInner(elem.shadowRoot, function () {\n\t        var possibleFn = elem.renderCallback();\n\t        if (isFunction(possibleFn)) {\n\t          possibleFn();\n\t        } else if (Array.isArray(possibleFn)) {\n\t          possibleFn.forEach(function (fn) {\n\t            if (isFunction(fn)) {\n\t              fn();\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to updatedCallback() before removing.\n\t\n\t  }, {\n\t    key: 'updated',\n\t    value: function updated(elem, prevProps) {\n\t      // short-circuits if this is the first time\n\t      if (!prevProps) {\n\t        return true;\n\t      }\n\t\n\t      // Use getAllKeys to include all props names and Symbols\n\t      var allKeys = keys(prevProps);\n\t\n\t      // Use classic loop because 'for ... of' skips symbols\n\t      for (var i = 0; i < allKeys.length; i++) {\n\t        var nameOrSymbol = allKeys[i];\n\t\n\t        // Object.is (NaN is equal NaN)\n\t        if (!objectIs(prevProps[nameOrSymbol], elem[nameOrSymbol])) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t  }]);\n\t  return _class2;\n\t}(HTMLElement$1);\n\t\n\tfunction uniqueId(prefix) {\n\t  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n\t  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    // eslint-disable-next-line no-mixed-operators\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t  return (prefix || 'x') + '-' + rand;\n\t}\n\t\n\tvar define = function () {\n\t  var customElements = root.customElements;\n\t\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  var name$$1 = args[0];\n\t  var Ctor = args[1];\n\t\n\t\n\t  if (!customElements) {\n\t    throw new Error('Skate requires native custom element support or a polyfill.');\n\t  }\n\t\n\t  // Support passing an anonymous definition.\n\t  if (args.length === 1) {\n\t    // We are checking string for now, but once we remove the ability to pass\n\t    // an object literal, we can change this to check \"function\" and invert the\n\t    // blocks of logic.\n\t    if (typeof name$$1 === 'string') {\n\t      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n\t    } else {\n\t      Ctor = name$$1;\n\t      name$$1 = uniqueId();\n\t    }\n\t  }\n\t\n\t  // Ensure there's no conflicts.\n\t  if (customElements.get(name$$1)) {\n\t    name$$1 = uniqueId(name$$1);\n\t  }\n\t\n\t  // DEPRECATED\n\t  //\n\t  // Object literals.\n\t  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n\t    Ctor = _class2.extend(Ctor);\n\t  }\n\t\n\t  // This allows us to check this before instantiating the custom element to\n\t  // find its name from the constructor in the vdom module, thus improving\n\t  // performance but still falling back to a robust method.\n\t  Ctor[name] = name$$1;\n\t\n\t  // Sipmle define. Not supporting customised built-ins yet.\n\t  customElements.define(name$$1, Ctor);\n\t\n\t  // The spec doesn't return but this allows for a simpler, more concise API.\n\t  return Ctor;\n\t};\n\t\n\tvar Event = function (TheEvent) {\n\t  if (TheEvent) {\n\t    try {\n\t      new TheEvent('emit-init'); // eslint-disable-line no-new\n\t    } catch (e) {\n\t      return undefined;\n\t    }\n\t  }\n\t  return TheEvent;\n\t}(root.Event);\n\t\n\tfunction createCustomEvent(name) {\n\t  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var detail = opts.detail;\n\t\n\t  delete opts.detail;\n\t\n\t  var e = void 0;\n\t  if (Event) {\n\t    e = new Event(name, opts);\n\t    Object.defineProperty(e, 'detail', { value: detail });\n\t  } else {\n\t    e = document.createEvent('CustomEvent');\n\t    Object.defineProperty(e, 'composed', { value: opts.composed });\n\t    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n\t  }\n\t  return e;\n\t}\n\t\n\tvar emit = function (elem, name) {\n\t  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (opts.bubbles === undefined) {\n\t    opts.bubbles = true;\n\t  }\n\t  if (opts.cancelable === undefined) {\n\t    opts.cancelable = true;\n\t  }\n\t  if (opts.composed === undefined) {\n\t    opts.composed = true;\n\t  }\n\t  return elem.dispatchEvent(createCustomEvent(name, opts));\n\t};\n\t\n\tfunction getValue(elem) {\n\t  var type = elem.type;\n\t  if (type === 'checkbox' || type === 'radio') {\n\t    return elem.checked ? elem.value || true : false;\n\t  }\n\t  return elem.value;\n\t}\n\t\n\tvar link = function (elem, target) {\n\t  return function (e) {\n\t    var value = getValue(e.target);\n\t    var localTarget = target || e.target.name || 'value';\n\t\n\t    if (localTarget.indexOf('.') > -1) {\n\t      var parts = localTarget.split('.');\n\t      var firstPart = parts[0];\n\t      var propName = parts.pop();\n\t      var obj = parts.reduce(function (prev, curr) {\n\t        return prev && prev[curr];\n\t      }, elem);\n\t\n\t      obj[propName || e.target.name] = value;\n\t      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n\t    } else {\n\t      props$1(elem, defineProperty({}, localTarget, value));\n\t    }\n\t  };\n\t};\n\t\n\tvar ready = function (elem, done) {\n\t  var info = data(elem);\n\t  if (elem[created]) {\n\t    done(elem);\n\t  } else if (info.readyCallbacks) {\n\t    info.readyCallbacks.push(done);\n\t  } else {\n\t    info.readyCallbacks = [done];\n\t  }\n\t};\n\t\n\tvar h = builder();\n\t\n\texports.Component = _class2;\n\texports.define = define;\n\texports.emit = emit;\n\texports.h = h;\n\texports.link = link;\n\texports.prop = prop;\n\texports.props = props$1;\n\texports.ready = ready;\n\texports.symbols = symbols$1;\n\texports.vdom = vdom;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=index.js.map\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function (name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function (doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function (nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function (run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function (node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function () {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function () {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function () {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function () {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function (tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function () {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function () {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function () {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function () {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function (tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function (name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function () {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function (tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function (tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function (value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict'\n\tmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n\t  (typeof global === 'object' && global.global === global && global) ||\n\t  this\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.classes = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _base = __webpack_require__(6);\n\t\n\tvar _base2 = _interopRequireDefault(_base);\n\t\n\tvar _index = __webpack_require__(8);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar _document = document,\n\t    head = _document.head;\n\t\n\tvar cssBaseStyle = document.createElement('style');\n\tvar cssAppStyle = document.createElement('style');\n\t\n\tcssBaseStyle.textContent = _base2.default.toString();\n\tcssAppStyle.textContent = _index2.default.toString();\n\t\n\thead.appendChild(cssBaseStyle);\n\thead.appendChild(cssAppStyle);\n\t\n\texports.default = _base2.default.toString() + _index2.default.toString();\n\tvar classes = exports.classes = _extends({}, _base2.default.locals, _index2.default.locals);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"hr{margin:20px 0;border:0;border-top:1px dashed #c5c5c5;border-bottom:1px dashed #f7f7f7}.cPEPub0maVFxkzbgWUVOd a{font-weight:400;text-decoration:none;color:#b83f45}.cPEPub0maVFxkzbgWUVOd a:hover{text-decoration:underline;color:#787e7e}.cPEPub0maVFxkzbgWUVOd h3,.cPEPub0maVFxkzbgWUVOd h4,.cPEPub0maVFxkzbgWUVOd h5{margin:10px 0;font-weight:500;line-height:1.2;color:#000}.cPEPub0maVFxkzbgWUVOd h3{font-size:24px}.cPEPub0maVFxkzbgWUVOd h4{font-size:18px}.cPEPub0maVFxkzbgWUVOd h5{margin-bottom:0;font-size:14px}.cPEPub0maVFxkzbgWUVOd ul{padding:0;margin:0 0 30px 25px}.cPEPub0maVFxkzbgWUVOd li{line-height:20px}.cPEPub0maVFxkzbgWUVOd p{font-size:15px;font-weight:300;line-height:1.3;margin-top:0;margin-bottom:0}#_3-nj88w-cbLlFAkd9E0Nbc{display:none}._2L69OI9oxKrr_A0PkWO2KF{border:none;margin:20px 0 60px}._2L69OI9oxKrr_A0PkWO2KF p{font-style:italic}._2L69OI9oxKrr_A0PkWO2KF p:before{content:'\\\\201C';font-size:50px;opacity:.15;position:absolute;top:-20px;left:3px}._2L69OI9oxKrr_A0PkWO2KF p:after{content:'\\\\201D';font-size:50px;opacity:.15;position:absolute;bottom:-42px;right:3px}._2L69OI9oxKrr_A0PkWO2KF footer{position:absolute;bottom:-40px;right:0}._2L69OI9oxKrr_A0PkWO2KF footer img{border-radius:3px}._2L69OI9oxKrr_A0PkWO2KF footer a{margin-left:5px;vertical-align:middle}._1nt1kCjSYEPZou23lObNdv{position:relative;padding:10px;background:rgba(0,0,0,.04);border-radius:5px}._1nt1kCjSYEPZou23lObNdv:after{content:'';position:absolute;top:100%;right:30px;border:13px solid transparent;border-top-color:rgba(0,0,0,.04)}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{position:absolute;width:272px;top:8px;left:-300px;padding:10px;border-radius:5px;background-color:hsla(0,0%,100%,.6);transition-property:left;transition-duration:.5s}@media (min-width:899px){._2vLQrIvSjobb3988bLfSTa{width:auto;padding-left:300px}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{left:8px}}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\t\"issue-count\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\t\"issueCount\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\t\"speech-bubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\t\"speechBubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\t\"learn-bar\": \"_2vLQrIvSjobb3988bLfSTa\",\n\t\t\"learnBar\": \"_2vLQrIvSjobb3988bLfSTa\"\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"body,button,html{margin:0;padding:0}button{border:0;background:none;font-size:100%;vertical-align:baseline;font-family:inherit;font-weight:inherit;color:inherit;-webkit-appearance:none;appearance:none;-webkit-font-smoothing:antialiased}body,button{-moz-osx-font-smoothing:grayscale}body{font:14px Helvetica Neue,Helvetica,Arial,sans-serif;line-height:1.4em;background:#f5f5f5;color:#4d4d4d;min-width:230px;max-width:550px;margin:0 auto;-webkit-font-smoothing:antialiased;font-weight:300}:focus{outline:0}.RBzyqGlIYFAdozfNAWX9T{display:none}._2lTeO9Nfd9StmHCibrKyDn{background:#fff;margin:130px 0 40px;position:relative;box-shadow:0 2px 4px 0 rgba(0,0,0,.2),0 25px 50px 0 rgba(0,0,0,.1)}._2lTeO9Nfd9StmHCibrKyDn input::-webkit-input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::-moz-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn h1{position:absolute;top:-155px;width:100%;font-size:100px;font-weight:100;text-align:center;color:rgba(175,47,47,.15);-webkit-text-rendering:optimizeLegibility;-moz-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility}._3RmQY0IMcqwS7R81Tj0dlC,.vdff5WcLi7yBBYDjtZljm{position:relative;margin:0;width:100%;font-size:24px;font-family:inherit;font-weight:inherit;line-height:1.4em;border:0;color:inherit;padding:6px;border:1px solid #999;box-shadow:inset 0 -1px 5px 0 rgba(0,0,0,.2);box-sizing:border-box;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.vdff5WcLi7yBBYDjtZljm{padding:16px 16px 16px 60px;border:none;background:rgba(0,0,0,.003);box-shadow:inset 0 -2px 1px rgba(0,0,0,.03)}._3dnsc4idur8-yk5Sjjq6VG{position:relative;z-index:2;border-top:1px solid #e6e6e6}label[for=toggle-all]{display:none}.DG0VaCEN4BXUysJd_tTIb{position:absolute;top:-55px;left:-12px;width:60px;height:34px;text-align:center;border:none}.DG0VaCEN4BXUysJd_tTIb:before{content:'\\\\276F';font-size:22px;color:#e6e6e6;padding:10px 27px}.DG0VaCEN4BXUysJd_tTIb:checked:before{color:#737373}._1p_AB3iiKNbxBsOlJi5CVw{margin:0;padding:0;list-style:none}._1p_AB3iiKNbxBsOlJi5CVw li{position:relative;font-size:24px;border-bottom:1px solid #ededed}._1p_AB3iiKNbxBsOlJi5CVw li:last-child{border-bottom:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm{border-bottom:none;padding:0}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm ._3RmQY0IMcqwS7R81Tj0dlC{display:block;width:506px;padding:12px 16px;margin:0 0 0 43px}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm .oksgs4_M9fAGjexFoJHTE{display:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{text-align:center;width:40px;height:auto;position:absolute;top:0;bottom:0;margin:auto 0;border:none;-webkit-appearance:none;appearance:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#ededed\\\" stroke-width=\\\"3\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:checked:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#bddad5\\\" stroke-width=\\\"3\\\"/><path fill=\\\"#5dc2af\\\" d=\\\"M72 25L42 71 27 56l-4 4 20 20 34-52z\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li label{word-break:break-all;padding:15px 60px 15px 15px;margin-left:45px;display:block;line-height:1.2;transition:color .4s}._1p_AB3iiKNbxBsOlJi5CVw li._29S5oJEhfUYjuw83RXIvg0 label{color:#d9d9d9;text-decoration:line-through}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE{display:none;position:absolute;top:0;right:10px;bottom:0;width:40px;height:40px;margin:auto 0;font-size:30px;color:#cc9a9a;margin-bottom:11px;transition:color .2s ease-out}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:hover{color:#af5b5e}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:after{content:'\\\\D7'}._1p_AB3iiKNbxBsOlJi5CVw li:hover ._3dDZq0iA7OOgE8KkLYlAeE{display:block}._1p_AB3iiKNbxBsOlJi5CVw li ._3RmQY0IMcqwS7R81Tj0dlC{display:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm:last-child{margin-bottom:-1px}.OfZp78rLkg_PWvZV9RYDG{color:#777;padding:10px 15px;height:20px;text-align:center;border-top:1px solid #e6e6e6}.OfZp78rLkg_PWvZV9RYDG:before{content:'';position:absolute;right:0;bottom:0;left:0;height:50px;overflow:hidden;box-shadow:0 1px 1px rgba(0,0,0,.2),0 8px 0 -3px #f6f6f6,0 9px 1px -3px rgba(0,0,0,.2),0 16px 0 -6px #f6f6f6,0 17px 2px -6px rgba(0,0,0,.2)}._1r5RuM5EHD-zS8b-wG0XPc{float:left;text-align:left}._1r5RuM5EHD-zS8b-wG0XPc strong{font-weight:300}._2tY47NKf597SqoScbkboy0{margin:0;padding:0;list-style:none;position:absolute;right:0;left:0}._2tY47NKf597SqoScbkboy0 li{display:inline}._2tY47NKf597SqoScbkboy0 li a{color:inherit;margin:3px;padding:3px 7px;text-decoration:none;border:1px solid transparent;border-radius:3px}._2tY47NKf597SqoScbkboy0 li a:hover{border-color:rgba(175,47,47,.1)}._2tY47NKf597SqoScbkboy0 li a.a8u8grJpMWz2FTlLtocrT{border-color:rgba(175,47,47,.2)}._1uOFz1y8zCB-ylF3BS8V7J,html ._1uOFz1y8zCB-ylF3BS8V7J:active{float:right;position:relative;line-height:20px;text-decoration:none;cursor:pointer}._1uOFz1y8zCB-ylF3BS8V7J:hover{text-decoration:underline}._3qrb6fjG3vwl0RExKf3l_q{margin:65px auto 0;color:#bfbfbf;font-size:10px;text-shadow:0 1px 0 hsla(0,0%,100%,.5);text-align:center}._3qrb6fjG3vwl0RExKf3l_q p{line-height:1}._3qrb6fjG3vwl0RExKf3l_q a{color:inherit;text-decoration:none;font-weight:400}._3qrb6fjG3vwl0RExKf3l_q a:hover{text-decoration:underline}@media screen and (-webkit-min-device-pixel-ratio:0){._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5,.DG0VaCEN4BXUysJd_tTIb{background:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{height:40px}.DG0VaCEN4BXUysJd_tTIb{-webkit-transform:rotate(90deg);transform:rotate(90deg);-webkit-appearance:none;appearance:none}}@media (max-width:430px){.OfZp78rLkg_PWvZV9RYDG{height:50px}._2tY47NKf597SqoScbkboy0{bottom:10px}}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\t\"new-todo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\t\"newTodo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\t\"toggle-all\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\t\"toggleAll\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\t\"todo-list\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\t\"todoList\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\t\"todo-count\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\t\"todoCount\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\t\"clear-completed\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\t\"clearCompleted\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\",\n\t\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\"\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// dist/index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b68d83bff7e2a2e2505a","/** @jsx h */\n\nimport 'skatejs-web-components';\nimport { Component, h, link, prop } from 'skatejs';\nimport css, { classes } from './style';\n\nconst { customElements } = window;\n\nfunction getCompleted (todos) {\n  return todos.filter(todo => todo.isCompleted);\n}\n\nfunction getPlural (count) {\n  return count === 1 ? '' : 's';\n}\n\nfunction getTodoMode (todo) {\n  if (todo.isEditing) {\n    return classes.editing;\n  }\n\n  if (todo.isCompleted) {\n    return classes.completed;\n  }\n\n  return '';\n}\n\nclass TodoApp extends Component {\n  static props = {\n    currentValue: prop.string(),\n    todos: prop.array()\n  }\n  handleChange = (e) => {\n    const { todos } = this;\n    const { target, target: { checked }} = e;\n    const todoIndex = parseFloat(target.getAttribute('data-todo-index'));\n    this.todos = todos.map((todo, currentTodoIndex) => {\n      if (currentTodoIndex === todoIndex) {\n        todo.isCompleted = checked;\n      }\n      return todo;\n    });\n  }\n  handleClear = () => {\n    this.todos = this.todos.filter(todo => !todo.isCompleted);\n  }\n  handleRemove = (e) => {\n    const todoIndex = parseFloat(e.target.getAttribute('data-todo-index'));\n    e.preventDefault();\n    this.todos = this.todos.filter((todo, currentTodoIndex) => currentTodoIndex !== todoIndex);\n  }\n  handleSubmit = (e) => {\n    e.preventDefault();\n    this.todos = this.todos.concat({\n      isCompleted: false,\n      isEditing: false,\n      description: this.currentValue\n    });\n    this.currentValue = '';\n  }\n  handleToggle = (e) => {\n    const { target: { checked } } = e;\n    this.todos = this.todos.map(todo => {\n      todo.isCompleted = checked;\n      return todo;\n    });\n  }\n  renderCallback () {\n    const {\n      currentValue,\n      handleChange,\n      handleClear,\n      handleRemove,\n      handleToggle,\n      handleSubmit,\n      todos\n    } = this;\n    const { length: todosLength } = todos;\n    const { length: todosCompletedLength } = getCompleted(todos);\n    const incompleteTodosLength = todosLength - todosCompletedLength;\n\n    return [\n      <style>{css}</style>,\n      <section class={classes.todoapp}>\n        <header class={classes.header}>\n          <h1>todos</h1>\n          <form onSubmit={handleSubmit}>\n            <input\n              autofocus\n              class={classes.newTodo}\n              name=\"currentValue\"\n              onKeyup={link(this)}\n              placeholder='What needs to be done?'\n              value={currentValue}\n            />\n          </form>\n        </header>\n\n        {todosLength ? (\n          <section class={classes.main}>\n            <input\n              class={classes.toggleAll} type='checkbox'\n              onChange={handleToggle}\n            />\n            <label for='toggle-all'>Mark all as complete</label>\n            <ul class={classes.todoList}>\n              {todos.map((todo, todoIndex) => (\n                <li class={getTodoMode(todo)}>\n                  <div class={classes.view}>\n                    <input\n                      class={classes.toggle}\n                      checked={todo.isCompleted}\n                      data-todo-index={todoIndex}\n                      onChange={handleChange}\n                      type='checkbox'\n                    />\n                    <label>{todo.description}</label>\n                    <button\n                      class={classes.destroy}\n                      data-todo-index={todoIndex}\n                      onClick={handleRemove}\n                    />\n                  </div>\n                  <input class={classes.edit} value='Create a TodoMVC template' />\n                </li>\n              ))}\n            </ul>\n          </section>\n        ) : ''}\n\n        {todosLength ? (\n          <footer class={classes.footer}>\n            <span class={classes.todoCount}>\n              <strong>{incompleteTodosLength}</strong>\n              {` item${getPlural(incompleteTodosLength)} left`}\n            </span>\n\n            {/*\n              Remove this if you don't implement routing\n              TODO should we anyways?\n              <ul class={classes.filters}>\n                <li>\n                  <a class={classes.selected} href='#/'>All</a>\n                </li>\n                <li>\n                  <a href='#/active'>Active</a>\n                </li>\n                <li>\n                  <a href='#/completed'>Completed</a>\n                </li>\n              </ul>\n            */}\n\n            {todosCompletedLength ? (\n              <button\n                class={classes.clearCompleted}\n                onClick={handleClear}\n              >Clear completed</button>\n            ) : ''}\n          </footer>\n        ) : ''}\n      </section>,\n      <footer class={classes.info}>\n        <p>Double-click to edit a todo</p>\n        <p>Created by the <a href='https://github.com/skatejs/skatejs'>SkateJS Team</a></p>\n        <p>Part of <a href='http://todomvc.com'>TodoMVC</a></p>\n      </footer>\n    ];\n  }\n}\n\ncustomElements.define('todo-app', TodoApp);\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsWebComponents\"] = factory();\n\telse\n\t\troot[\"skatejsWebComponents\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// We load the Safari fix first because the custom element polyfill overrides\n\t// attachShadow() to observe the shadow root.\n\t__webpack_require__(1);\n\t\n\t// We have to include this first so that it can patch native.\n\t__webpack_require__(2);\n\t\n\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t// ShadyDOM polyfill be loaded first.\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _window = window,\n\t    HTMLElement = _window.HTMLElement,\n\t    MutationObserver = _window.MutationObserver,\n\t    navigator = _window.navigator;\n\tvar userAgent = navigator.userAgent;\n\t\n\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\tvar safariVersions = [0, 1].map(function (v) {\n\t  return '10.0.' + v;\n\t}).concat(['10.0']);\n\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\n\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\tfunction fixSafari() {\n\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\n\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t  // element as this is the only scenario where styles aren't recalculated.\n\t  var moOpts = { childList: true, subtree: true };\n\t  var mo = new MutationObserver(function (muts) {\n\t    muts.forEach(function (mut) {\n\t      var target = mut.target;\n\t\n\t      if (target.tagName === 'STYLE') {\n\t        var nextSibling = target.nextSibling,\n\t            parentNode = target.parentNode;\n\t\n\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t        // as it seems that doesn't trigger a recalc.\n\t\n\t        parentNode.removeChild(target);\n\t        parentNode.insertBefore(target, nextSibling);\n\t      }\n\t    });\n\t  });\n\t\n\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t  function newAttachShadow(opts) {\n\t    var sr = oldAttachShadow.call(this, opts);\n\t    mo.observe(sr, moOpts);\n\t    return sr;\n\t  }\n\t\n\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t    // Ensure polyfills can override it (hoping they call it back).\n\t    configurable: true,\n\t    enumerable: true,\n\t    value: newAttachShadow,\n\t    writable: true\n\t  });\n\t}\n\t\n\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t// fixes the bug.\n\tif (patch) {\n\t  fixSafari();\n\t}\n\t\n\texports.default = patch;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t Code distributed by Google as part of the polymer project is also\n\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\n\t//# sourceMappingURL=custom-elements.min.js.map\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar settings = window.ShadyDOM || {};\n\t\n\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\n\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\n\tfunction isShadyRoot(obj) {\n\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t}\n\t\n\tvar p = Element.prototype;\n\tvar matches = p.matches || p.matchesSelector ||\n\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tfunction matchesSelector(element, selector) {\n\t  return matches.call(element, selector);\n\t}\n\t\n\tfunction copyOwnProperty(name, source, target) {\n\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t  if (pd) {\n\t    Object.defineProperty(target, name, pd);\n\t  }\n\t}\n\t\n\tfunction extend(target, source) {\n\t  if (target && source) {\n\t    var n$ = Object.getOwnPropertyNames(source);\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t      copyOwnProperty(n, source, target);\n\t    }\n\t  }\n\t  return target || source;\n\t}\n\t\n\tfunction extendAll(target) {\n\t  var sources = [], len = arguments.length - 1;\n\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  for (var i=0; i < sources.length; i++) {\n\t    extend(target, sources[i]);\n\t  }\n\t  return target;\n\t}\n\t\n\tfunction mixin(target, source) {\n\t  for (var i in source) {\n\t    target[i] = source[i];\n\t  }\n\t  return target;\n\t}\n\t\n\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t  obj.__proto__ = proto;\n\t  return obj;\n\t}\n\t\n\tfunction patchPrototype(obj, mixin) {\n\t  var proto = Object.getPrototypeOf(obj);\n\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t    var patchProto = Object.create(proto);\n\t    patchProto.__sourceProto = proto;\n\t    extend(patchProto, mixin);\n\t    proto.__patchProto = patchProto;\n\t  }\n\t  setPrototypeOf(obj, proto.__patchProto);\n\t}\n\t\n\t\n\t\n\tvar common = {};\n\t\n\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\tvar promish;\n\tif (window.Promise) {\n\t  promish = Promise.resolve();\n\t} else {\n\t  promish = {\n\t    then: function(cb) {\n\t      var twiddle = document.createTextNode('');\n\t      var observer = new MutationObserver(function() {\n\t        observer.disconnect();\n\t        cb();\n\t      });\n\t      observer.observe(twiddle, {characterData: true});\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction newSplice(index, removed, addedCount) {\n\t  return {\n\t    index: index,\n\t    removed: removed,\n\t    addedCount: addedCount\n\t  };\n\t}\n\t\n\tvar EDIT_LEAVE = 0;\n\tvar EDIT_UPDATE = 1;\n\tvar EDIT_ADD = 2;\n\tvar EDIT_DELETE = 3;\n\t\n\tvar ArraySplice = {\n\t\n\t  // Note: This function is *based* on the computation of the Levenshtein\n\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t  // edits - not one. With Array splices, an update is really a delete\n\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t  // maximum array items in the original array. For example:\n\t  //\n\t  //   'xxxx123' -> '123yyyy'\n\t  //\n\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t  // leaves the substring '123' intact.\n\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t                              old, oldStart, oldEnd) {\n\t    var this$1 = this;\n\t\n\t    // \"Deletion\" columns\n\t    var rowCount = oldEnd - oldStart + 1;\n\t    var columnCount = currentEnd - currentStart + 1;\n\t    var distances = new Array(rowCount);\n\t\n\t    // \"Addition\" rows. Initialize null column.\n\t    for (var i = 0; i < rowCount; i++) {\n\t      distances[i] = new Array(columnCount);\n\t      distances[i][0] = i;\n\t    }\n\t\n\t    // Initialize null row\n\t    for (var j = 0; j < columnCount; j++)\n\t      distances[0][j] = j;\n\t\n\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t        else {\n\t          var north = distances[i$1 - 1][j$1] + 1;\n\t          var west = distances[i$1][j$1 - 1] + 1;\n\t          distances[i$1][j$1] = north < west ? north : west;\n\t        }\n\t      }\n\t    }\n\t\n\t    return distances;\n\t  },\n\t\n\t  // This starts at the final weight, and walks \"backward\" by finding\n\t  // the minimum previous weight recursively until the origin of the weight\n\t  // matrix.\n\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t    var i = distances.length - 1;\n\t    var j = distances[0].length - 1;\n\t    var current = distances[i][j];\n\t    var edits = [];\n\t    while (i > 0 || j > 0) {\n\t      if (i == 0) {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        continue;\n\t      }\n\t      if (j == 0) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        continue;\n\t      }\n\t      var northWest = distances[i - 1][j - 1];\n\t      var west = distances[i - 1][j];\n\t      var north = distances[i][j - 1];\n\t\n\t      var min;\n\t      if (west < north)\n\t        min = west < northWest ? west : northWest;\n\t      else\n\t        min = north < northWest ? north : northWest;\n\t\n\t      if (min == northWest) {\n\t        if (northWest == current) {\n\t          edits.push(EDIT_LEAVE);\n\t        } else {\n\t          edits.push(EDIT_UPDATE);\n\t          current = northWest;\n\t        }\n\t        i--;\n\t        j--;\n\t      } else if (min == west) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        current = west;\n\t      } else {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        current = north;\n\t      }\n\t    }\n\t\n\t    edits.reverse();\n\t    return edits;\n\t  },\n\t\n\t  /**\n\t   * Splice Projection functions:\n\t   *\n\t   * A splice map is a representation of how a previous array of items\n\t   * was transformed into a new array of items. Conceptually it is a list of\n\t   * tuples of\n\t   *\n\t   *   <index, removed, addedCount>\n\t   *\n\t   * which are kept in ascending index order of. The tuple represents that at\n\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t   * from |index|, |addedCount| items were added.\n\t   */\n\t\n\t  /**\n\t   * Lacking individual splice mutation information, the minimal set of\n\t   * splices can be synthesized given the previous state and final state of an\n\t   * array. The basic approach is to calculate the edit distance matrix and\n\t   * choose the shortest path through it.\n\t   *\n\t   * Complexity: O(l * p)\n\t   *   l: The length of the current array\n\t   *   p: The length of the old array\n\t   */\n\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t                        old, oldStart, oldEnd) {\n\t    var prefixCount = 0;\n\t    var suffixCount = 0;\n\t    var splice;\n\t\n\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t    if (currentStart == 0 && oldStart == 0)\n\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\n\t    if (currentEnd == current.length && oldEnd == old.length)\n\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\n\t    currentStart += prefixCount;\n\t    oldStart += prefixCount;\n\t    currentEnd -= suffixCount;\n\t    oldEnd -= suffixCount;\n\t\n\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t      return [];\n\t\n\t    if (currentStart == currentEnd) {\n\t      splice = newSplice(currentStart, [], 0);\n\t      while (oldStart < oldEnd)\n\t        splice.removed.push(old[oldStart++]);\n\t\n\t      return [ splice ];\n\t    } else if (oldStart == oldEnd)\n\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\n\t    var ops = this.spliceOperationsFromEditDistances(\n\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t                               old, oldStart, oldEnd));\n\t\n\t    splice = undefined;\n\t    var splices = [];\n\t    var index = currentStart;\n\t    var oldIndex = oldStart;\n\t    for (var i = 0; i < ops.length; i++) {\n\t      switch(ops[i]) {\n\t        case EDIT_LEAVE:\n\t          if (splice) {\n\t            splices.push(splice);\n\t            splice = undefined;\n\t          }\n\t\n\t          index++;\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_UPDATE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_ADD:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t          break;\n\t        case EDIT_DELETE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (splice) {\n\t      splices.push(splice);\n\t    }\n\t    return splices;\n\t  },\n\t\n\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t    var this$1 = this;\n\t\n\t    for (var i = 0; i < searchLength; i++)\n\t      if (!this$1.equals(current[i], old[i]))\n\t        return i;\n\t    return searchLength;\n\t  },\n\t\n\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t    var index1 = current.length;\n\t    var index2 = old.length;\n\t    var count = 0;\n\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t      count++;\n\t\n\t    return count;\n\t  },\n\t\n\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t                            previous.length);\n\t  },\n\t\n\t  equals: function equals(currentValue, previousValue) {\n\t    return currentValue === previousValue;\n\t  }\n\t\n\t};\n\t\n\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t// for now this is stuck on `utils`\n\t//import {patchNode} from './patch'\n\t// native add/remove\n\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\tvar nativeAppendChild = Element.prototype.appendChild;\n\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\n\t/**\n\t * `tree` is a dom manipulation library used by ShadyDom to\n\t * manipulate composed and logical trees.\n\t */\n\tvar tree = {\n\t\n\t  // sad but faster than slice...\n\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopy: function arrayCopy(a$) {\n\t    var l = a$.length;\n\t    var copy = new Array(l);\n\t    for (var i=0; i < l; i++) {\n\t      copy[i] = a$[i];\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes(node) {\n\t    tree.Logical.saveChildNodes(node);\n\t    if (!tree.Composed.hasParentNode(node)) {\n\t      tree.Composed.saveComposedData(node);\n\t      //tree.Composed.saveParentNode(node);\n\t    }\n\t    tree.Composed.saveChildNodes(node);\n\t  }\n\t\n\t};\n\t\n\ttree.Logical = {\n\t\n\t  hasParentNode: function hasParentNode(node) {\n\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes(node) {\n\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes(node) {\n\t    // note: we're distinguishing here between undefined and false-y:\n\t    // hasChildNodes uses undefined check to see if this element has logical\n\t    // children; the false-y check indicates whether or not we should rebuild\n\t    // the cached childNodes array.\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      tree.Composed.getChildNodes(node);\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes(node) {\n\t    if (!node.__dom.childNodes) {\n\t      node.__dom.childNodes = [];\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        node.__dom.childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.childNodes;\n\t  },\n\t\n\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t  // element will store firstChild/lastChild, and in case (2), the element\n\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t  // the mere existence of __dom is not enough to know if the requested\n\t  // logical data is available and instead we do an explicit undefined check.\n\t  getParentNode: function getParentNode(node) {\n\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t  },\n\t\n\t  getLastChild: function getLastChild(node) {\n\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t  },\n\t\n\t  getNextSibling: function getNextSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      this._getFirstElementChild(node) :\n\t      tree.Composed.getFirstElementChild(node);\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t    var n = node.__dom.firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild(node) {\n\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t      this._getLastElementChild(node) :\n\t      tree.Composed.getLastElementChild(node);\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild(node) {\n\t    var n = node.__dom.lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t      this._getNextElementSibling(node) :\n\t      tree.Composed.getNextElementSibling(node);\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t      this._getPreviousElementSibling(node) :\n\t      tree.Composed.getPreviousElementSibling(node);\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  // Capture the list of light children. It's important to do this before we\n\t  // start transforming the DOM into \"rendered\" state.\n\t  // Children may be added to this list dynamically. It will be treated as the\n\t  // source of truth for the light children of the element. This element's\n\t  // actual children will be treated as the rendered state once this function\n\t  // has been called.\n\t  saveChildNodes: function saveChildNodes$1(node) {\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.firstChild;\n\t      node.__dom.lastChild = node.lastChild;\n\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        n.__dom = n.__dom || {};\n\t        n.__dom.parentNode = node;\n\t        n.__dom.nextSibling = c$[i+1] || null;\n\t        n.__dom.previousSibling = c$[i-1] || null;\n\t        common.patchNode(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t  // already been distributed.\n\t  // NOTE: ensure `node` is patched...\n\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var c$ = tree.arrayCopyChildNodes(node);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1._linkNode(c$[i], container, ref_node);\n\t      }\n\t      // cleanup logical dom in doc fragment.\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t      node.__dom.childNodes = null;\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t    common.patchNode(node);\n\t    ref_node = ref_node || null;\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t      container.__dom.lastChild;\n\t    if (node.__dom.previousSibling) {\n\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.nextSibling = ref_node;\n\t    if (node.__dom.nextSibling) {\n\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.lastChild = node;\n\t      if (!container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.firstChild) {\n\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t    }\n\t    if (node === container.__dom.lastChild) {\n\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t    }\n\t    var p = node.__dom.previousSibling;\n\t    var n = node.__dom.nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.previousSibling = p;\n\t    }\n\t    // When an element is removed, logical data is no longer tracked.\n\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t    // from `null` which is set if info is null.\n\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t      node.__dom.nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  }\n\t\n\t}\n\t\n\t\n\t// TODO(sorvell): composed tree manipulation is made available\n\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t// to the tree for optional patching pluggability.\n\ttree.Composed = {\n\t\n\t  hasParentNode: function hasParentNode$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes$1(node) {\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes$1(node) {\n\t    if (!node.__dom.$childNodes) {\n\t      node.__dom.$childNodes = [];\n\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t        node.__dom.$childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getParentNode: function getParentNode$1(node) {\n\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t      (!node.__patched && node.parentNode);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild$1(node) {\n\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t  },\n\t\n\t  getLastChild: function getLastChild$1(node) {\n\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t  },\n\t\n\t  getNextSibling: function getNextSibling$1(node) {\n\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t    return node.__patched ? this._getFirstElementChild(node) :\n\t      node.firstElementChild;\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t    var n = node.__dom.$firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild$1(node) {\n\t    return node.__patched ? this._getLastElementChild(node) :\n\t      node.lastElementChild;\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t    var n = node.__dom.$lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t    return node.__patched ? this._getNextElementSibling(node) :\n\t      node.nextElementSibling;\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t      node.previousElementSibling;\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes$2(node) {\n\t    var this$1 = this;\n\t\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.$firstChild = node.firstChild;\n\t      node.__dom.$lastChild = node.lastChild;\n\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        this$1.saveComposedData(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  saveComposedData: function saveComposedData(node) {\n\t    node.__dom = node.__dom || {};\n\t    if (node.__dom.$parentNode === undefined) {\n\t      node.__dom.$parentNode = node.parentNode;\n\t    }\n\t    if (node.__dom.$nextSibling === undefined) {\n\t      node.__dom.$nextSibling = node.nextSibling;\n\t    }\n\t    if (node.__dom.$previousSibling === undefined) {\n\t      node.__dom.$previousSibling = node.previousSibling;\n\t    }\n\t  },\n\t\n\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.$childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      // TODO(sorvell): remember this for patching:\n\t      // the act of setting this info can affect patched nodes\n\t      // getters; therefore capture childNodes before patching.\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        this$1._linkNode(n, container, ref_node);\n\t      }\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t      container.__dom.$lastChild;\n\t    if (node.__dom.$previousSibling) {\n\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.$nextSibling = ref_node;\n\t    if (node.__dom.$nextSibling) {\n\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.$parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.$lastChild = node;\n\t      if (!container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.$firstChild) {\n\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t    }\n\t    if (node === container.__dom.$lastChild) {\n\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t    }\n\t    var p = node.__dom.$previousSibling;\n\t    var n = node.__dom.$nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.$nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.$previousSibling = p;\n\t    }\n\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t      node.__dom.$nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  clearChildNodes: function clearChildNodes(node) {\n\t    var this$1 = this;\n\t\n\t    var c$ = this.getChildNodes(node);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      this$1.recordRemoveChild(c, node);\n\t      nativeRemoveChild.call(node, c)\n\t    }\n\t  },\n\t\n\t  saveParentNode: function saveParentNode(node) {\n\t    node.__dom = node.__dom || {};\n\t    node.__dom.$parentNode = node.parentNode;\n\t  },\n\t\n\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t    this.saveChildNodes(parentNode);\n\t    // remove from current location.\n\t    this._addChild(parentNode, newChild, refChild);\n\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t  },\n\t\n\t  appendChild: function appendChild(parentNode, newChild) {\n\t    this.saveChildNodes(parentNode);\n\t    this._addChild(parentNode, newChild);\n\t    return nativeAppendChild.call(parentNode, newChild);\n\t  },\n\t\n\t  removeChild: function removeChild(parentNode, node) {\n\t    var currentParent = this.getParentNode(node);\n\t    this.saveChildNodes(parentNode);\n\t    this._removeChild(parentNode, node);\n\t    if (currentParent === parentNode) {\n\t      return nativeRemoveChild.call(parentNode, node);\n\t    }\n\t  },\n\t\n\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t    var this$1 = this;\n\t\n\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t    var oldParent = this.getParentNode(newChild);\n\t    if (oldParent) {\n\t      this._removeChild(oldParent, newChild);\n\t    }\n\t    if (isFrag) {\n\t      var c$ = this.getChildNodes(newChild);\n\t      for (var i=0; i < c$.length; i++) {\n\t        var c = c$[i];\n\t        // unlink document fragment children\n\t        this$1._removeChild(newChild, c);\n\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t      }\n\t    } else {\n\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t    }\n\t  },\n\t\n\t  _removeChild: function _removeChild(parentNode, node) {\n\t    this.recordRemoveChild(node, parentNode);\n\t  }\n\t\n\t};\n\t\n\t// for testing...\n\tvar descriptors = {};\n\tfunction getNativeProperty(element, property) {\n\t  if (!descriptors[property]) {\n\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t      HTMLElement.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Element.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Node.prototype, property);\n\t  }\n\t  return descriptors[property].get.call(element);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// NOTE: normalize event contruction where necessary (IE11)\n\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t  function(inType, params) {\n\t    params = params || {};\n\t    var e = document.createEvent('Event');\n\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t    return e;\n\t  };\n\t\n\tvar Distributor = (function () {\n\t  function anonymous(root) {\n\t    this.root = root;\n\t    this.insertionPointTag = 'slot';\n\t  }\n\t\n\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t  };\n\t\n\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t    return Boolean(this.root._insertionPoints &&\n\t      this.root._insertionPoints.length);\n\t  };\n\t\n\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t    return node.localName && node.localName == this.insertionPointTag;\n\t  };\n\t\n\t  anonymous.prototype.distribute = function distribute () {\n\t    if (this.hasInsertionPoint()) {\n\t      return this.distributePool(this.root, this.collectPool());\n\t    }\n\t    return [];\n\t  };\n\t\n\t  // Gather the pool of nodes that should be distributed. We will combine\n\t  // these with the \"content root\" to arrive at the composed tree.\n\t  anonymous.prototype.collectPool = function collectPool () {\n\t    return tree.arrayCopy(\n\t      tree.Logical.getChildNodes(this.root.host));\n\t  };\n\t\n\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t  // instead elements are distributed into storage\n\t  // array where applicable.\n\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t    var this$1 = this;\n\t\n\t    var dirtyRoots = [];\n\t    var p$ = this.root._insertionPoints;\n\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t      this$1.distributeInsertionPoint(p, pool);\n\t      // provoke redistribution on insertion point parents\n\t      // must do this on all candidate hosts since distribution in this\n\t      // scope invalidates their distribution.\n\t      // only get logical parent.\n\t      var parent = tree.Logical.getParentNode(p);\n\t      if (parent && parent.shadyRoot &&\n\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t        dirtyRoots.push(parent.shadyRoot);\n\t      }\n\t    }\n\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t      var p$1 = pool[i$1];\n\t      if (p$1) {\n\t        p$1._assignedSlot = undefined;\n\t        // remove undistributed elements from physical dom.\n\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t        if (parent$1) {\n\t          tree.Composed.removeChild(parent$1, p$1);\n\t        }\n\t      }\n\t    }\n\t    return dirtyRoots;\n\t  };\n\t\n\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t    var this$1 = this;\n\t\n\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t    if (prevAssignedNodes) {\n\t      this.clearAssignedSlots(insertionPoint, true);\n\t    }\n\t    insertionPoint._assignedNodes = [];\n\t    var needsSlotChange = false;\n\t    // distribute nodes from the pool that this selector matches\n\t    var anyDistributed = false;\n\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t      node=pool[i];\n\t      // skip nodes that were already used\n\t      if (!node) {\n\t        continue;\n\t      }\n\t      // distribute this node if it matches\n\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node, insertionPoint)\n\t        // remove this node from the pool\n\t        pool[i] = undefined;\n\t        // since at least one node matched, we won't need fallback content\n\t        anyDistributed = true;\n\t      }\n\t    }\n\t    // Fallback content if nothing was distributed here\n\t    if (!anyDistributed) {\n\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t      for (var j = 0, node$1; j < children.length; j++) {\n\t        node$1 = children[j];\n\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t      }\n\t    }\n\t    // we're already dirty if a node was newly added to the slot\n\t    // and we're also dirty if the assigned count decreased.\n\t    if (prevAssignedNodes) {\n\t      // TODO(sorvell): the tracking of previously assigned slots\n\t      // could instead by done with a Set and then we could\n\t      // avoid needing to iterate here to clear the info.\n\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t      }\n\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t        needsSlotChange = true;\n\t      }\n\t    }\n\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t    if (needsSlotChange) {\n\t      this._fireSlotChange(insertionPoint);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t    var n$ = slot._assignedNodes;\n\t    if (n$) {\n\t      for (var i=0; i < n$.length; i++) {\n\t        var n = n$[i];\n\t        if (savePrevious) {\n\t          n.__prevAssignedSlot = n._assignedSlot;\n\t        }\n\t        // only clear if it was previously set to this slot;\n\t        // this helps ensure that if the node has otherwise been distributed\n\t        // ignore it.\n\t        if (n._assignedSlot === slot) {\n\t          n._assignedSlot = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t    var slotName = insertionPoint.getAttribute('name');\n\t    slotName = slotName ? slotName.trim() : '';\n\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t    slot = slot ? slot.trim() : '';\n\t    return (slot == slotName);\n\t  };\n\t\n\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t    insertionPoint._assignedNodes.push(child);\n\t    child._assignedSlot = insertionPoint;\n\t  };\n\t\n\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t    var this$1 = this;\n\t\n\t    var n$ = insertionPoint._assignedNodes;\n\t    insertionPoint._distributedNodes = [];\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t      if (this$1.isInsertionPoint(n)) {\n\t        var d$ = n._distributedNodes;\n\t        if (d$) {\n\t          for (var j=0; j < d$.length; j++) {\n\t            insertionPoint._distributedNodes.push(d$[j]);\n\t          }\n\t        }\n\t      } else {\n\t        insertionPoint._distributedNodes.push(n$[i]);\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t    // Safari tech preview does not bubble but chrome does\n\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t    if (insertionPoint._assignedSlot) {\n\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t    return !(insertionPoint._assignedSlot);\n\t  };\n\t\n\t  return anonymous;\n\t}())\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t  polyfill across browsers.\n\t*/\n\tvar ShadyRoot = function ShadyRoot(host) {\n\t  if (!host) {\n\t    throw 'Must provide a host';\n\t  }\n\t  // NOTE: this strange construction is necessary because\n\t  // DocumentFragment cannot be subclassed on older browsers.\n\t  var frag = document.createDocumentFragment();\n\t  frag.__proto__ = ShadyFragmentMixin;\n\t  frag._init(host);\n\t  return frag;\n\t};\n\t\n\tvar ShadyMixin = {\n\t\n\t  _init: function _init(host) {\n\t    // NOTE: set a fake local name so this element can be\n\t    // distinguished from a DocumentFragment when patching.\n\t    // FF doesn't allow this to be `localName`\n\t    this.__localName = 'ShadyRoot';\n\t    // root <=> host\n\t    host.shadyRoot = this;\n\t    this.host = host;\n\t    // logical dom setup\n\t    tree.Logical.saveChildNodes(host);\n\t    tree.Logical.saveChildNodes(this);\n\t    // state flags\n\t    this._clean = true;\n\t    this._hasRendered = false;\n\t    this._distributor = new Distributor(this);\n\t    this.update();\n\t  },\n\t\n\t  // async render the \"top\" distributor (this is all that is needed to\n\t  // distribute this host).\n\t  update: function update() {\n\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t    if (distributionRoot._clean) {\n\t      distributionRoot._clean = false;\n\t      enqueue(function() {\n\t        distributionRoot.render();\n\t      });\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t  // this should only return a shadowRoot.\n\t  // returns the host that's the top of this host's distribution tree\n\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t    var root = element.shadyRoot;\n\t    while (element && this._elementNeedsDistribution(element)) {\n\t      root = element.getRootNode();\n\t      element = root && root.host;\n\t    }\n\t    return root;\n\t  },\n\t\n\t  // Return true if a host's children includes\n\t  // an insertion point that selects selectively\n\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t    var this$1 = this;\n\t\n\t    var c$ = tree.Logical.getChildNodes(element);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t        return element.getRootNode();\n\t      }\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    if (!this._clean) {\n\t      this._clean = true;\n\t      if (!this._skipUpdateInsertionPoints) {\n\t        this.updateInsertionPoints();\n\t      } else if (!this._hasRendered) {\n\t        this._insertionPoints = [];\n\t      }\n\t      this._skipUpdateInsertionPoints = false;\n\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t      // that would avoid distribution for initial render if\n\t      // no insertion points exist. We cannot currently do this because\n\t      // it relies on elements being in the physical shadowRoot element\n\t      // so that native methods will be used. The current append code\n\t      // simply provokes distribution in this case and does not put the\n\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t      // consider if the special processing is worth the perf gain.\n\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t      //   tree.Composed.clearChildNodes(this.host);\n\t      //   tree.Composed.appendChild(this.host, this);\n\t      // } else {\n\t      // logical\n\t      this.distribute();\n\t      // physical\n\t      this.compose();\n\t      this._hasRendered = true;\n\t    }\n\t  },\n\t\n\t  forceRender: function forceRender() {\n\t    this._clean = false;\n\t    this.render();\n\t  },\n\t\n\t  distribute: function distribute() {\n\t    var dirtyRoots = this._distributor.distribute();\n\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t      dirtyRoots[i].forceRender();\n\t    }\n\t  },\n\t\n\t  updateInsertionPoints: function updateInsertionPoints() {\n\t    var this$1 = this;\n\t\n\t    var i$ = this.__insertionPoints;\n\t    // if any insertion points have been removed, clear their distribution info\n\t    if (i$) {\n\t      for (var i=0, c; i < i$.length; i++) {\n\t        c = i$[i];\n\t        if (c.getRootNode() !== this$1) {\n\t          this$1._distributor.clearAssignedSlots(c);\n\t        }\n\t      }\n\t    }\n\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t    // ensure insertionPoints's and their parents have logical dom info.\n\t    // save logical tree info\n\t    // a. for shadyRoot\n\t    // b. for insertion points (fallback)\n\t    // c. for parents of insertion points\n\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t      c$1 = i$[i$1];\n\t      tree.Logical.saveChildNodes(c$1);\n\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t    }\n\t  },\n\t\n\t  get _insertionPoints() {\n\t    if (!this.__insertionPoints) {\n\t      this.updateInsertionPoints();\n\t    }\n\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t  },\n\t\n\t  set _insertionPoints(insertionPoints) {\n\t    this.__insertionPoints = insertionPoints;\n\t  },\n\t\n\t  hasInsertionPoint: function hasInsertionPoint() {\n\t    return this._distributor.hasInsertionPoint();\n\t  },\n\t\n\t  compose: function compose() {\n\t    // compose self\n\t    // note: it's important to mark this clean before distribution\n\t    // so that attachment that provokes additional distribution (e.g.\n\t    // adding something to your parentNode) works\n\t    this._composeTree();\n\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t    // (these seem unnecessary)\n\t  },\n\t\n\t  // Reify dom such that it is at its correct rendering position\n\t  // based on logical distribution.\n\t  _composeTree: function _composeTree() {\n\t    var this$1 = this;\n\t\n\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t    var p$ = this._insertionPoints || [];\n\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t      parent = tree.Logical.getParentNode(p);\n\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t      }\n\t    }\n\t  },\n\t\n\t  // Returns the list of nodes which should be rendered inside `node`.\n\t  _composeNode: function _composeNode(node) {\n\t    var this$1 = this;\n\t\n\t    var children = [];\n\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t    for (var i = 0; i < c$.length; i++) {\n\t      var child = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t        var distributedNodes = child._distributedNodes ||\n\t          (child._distributedNodes = []);\n\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t          var distributedNode = distributedNodes[j];\n\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t            children.push(distributedNode);\n\t          }\n\t        }\n\t      } else {\n\t        children.push(child);\n\t      }\n\t    }\n\t    return children;\n\t  },\n\t\n\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t    return this._distributor.isFinalDestination(\n\t      insertionPoint, node);\n\t  },\n\t\n\t  // Ensures that the rendered node list inside `container` is `children`.\n\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t    var composed = tree.Composed.getChildNodes(container);\n\t    var splices = calculateSplices(children, composed);\n\t    // process removals\n\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t        // check if the node is still where we expect it is before trying\n\t        // to remove it; this can happen if we move a node and\n\t        // then schedule its previous host for distribution resulting in\n\t        // the node being removed here.\n\t        if (tree.Composed.getParentNode(n) === container) {\n\t          tree.Composed.removeChild(container, n);\n\t        }\n\t        composed.splice(s.index + d, 1);\n\t      }\n\t      d -= s.addedCount;\n\t    }\n\t    // process adds\n\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t      next = composed[s$1.index];\n\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t        n$1 = children[j$1];\n\t        tree.Composed.insertBefore(container, n$1, next);\n\t        // TODO(sorvell): is this splice strictly needed?\n\t        composed.splice(j$1, 0, n$1);\n\t      }\n\t    }\n\t  },\n\t\n\t  getInsertionPointTag: function getInsertionPointTag() {\n\t    return this._distributor.insertionPointTag;\n\t  }\n\t\n\t}\n\t\n\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\textend(ShadyFragmentMixin, ShadyMixin);\n\t\n\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\n\t// function upgradeLogicalChildren(children) {\n\t//   if (needsUpgrade && children) {\n\t//     for (let i=0; i < children.length; i++) {\n\t//       CustomElements.upgrade(children[i]);\n\t//     }\n\t//   }\n\t// }\n\t\n\t// render enqueuer/flusher\n\tvar customElements = window.customElements;\n\tvar flushList = [];\n\tvar scheduled;\n\tvar flushCount = 0;\n\tvar flushMax = 100;\n\tfunction enqueue(callback) {\n\t  if (!scheduled) {\n\t    scheduled = true;\n\t    promish.then(flush$1);\n\t  }\n\t  flushList.push(callback);\n\t}\n\t\n\tfunction flush$1() {\n\t  scheduled = false;\n\t  flushCount++;\n\t  while (flushList.length) {\n\t    flushList.shift()();\n\t  }\n\t  if (customElements && customElements.flush) {\n\t    customElements.flush();\n\t  }\n\t  // continue flushing after elements are upgraded...\n\t  var isFlushedMaxed = (flushCount > flushMax);\n\t  if (flushList.length && !isFlushedMaxed) {\n\t      flush$1();\n\t  }\n\t  flushCount = 0;\n\t  if (isFlushedMaxed) {\n\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t  }\n\t}\n\t\n\tflush$1.list = flushList;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// Cribbed from ShadowDOM polyfill\n\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t/////////////////////////////////////////////////////////////////////////////\n\t// innerHTML and outerHTML\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\n\tfunction escapeReplace(c) {\n\t  switch (c) {\n\t    case '&':\n\t      return '&amp;';\n\t    case '<':\n\t      return '&lt;';\n\t    case '>':\n\t      return '&gt;';\n\t    case '\"':\n\t      return '&quot;';\n\t    case '\\u00A0':\n\t      return '&nbsp;';\n\t  }\n\t}\n\t\n\tfunction escapeAttr(s) {\n\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t}\n\t\n\tfunction escapeData(s) {\n\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t}\n\t\n\tfunction makeSet(arr) {\n\t  var set = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    set[arr[i]] = true;\n\t  }\n\t  return set;\n\t}\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\tvar voidElements = makeSet([\n\t  'area',\n\t  'base',\n\t  'br',\n\t  'col',\n\t  'command',\n\t  'embed',\n\t  'hr',\n\t  'img',\n\t  'input',\n\t  'keygen',\n\t  'link',\n\t  'meta',\n\t  'param',\n\t  'source',\n\t  'track',\n\t  'wbr'\n\t]);\n\t\n\tvar plaintextParents = makeSet([\n\t  'style',\n\t  'script',\n\t  'xmp',\n\t  'iframe',\n\t  'noembed',\n\t  'noframes',\n\t  'plaintext',\n\t  'noscript'\n\t]);\n\t\n\tfunction getOuterHTML(node, parentNode, composed) {\n\t  switch (node.nodeType) {\n\t    case Node.ELEMENT_NODE: {\n\t      var tagName = node.localName;\n\t      var s = '<' + tagName;\n\t      var attrs = node.attributes;\n\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t      }\n\t      s += '>';\n\t      if (voidElements[tagName]) {\n\t        return s;\n\t      }\n\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t    }\n\t    case Node.TEXT_NODE: {\n\t      var data = node.data;\n\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t        return data;\n\t      }\n\t      return escapeData(data);\n\t    }\n\t    case Node.COMMENT_NODE: {\n\t      return '<!--' + node.data + '-->';\n\t    }\n\t    default: {\n\t      window.console.error(node);\n\t      throw new Error('not implemented');\n\t    }\n\t  }\n\t}\n\t\n\tfunction getInnerHTML(node, composed) {\n\t  if (node.localName === 'template') {\n\t    node = node.content;\n\t  }\n\t  var s = '';\n\t  var c$ = composed ? composed(node) : node.childNodes;\n\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t    s += getOuterHTML(child, node, composed);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar mixinImpl = {\n\t\n\t  // Try to add node. Record logical info, track insertion points, perform\n\t  // distribution iff needed. Return true if the add is handled.\n\t  addNode: function addNode(container, node, ref_node) {\n\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t    if (ownerRoot) {\n\t      // optimization: special insertion point tracking\n\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t      }\n\t      // note: we always need to see if an insertion point is added\n\t      // since this saves logical tree info; however, invalidation state\n\t      // needs\n\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t      // invalidate insertion points IFF not already invalid!\n\t      if (ipAdded) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t      }\n\t    }\n\t    if (tree.Logical.hasChildNodes(container)) {\n\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t    }\n\t    // if not distributing and not adding to host, do a fast path addition\n\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t      container.shadyRoot;\n\t    return handled;\n\t  },\n\t\n\t  // Try to remove node: update logical info and perform distribution iff\n\t  // needed. Return true if the removal has been handled.\n\t  // note that it's possible for both the node's host and its parent\n\t  // to require distribution... both cases are handled here.\n\t  removeNode: function removeNode(node) {\n\t    // important that we want to do this only if the node has a logical parent\n\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t      tree.Logical.getParentNode(node);\n\t    var distributed;\n\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t    if (logicalParent) {\n\t      // distribute node's parent iff needed\n\t      distributed = this.maybeDistributeParent(node);\n\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t      // remove node from root and distribute it iff needed\n\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    this._removeOwnerShadyRoot(node);\n\t    return distributed;\n\t  },\n\t\n\t\n\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t    var observer = node.__dom && node.__dom.observer;\n\t    if (observer) {\n\t      if (addedNode) {\n\t        observer.addedNodes.push(addedNode);\n\t      }\n\t      if (removedNode) {\n\t        observer.removedNodes.push(removedNode);\n\t      }\n\t      observer.schedule();\n\t    }\n\t  },\n\t\n\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t    if (parent) {\n\t      this._scheduleObserver(parent, null, node);\n\t      this.removeNode(node);\n\t    } else {\n\t      this._removeOwnerShadyRoot(node);\n\t    }\n\t  },\n\t\n\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t  },\n\t\n\t  getRootNode: function getRootNode$1(node) {\n\t    if (!node || !node.nodeType) {\n\t      return;\n\t    }\n\t    var root = node.__ownerShadyRoot;\n\t    if (root === undefined) {\n\t      if (isShadyRoot(node)) {\n\t        root = node;\n\t      } else {\n\t        var parent = tree.Logical.getParentNode(node);\n\t        root = parent ? this.getRootNode(parent) : node;\n\t      }\n\t      // memo-ize result for performance but only memo-ize\n\t      // result if node is in the document. This avoids a problem where a root\n\t      // can be cached while an element is inside a fragment.\n\t      // If this happens and we cache the result, the value can become stale\n\t      // because for perf we avoid processing the subtree of added fragments.\n\t      if (document.documentElement.contains(node)) {\n\t        node.__ownerShadyRoot = root;\n\t      }\n\t    }\n\t    return root;\n\t  },\n\t\n\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t    var root = this.getRootNode(node);\n\t    if (isShadyRoot(root)) {\n\t      return root;\n\t    }\n\t  },\n\t\n\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t    // <content> children but since this case is assumed to be exceedingly\n\t    // rare, we avoid the cost and will address with some specific api\n\t    // when the need arises.  For now, the user must call\n\t    // distributeContent(true), which updates insertion points manually\n\t    // and forces distribution.\n\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t      !node.__noInsertionPoint &&\n\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t    var wrappedContent = fragContent &&\n\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t    // There are 3 possible cases where a distribution may need to occur:\n\t    // 1. <content> being inserted (the host of the shady root where\n\t    //    content is inserted needs distribution)\n\t    // 2. children being inserted into parent with a shady root (parent\n\t    //    needs distribution)\n\t    // 3. container is an insertionPoint\n\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t      if (ownerRoot) {\n\t        // note, insertion point list update is handled after node\n\t        // mutations are complete\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    var needsDist = this._nodeNeedsDistribution(container);\n\t    if (needsDist) {\n\t      container.shadyRoot.update();\n\t    }\n\t    // Return true when distribution will fully handle the composition\n\t    // Note that if a content was being inserted that was wrapped by a node,\n\t    // and the parent does not need distribution, return false to allow\n\t    // the nodes to be added directly, after which children may be\n\t    // distributed and composed into the wrapping node(s)\n\t    return needsDist || (hasContent && !wrappedContent);\n\t  },\n\t\n\t  /* note: parent argument is required since node may have an out\n\t  of date parent at this point; returns true if a <content> is being added */\n\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t    var this$1 = this;\n\t\n\t    var added;\n\t    var insertionPointTag = root.getInsertionPointTag();\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t      !node.__noInsertionPoint) {\n\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t        np = tree.Logical.getParentNode(n);\n\t        // don't allow node's parent to be fragment itself\n\t        if (np === node) {\n\t          np = parent;\n\t        }\n\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t        added = added || na;\n\t      }\n\t    } else if (node.localName === insertionPointTag) {\n\t      tree.Logical.saveChildNodes(parent);\n\t      tree.Logical.saveChildNodes(node);\n\t      added = true;\n\t    }\n\t    return added;\n\t  },\n\t\n\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t    return node && node.shadyRoot &&\n\t      node.shadyRoot.hasInsertionPoint();\n\t  },\n\t\n\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t    var this$1 = this;\n\t\n\t    var hostNeedsDist;\n\t    var ip$ = root._insertionPoints;\n\t    for (var i=0; i<ip$.length; i++) {\n\t      var insertionPoint = ip$[i];\n\t      if (this$1._contains(container, insertionPoint)) {\n\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t        for (var j=0; j<dc$.length; j++) {\n\t          hostNeedsDist = true;\n\t          var node = dc$[j];\n\t          var parent = tree.Composed.getParentNode(node);\n\t          if (parent) {\n\t            tree.Composed.removeChild(parent, node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return hostNeedsDist;\n\t  },\n\t\n\t  _contains: function _contains(container, node) {\n\t    while (node) {\n\t      if (node == container) {\n\t        return true;\n\t      }\n\t      node = tree.Logical.getParentNode(node);\n\t    }\n\t  },\n\t\n\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t    var this$1 = this;\n\t\n\t    // optimization: only reset the tree if node is actually in a root\n\t    if (this._hasCachedOwnerRoot(node)) {\n\t      var c$ = tree.Logical.getChildNodes(node);\n\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t        this$1._removeOwnerShadyRoot(n);\n\t      }\n\t    }\n\t    node.__ownerShadyRoot = undefined;\n\t  },\n\t\n\t  // TODO(sorvell): This will fail if distribution that affects this\n\t  // question is pending; this is expected to be exceedingly rare, but if\n\t  // the issue comes up, we can force a flush in this case.\n\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t    var root = this.getRootNode(insertionPoint);\n\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t      // means that we're composed to this spot.\n\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t        return n;\n\t      }\n\t    }\n\t  },\n\t\n\t  clearNode: function clearNode(node) {\n\t    while (node.firstChild) {\n\t      node.removeChild(node.firstChild);\n\t    }\n\t  },\n\t\n\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t    var parent = tree.Logical.getParentNode(node);\n\t    if (this._nodeNeedsDistribution(parent)) {\n\t      parent.shadyRoot.update();\n\t      return true;\n\t    }\n\t  },\n\t\n\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t    if (name === 'slot') {\n\t      this.maybeDistributeParent(node);\n\t    } else if (node.localName === 'slot' && name === 'name') {\n\t      var root = this.ownerShadyRootForNode(node);\n\t      if (root) {\n\t        root.update();\n\t      }\n\t    }\n\t  },\n\t\n\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t  // but it's also generally useful to recurse through the element tree\n\t  // and is used by Polymer's styling system.\n\t  query: function query(node, matcher, halter) {\n\t    var list = [];\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t    return list;\n\t  },\n\t\n\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t    var this$1 = this;\n\t\n\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t          this$1._queryElement(c, matcher, halter, list)) {\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t    var result = matcher(node);\n\t    if (result) {\n\t      list.push(node);\n\t    }\n\t    if (halter && halter(result)) {\n\t      return result;\n\t    }\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t  },\n\t\n\t  activeElementForNode: function activeElementForNode(node) {\n\t    var this$1 = this;\n\t\n\t    var active = document.activeElement;\n\t    if (!active) {\n\t      return null;\n\t    }\n\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t    if (node !== document) {\n\t      // If this node isn't a document or shady root, then it doesn't have\n\t      // an active element.\n\t      if (!isShadyRoot$$1) {\n\t        return null;\n\t      }\n\t      // If this shady root's host is the active element or the active\n\t      // element is not a descendant of the host (in the composed tree),\n\t      // then it doesn't have an active element.\n\t      if (node.host === active ||\n\t          !node.host.contains(active)) {\n\t        return null;\n\t      }\n\t    }\n\t    // This node is either the document or a shady root of which the active\n\t    // element is a (composed) descendant of its host; iterate upwards to\n\t    // find the active element's most shallow host within it.\n\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t    while (activeRoot && activeRoot !== node) {\n\t      active = activeRoot.host;\n\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t    }\n\t    if (node === document) {\n\t      // This node is the document, so activeRoot should be null.\n\t      return activeRoot ? null : active;\n\t    } else {\n\t      // This node is a non-document shady root, and it should be\n\t      // activeRoot.\n\t      return activeRoot === node ? active : null;\n\t    }\n\t  }\n\t\n\t};\n\t\n\tvar nativeCloneNode = Element.prototype.cloneNode;\n\tvar nativeImportNode = Document.prototype.importNode;\n\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\n\tvar setAttribute = function(attr, value) {\n\t  if (window.ShadyCSS && attr === 'class') {\n\t    window.ShadyCSS.setElementClass(this, value);\n\t  } else {\n\t    nativeSetAttribute.call(this, attr, value);\n\t  }\n\t}\n\t\n\tvar NodeMixin = {};\n\t\n\tObject.defineProperties(NodeMixin, {\n\t\n\t  parentElement: {\n\t    get: function get() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  parentNode: {\n\t    get: function get$1() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextSibling: {\n\t    get: function get$2() {\n\t      return tree.Logical.getNextSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousSibling: {\n\t    get: function get$3() {\n\t      return tree.Logical.getPreviousSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextElementSibling: {\n\t    get: function get$4() {\n\t      return tree.Logical.getNextElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousElementSibling: {\n\t    get: function get$5() {\n\t      return tree.Logical.getPreviousElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  assignedSlot: {\n\t    get: function get$6() {\n\t      return this._assignedSlot;\n\t    },\n\t    configurable: true\n\t  }\n\t});\n\t\n\tvar FragmentMixin = {\n\t\n\t  appendChild: function appendChild(node) {\n\t    return this.insertBefore(node);\n\t  },\n\t\n\t  // cases in which we may not be able to just do standard native call\n\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t  // has an insertion point)\n\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t  // container to container.host.\n\t  // 3. node is <content> (host of container needs distribution)\n\t  insertBefore: function insertBefore(node, ref_node) {\n\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t        'of this node');\n\t    }\n\t    // remove node from its current position iff it's in a tree.\n\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var parent = tree.Logical.getParentNode(node);\n\t      mixinImpl.removeNodeFromParent(node, parent);\n\t    }\n\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t      if (ref_node) {\n\t        // if ref_node is an insertion point replace with first distributed node\n\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t        if (root) {\n\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t        }\n\t      }\n\t      // if adding to a shadyRoot, add to host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host : this;\n\t      if (ref_node) {\n\t        tree.Composed.insertBefore(container, node, ref_node);\n\t      } else {\n\t        tree.Composed.appendChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, node);\n\t    return node;\n\t  },\n\t\n\t  /**\n\t    Removes the given `node` from the element's `lightChildren`.\n\t    This method also performs dom composition.\n\t  */\n\t  removeChild: function removeChild(node) {\n\t    if (tree.Logical.getParentNode(node) !== this) {\n\t      throw Error('The node to be removed is not a child of this node: ' +\n\t        node);\n\t    }\n\t    if (!mixinImpl.removeNode(node)) {\n\t      // if removing from a shadyRoot, remove form host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host :\n\t        this;\n\t      // not guaranteed to physically be in container; e.g.\n\t      // undistributed nodes.\n\t      var parent = tree.Composed.getParentNode(node);\n\t      if (container === parent) {\n\t        tree.Composed.removeChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, null, node);\n\t    return node;\n\t  },\n\t\n\t  replaceChild: function replaceChild(node, ref_node) {\n\t    this.insertBefore(node, ref_node);\n\t    this.removeChild(ref_node);\n\t    return node;\n\t  },\n\t\n\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t  querySelector: function querySelector(selector) {\n\t    // match selector and halt on first result.\n\t    var result = mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    }, function(n) {\n\t      return Boolean(n);\n\t    })[0];\n\t    return result || null;\n\t  },\n\t\n\t  querySelectorAll: function querySelectorAll(selector) {\n\t    return mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    });\n\t  },\n\t\n\t  cloneNode: function cloneNode(deep) {\n\t    if (this.localName == 'template') {\n\t      return nativeCloneNode.call(this, deep);\n\t    } else {\n\t      var n = nativeCloneNode.call(this, false);\n\t      if (deep) {\n\t        var c$ = this.childNodes;\n\t        for (var i=0, nc; i < c$.length; i++) {\n\t          nc = c$[i].cloneNode(true);\n\t          n.appendChild(nc);\n\t        }\n\t      }\n\t      return n;\n\t    }\n\t  },\n\t\n\t  importNode: function importNode(externalNode, deep) {\n\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t    var doc = this instanceof Document ? this :\n\t      this.ownerDocument;\n\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t    if (deep) {\n\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t      common.patchNode(n);\n\t      for (var i=0, nc; i < c$.length; i++) {\n\t        nc = doc.importNode(c$[i], true);\n\t        n.appendChild(nc);\n\t      }\n\t    }\n\t    return n;\n\t  }\n\t};\n\t\n\tObject.defineProperties(FragmentMixin, {\n\t\n\t  childNodes: {\n\t    get: function get$7() {\n\t      var c$ = tree.Logical.getChildNodes(this);\n\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  children: {\n\t    get: function get$8() {\n\t      if (tree.Logical.hasChildNodes(this)) {\n\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t        });\n\t      } else {\n\t        return tree.arrayCopyChildren(this);\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstChild: {\n\t    get: function get$9() {\n\t      return tree.Logical.getFirstChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastChild: {\n\t    get: function get$10() {\n\t      return tree.Logical.getLastChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstElementChild: {\n\t    get: function get$11() {\n\t      return tree.Logical.getFirstElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastElementChild: {\n\t    get: function get$12() {\n\t      return tree.Logical.getLastElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t  // textContent / innerHTML\n\t  textContent: {\n\t    get: function get$13() {\n\t      if (this.childNodes) {\n\t        var tc = [];\n\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t            tc.push(c.textContent);\n\t          }\n\t        }\n\t        return tc.join('');\n\t      }\n\t      return '';\n\t    },\n\t    set: function set(text) {\n\t      mixinImpl.clearNode(this);\n\t      if (text) {\n\t        this.appendChild(document.createTextNode(text));\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  innerHTML: {\n\t    get: function get$14() {\n\t      return getInnerHTML(this);\n\t    },\n\t    set: function set$1(text) {\n\t      var this$1 = this;\n\t\n\t      mixinImpl.clearNode(this);\n\t      var d = document.createElement('div');\n\t      d.innerHTML = text;\n\t      // here, appendChild may move nodes async so we cannot rely\n\t      // on node position when copying\n\t      var c$ = tree.arrayCopyChildNodes(d);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1.appendChild(c$[i]);\n\t      }\n\t    },\n\t    configurable: true\n\t  }\n\t\n\t});\n\t\n\tvar ElementMixin = {\n\t\n\t  // TODO(sorvell): should only exist on <slot>\n\t  assignedNodes: function assignedNodes(options) {\n\t    return (options && options.flatten ? this._distributedNodes :\n\t      this._assignedNodes) || [];\n\t  },\n\t\n\t\n\t  setAttribute: function setAttribute$1(name, value) {\n\t    setAttribute.call(this, name, value);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  },\n\t\n\t  removeAttribute: function removeAttribute(name) {\n\t    nativeRemoveAttribute.call(this, name);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  }\n\t\n\t};\n\t\n\tObject.defineProperties(ElementMixin, {\n\t\n\t  shadowRoot: {\n\t    get: function get$15() {\n\t      return this.shadyRoot;\n\t    }\n\t  },\n\t\n\t  slot: {\n\t    get: function get$16() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set$2(value) {\n\t      this.setAttribute('slot', value);\n\t    }\n\t  }\n\t\n\t});\n\t\n\tvar activeElementDescriptor = {\n\t  get: function get$17() {\n\t    return mixinImpl.activeElementForNode(this);\n\t  }\n\t}\n\t\n\tvar ActiveElementMixin = {};\n\tObject.defineProperties(ActiveElementMixin, {\n\t  activeElement: activeElementDescriptor\n\t});\n\t\n\tvar UnderActiveElementMixin = {};\n\tObject.defineProperties(UnderActiveElementMixin, {\n\t  _activeElement: activeElementDescriptor\n\t});\n\t\n\tvar Mixins = {\n\t\n\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\n\t  Fragment: extendAll({__patched: 'Fragment'},\n\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\n\t  Element: extendAll({__patched: 'Element'},\n\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\n\t  // Note: activeElement cannot be patched on document!\n\t  Document: extendAll({__patched: 'Document'},\n\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\n\t};\n\t\n\tvar getRootNode = function(node) {\n\t  return mixinImpl.getRootNode(node);\n\t}\n\t\n\tfunction filterMutations(mutations, target) {\n\t  var targetRootNode = getRootNode(target);\n\t  return mutations.filter(function(mutation) {\n\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t    if (mutationInScope && mutation.addedNodes) {\n\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t        return (targetRootNode === getRootNode(n));\n\t      });\n\t      Object.defineProperty(mutation, 'addedNodes', {\n\t        value: nodes,\n\t        configurable: true\n\t      });\n\t    }\n\t    return mutationInScope &&\n\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t  });\n\t}\n\t\n\t// const promise = Promise.resolve();\n\t\n\tvar AsyncObserver = function AsyncObserver() {\n\t  this._scheduled = false;\n\t  this.addedNodes = [];\n\t  this.removedNodes = [];\n\t  this.callbacks = new Set();\n\t};\n\t\n\tAsyncObserver.prototype.schedule = function schedule () {\n\t    var this$1 = this;\n\t\n\t  if (!this._scheduled) {\n\t    this._scheduled = true;\n\t    promish.then(function () {\n\t      this$1.flush();\n\t    });\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.flush = function flush () {\n\t  if (this._scheduled) {\n\t    this._scheduled = false;\n\t    var mutations = this.takeRecords();\n\t    if (mutations.length) {\n\t      this.callbacks.forEach(function(cb) {\n\t        cb(mutations);\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t    var mutations = [{\n\t      addedNodes: this.addedNodes,\n\t      removedNodes: this.removedNodes\n\t    }];\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    return mutations;\n\t  }\n\t  return [];\n\t};\n\t\n\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t// directly so that users do not have to fork their code.\n\t// Supporting the entire api may be challenging: e.g. filtering out\n\t// removed nodes in the wrong scope and seeing non-distributing\n\t// subtree child mutations.\n\tvar observeChildren = function(node, callback) {\n\t  common.patchNode(node);\n\t  if (!node.__dom.observer) {\n\t    node.__dom.observer = new AsyncObserver();\n\t  }\n\t  node.__dom.observer.callbacks.add(callback);\n\t  var observer = node.__dom.observer;\n\t  return {\n\t    _callback: callback,\n\t    _observer: observer,\n\t    _node: node,\n\t    takeRecords: function takeRecords() {\n\t      return observer.takeRecords()\n\t    }\n\t  };\n\t}\n\t\n\tvar unobserveChildren = function(handle) {\n\t  var observer = handle && handle._observer;\n\t  if (observer) {\n\t    observer.callbacks.delete(handle._callback);\n\t    if (!observer.callbacks.size) {\n\t      handle._node.__dom.observer = null;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tvar patchedCount = 0;\n\t\n\tvar log = false;\n\t\n\tvar patchImpl = {\n\t\n\t  canPatchNode: function(node) {\n\t    switch (node) {\n\t      case document.head:\n\t      case document.documentElement:\n\t        return false;\n\t      default:\n\t        return true;\n\t    }\n\t  },\n\t\n\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t    window.Node.prototype, 'textContent')),\n\t\n\t  patch: function(node) {\n\t    patchedCount++;\n\t    log && window.console.warn('patch node', node);\n\t    if (this.hasPrototypeDescriptors) {\n\t      patchPrototype(node, this.mixinForObject(node));\n\t    } else {\n\t      window.console.warn('Patching instance rather than prototype', node);\n\t      extend(node, this.mixinForNode(node));\n\t    }\n\t  },\n\t\n\t  mixinForObject: function(obj) {\n\t    switch (obj.nodeType) {\n\t      case Node.ELEMENT_NODE:\n\t        return Mixins.Element;\n\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t        return Mixins.Fragment;\n\t      case Node.DOCUMENT_NODE:\n\t        return Mixins.Document;\n\t      case Node.TEXT_NODE:\n\t      case Node.COMMENT_NODE:\n\t        return Mixins.Node;\n\t    }\n\t  },\n\t\n\t  unpatch: function(obj) {\n\t    if (obj.__sourceProto) {\n\t      obj.__proto__ = obj.__sourceProto;\n\t\n\t    }\n\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t  }\n\t\n\t};\n\t\n\tfunction patchNode(node) {\n\t  if (!settings.inUse) {\n\t    return;\n\t  }\n\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t    tree.saveChildNodes(node);\n\t    patchImpl.patch(node);\n\t  }\n\t}\n\t\n\tfunction unpatchNode(node) {\n\t  patchImpl.unpatch(node);\n\t}\n\t\n\tfunction isNodePatched(node) {\n\t  return Boolean(node.__patched);\n\t}\n\t\n\t// TODO(sorvell): fake export\n\tcommon.patchNode = patchNode;\n\tcommon.isNodePatched = isNodePatched;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar origAddEventListener = Element.prototype.addEventListener;\n\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\n\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\tvar alwaysComposed = {\n\t  blur: true,\n\t  focus: true,\n\t  focusin: true,\n\t  focusout: true,\n\t  click: true,\n\t  dblclick: true,\n\t  mousedown: true,\n\t  mouseenter: true,\n\t  mouseleave: true,\n\t  mousemove: true,\n\t  mouseout: true,\n\t  mouseover: true,\n\t  mouseup: true,\n\t  wheel: true,\n\t  beforeinput: true,\n\t  input: true,\n\t  keydown: true,\n\t  keyup: true,\n\t  compositionstart: true,\n\t  compositionupdate: true,\n\t  compositionend: true,\n\t  touchstart: true,\n\t  touchend: true,\n\t  touchmove: true,\n\t  touchcancel: true,\n\t  pointerover: true,\n\t  pointerenter: true,\n\t  pointerdown: true,\n\t  pointermove: true,\n\t  pointerup: true,\n\t  pointercancel: true,\n\t  pointerout: true,\n\t  pointerleave: true,\n\t  gotpointercapture: true,\n\t  lostpointercapture: true,\n\t  dragstart: true,\n\t  drag: true,\n\t  dragenter: true,\n\t  dragleave: true,\n\t  dragover: true,\n\t  drop: true,\n\t  dragend: true,\n\t  DOMActivate: true,\n\t  DOMFocusIn: true,\n\t  DOMFocusOut: true,\n\t  keypress: true\n\t};\n\t\n\tfunction pathComposer(startNode, composed) {\n\t  var composedPath = [];\n\t  var current = startNode;\n\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t  while (current) {\n\t    composedPath.push(current);\n\t    if (current.assignedSlot) {\n\t      current = current.assignedSlot;\n\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t      current = current.host;\n\t    } else {\n\t      current = current.parentNode;\n\t    }\n\t  }\n\t  // event composedPath includes window when startNode's ownerRoot is document\n\t  if (composedPath[composedPath.length - 1] === document) {\n\t    composedPath.push(window);\n\t  }\n\t  return composedPath;\n\t}\n\t\n\tfunction retarget(refNode, path) {\n\t  if (!isShadyRoot) {\n\t    return refNode;\n\t  }\n\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t  var refNodePath = pathComposer(refNode, true);\n\t  var p$ = path;\n\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t    ancestor = p$[i];\n\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t    if (root !== lastRoot) {\n\t      rootIdx = refNodePath.indexOf(root);\n\t      lastRoot = root;\n\t    }\n\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t      return ancestor;\n\t    }\n\t  }\n\t}\n\t\n\tvar EventMixin = {\n\t\n\t  __patched: 'Event',\n\t\n\t  get composed() {\n\t    if (this.isTrusted && this.__composed === undefined) {\n\t      this.__composed = alwaysComposed[this.type];\n\t    }\n\t    return this.__composed || false;\n\t  },\n\t\n\t  composedPath: function composedPath() {\n\t    if (!this.__composedPath) {\n\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t    }\n\t    return this.__composedPath;\n\t  },\n\t\n\t  get target() {\n\t    return retarget(this.currentTarget, this.composedPath());\n\t  },\n\t\n\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t  get relatedTarget() {\n\t    if (!this.__relatedTarget) {\n\t      return null;\n\t    }\n\t    if (!this.__relatedTargetComposedPath) {\n\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t    }\n\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t  },\n\t  stopPropagation: function stopPropagation() {\n\t    Event.prototype.stopPropagation.call(this);\n\t    this.__propagationStopped = true;\n\t  },\n\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t    Event.prototype.stopImmediatePropagation.call(this);\n\t    this.__immediatePropagationStopped = true;\n\t    this.__propagationStopped = true;\n\t  }\n\t\n\t};\n\t\n\tfunction mixinComposedFlag(Base) {\n\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t  // try to do `Base.call` with a dom construtor.\n\t  var klazz = function(type, options) {\n\t    var event = new Base(type, options);\n\t    event.__composed = options && Boolean(options.composed);\n\t    return event;\n\t  }\n\t  // put constructor properties on subclass\n\t  mixin(klazz, Base);\n\t  klazz.prototype = Base.prototype;\n\t  return klazz;\n\t}\n\t\n\tvar nonBubblingEventsToRetarget = {\n\t  focus: true,\n\t  blur: true\n\t};\n\t\n\tfunction fireHandlers(event, node, phase) {\n\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t    node.__handlers[event.type][phase];\n\t  if (hs) {\n\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t      fn.call(node, event);\n\t      if (event.__immediatePropagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction retargetNonBubblingEvent(e) {\n\t  var path = e.composedPath();\n\t  var node;\n\t  // override `currentTarget` to let patched `target` calculate correctly\n\t  Object.defineProperty(e, 'currentTarget', {\n\t    get: function() {\n\t      return node;\n\t    },\n\t    configurable: true\n\t  });\n\t  for (var i = path.length - 1; i >= 0; i--) {\n\t    node = path[i];\n\t    // capture phase fires all capture handlers\n\t    fireHandlers(e, node, 'capture');\n\t    if (e.__propagationStopped) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  // set the event phase to `AT_TARGET` as in spec\n\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\n\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t  // keep track of the last seen owner root\n\t  var lastFiredRoot;\n\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t    node = path[i$1];\n\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t      fireHandlers(e, node, 'bubble');\n\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t      if (node !== window) {\n\t        lastFiredRoot = node.getRootNode();\n\t      }\n\t      if (e.__propagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t  // It's more efficient to store the node/type/options information as Array in\n\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  if (fn.__eventWrappers) {\n\t    // Stop if the wrapper function has already been created.\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        return;\n\t      }\n\t    }\n\t  } else {\n\t    fn.__eventWrappers = [];\n\t  }\n\t\n\t  var wrapperFn = function(e) {\n\t    // Support `once` option.\n\t    if (once) {\n\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t    }\n\t    if (!e.__target) {\n\t      e.__target = e.target;\n\t      e.__relatedTarget = e.relatedTarget;\n\t      patchPrototype(e, EventMixin);\n\t    }\n\t    // There are two critera that should stop events from firing on this node\n\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t        if (e.target === e.relatedTarget) {\n\t          e.stopImmediatePropagation();\n\t          return;\n\t        }\n\t      }\n\t      return fn(e);\n\t    }\n\t  };\n\t  // Store the wrapper information.\n\t  fn.__eventWrappers.push({\n\t    node: this,\n\t    type: type,\n\t    capture: capture,\n\t    once: once,\n\t    passive: passive,\n\t    wrapperFn: wrapperFn\n\t  });\n\t\n\t  if (nonBubblingEventsToRetarget[type]) {\n\t    this.__handlers = this.__handlers || {};\n\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t  } else {\n\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  // Search the wrapped function.\n\t  var wrapperFn = undefined;\n\t  if (fn.__eventWrappers) {\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t        // Cleanup.\n\t        if (!fn.__eventWrappers.length) {\n\t          fn.__eventWrappers = undefined;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t      this.__handlers && this.__handlers[type]) {\n\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t    var idx = arr.indexOf(wrapperFn);\n\t    if (idx > -1) {\n\t      arr.splice(idx, 1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction activateFocusEventOverrides() {\n\t  for (var ev in nonBubblingEventsToRetarget) {\n\t    window.addEventListener(ev, function(e) {\n\t      if (!e.__target) {\n\t        e.__target = e.target;\n\t        e.__relatedTarget = e.relatedTarget;\n\t        patchPrototype(e, EventMixin);\n\t        retargetNonBubblingEvent(e);\n\t        e.stopImmediatePropagation();\n\t      }\n\t    }, true);\n\t  }\n\t}\n\t\n\t\n\tvar PatchedEvent = mixinComposedFlag(Event);\n\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tif (settings.inUse) {\n\t\n\t  window.ShadyDOM = {\n\t    tree: tree,\n\t    getNativeProperty: getNativeProperty,\n\t    patch: patchNode,\n\t    isPatched: isNodePatched,\n\t    unpatch: unpatchNode,\n\t    isShadyRoot: isShadyRoot,\n\t    enqueue: enqueue,\n\t    flush: flush$1,\n\t    inUse: settings.inUse,\n\t    filterMutations: filterMutations,\n\t    observeChildren: observeChildren,\n\t    unobserveChildren: unobserveChildren\n\t  };\n\t\n\t  var createRootAndEnsurePatched = function(node) {\n\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t    // a timing problem with gathering composed children.\n\t    // (1) currently the child list is crawled and patched when patching occurs\n\t    // (this needs to change)\n\t    // (2) we can only patch when an element has received its parsed children\n\t    // because we cannot detect them when inserted by parser.\n\t    // let ancestor = node;\n\t    // while (ancestor) {\n\t    //   patchNode(ancestor);\n\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t    // }\n\t    patchNode(node);\n\t    var root = new ShadyRoot(node);\n\t    patchNode(root);\n\t    return root;\n\t  }\n\t\n\t  Element.prototype.attachShadow = function() {\n\t    return createRootAndEnsurePatched(this);\n\t  }\n\t\n\t  Node.prototype.addEventListener = addEventListener;\n\t  Node.prototype.removeEventListener = removeEventListener;\n\t  Event = PatchedEvent;\n\t  CustomEvent = PatchedCustomEvent;\n\t  MouseEvent = PatchedMouseEvent;\n\t  activateFocusEventOverrides();\n\t\n\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t    get: function get() {\n\t      return document.documentElement.contains(this);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Node.prototype.getRootNode = function(options) {\n\t    return getRootNode(this, options);\n\t  }\n\t\n\t  Object.defineProperty(Element.prototype, 'slot', {\n\t    get: function get$1() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set(value) {\n\t      this.setAttribute('slot', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t    get: function get$2() {\n\t      return this._assignedSlot || null;\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Element.prototype.setAttribute = setAttribute;\n\t\n\t  Object.defineProperty(Element.prototype, 'className', {\n\t    get: function get$3() {\n\t      return this.getAttribute('class');\n\t    },\n\t    set: function set$1(value) {\n\t      this.setAttribute('class', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t  // via appendChild. This either needs to be expanded or contracted.\n\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t  //   patchNode(this);\n\t  //   return this.appendChild(node);\n\t  // }\n\t\n\t}\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadydom.min.js.map\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tExtremely simple css parser. Intended to be not more than what we need\n\tand definitely not necessarily correct =).\n\t*/\n\t\n\t// given a string of css, return a simple rule tree\n\t\n\tfunction parse(text) {\n\t  text = clean(text);\n\t  return parseCss(lex(text), text);\n\t}\n\t\n\t// remove stuff we don't care about that may hinder parsing\n\tfunction clean(cssText) {\n\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t}\n\t\n\t// super simple {...} lexer that returns a node tree\n\tfunction lex(text) {\n\t  var root = {\n\t    start: 0,\n\t    end: text.length\n\t  };\n\t  var n = root;\n\t  for (var i = 0, l = text.length; i < l; i++) {\n\t    if (text[i] === OPEN_BRACE) {\n\t      if (!n.rules) {\n\t        n.rules = [];\n\t      }\n\t      var p = n;\n\t      var previous = p.rules[p.rules.length - 1];\n\t      n = {\n\t        start: i + 1,\n\t        parent: p,\n\t        previous: previous\n\t      };\n\t      p.rules.push(n);\n\t    } else if (text[i] === CLOSE_BRACE) {\n\t      n.end = i + 1;\n\t      n = n.parent || root;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// add selectors/cssText to node tree\n\tfunction parseCss(node, text) {\n\t  var t = text.substring(node.start, node.end - 1);\n\t  node.parsedCssText = node.cssText = t.trim();\n\t  if (node.parent) {\n\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t    t = text.substring(ss, node.start - 1);\n\t    t = _expandUnicodeEscapes(t);\n\t    t = t.replace(RX.multipleSpaces, ' ');\n\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t    // helps with mixin syntax\n\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t    var s = node.parsedSelector = node.selector = t.trim();\n\t    node.atRule = s.indexOf(AT_START) === 0;\n\t    // note, support a subset of rule types...\n\t    if (node.atRule) {\n\t      if (s.indexOf(MEDIA_START) === 0) {\n\t        node.type = types.MEDIA_RULE;\n\t      } else if (s.match(RX.keyframesRule)) {\n\t        node.type = types.KEYFRAMES_RULE;\n\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t      }\n\t    } else {\n\t      if (s.indexOf(VAR_START) === 0) {\n\t        node.type = types.MIXIN_RULE;\n\t      } else {\n\t        node.type = types.STYLE_RULE;\n\t      }\n\t    }\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      parseCss(r, text);\n\t    }\n\t  }\n\t  return node;\n\t}\n\t\n\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t// expanded form that doesn't require trailing space `\\000033`\n\tfunction _expandUnicodeEscapes(s) {\n\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t    var code = arguments[1],\n\t        repeat = 6 - code.length;\n\t    while (repeat--) {\n\t      code = '0' + code;\n\t    }\n\t    return '\\\\' + code;\n\t  });\n\t}\n\t\n\t// stringify parsed css.\n\tfunction stringify(node, preserveProperties, text) {\n\t  text = text || '';\n\t  // calc rule cssText\n\t  var cssText = '';\n\t  if (node.cssText || node.rules) {\n\t    var r$ = node.rules;\n\t    if (r$ && !_hasMixinRules(r$)) {\n\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t        cssText = stringify(r, preserveProperties, cssText);\n\t      }\n\t    } else {\n\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t      cssText = cssText.trim();\n\t      if (cssText) {\n\t        cssText = '  ' + cssText + '\\n';\n\t      }\n\t    }\n\t  }\n\t  // emit rule if there is cssText\n\t  if (cssText) {\n\t    if (node.selector) {\n\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t    }\n\t    text += cssText;\n\t    if (node.selector) {\n\t      text += CLOSE_BRACE + '\\n\\n';\n\t    }\n\t  }\n\t  return text;\n\t}\n\t\n\tfunction _hasMixinRules(rules) {\n\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t}\n\t\n\tfunction removeCustomProps(cssText) {\n\t  cssText = removeCustomPropAssignment(cssText);\n\t  return removeCustomPropApply(cssText);\n\t}\n\t\n\tfunction removeCustomPropAssignment(cssText) {\n\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t}\n\t\n\tfunction removeCustomPropApply(cssText) {\n\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t}\n\t\n\tvar types = {\n\t  STYLE_RULE: 1,\n\t  KEYFRAMES_RULE: 7,\n\t  MEDIA_RULE: 4,\n\t  MIXIN_RULE: 1000\n\t};\n\t\n\tvar OPEN_BRACE = '{';\n\tvar CLOSE_BRACE = '}';\n\t\n\t// helper regexp's\n\tvar RX = {\n\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t  port: /@import[^;]*;/gim,\n\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t  multipleSpaces: /\\s+/g\n\t};\n\t\n\tvar VAR_START = '--';\n\tvar MEDIA_START = '@media';\n\tvar AT_START = '@';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\n\t// experimental support for native @apply\n\tfunction detectNativeApply() {\n\t  var style = document.createElement('style');\n\t  style.textContent = '.foo { @apply --foo }';\n\t  document.head.appendChild(style);\n\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t  document.head.removeChild(style);\n\t  return nativeCssApply;\n\t}\n\t\n\tvar nativeCssApply = false && detectNativeApply();\n\t\n\tfunction parseSettings(settings) {\n\t  if (settings) {\n\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t  }\n\t}\n\t\n\tif (window.ShadyCSS) {\n\t  parseSettings(window.ShadyCSS);\n\t} else if (window.WebComponents) {\n\t  parseSettings(window.WebComponents.flags);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction toCssText(rules, callback) {\n\t  if (typeof rules === 'string') {\n\t    rules = parse(rules);\n\t  }\n\t  if (callback) {\n\t    forEachRule(rules, callback);\n\t  }\n\t  return stringify(rules, nativeCssVariables);\n\t}\n\t\n\tfunction rulesForStyle(style) {\n\t  if (!style.__cssRules && style.textContent) {\n\t    style.__cssRules = parse(style.textContent);\n\t  }\n\t  return style.__cssRules;\n\t}\n\t\n\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t// like a normal selector but is not (it has nothing to do with scoping\n\t// for example).\n\tfunction isKeyframesSelector(rule) {\n\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t}\n\t\n\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t  if (!node) {\n\t    return;\n\t  }\n\t  var skipRules = false;\n\t  if (onlyActiveRules) {\n\t    if (node.type === types.MEDIA_RULE) {\n\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t      if (matchMedia) {\n\t        // if rule is a non matching @media rule, skip subrules\n\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t          skipRules = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (node.type === types.STYLE_RULE) {\n\t    styleRuleCallback(node);\n\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t    keyframesRuleCallback(node);\n\t  } else if (node.type === types.MIXIN_RULE) {\n\t    skipRules = true;\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$ && !skipRules) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t    }\n\t  }\n\t}\n\t\n\t// add a string of cssText to the document.\n\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t  var style = createScopeStyle(cssText, moniker);\n\t  return applyStyle$1(style, target, contextNode);\n\t}\n\t\n\tfunction applyStyle$1(style, target, contextNode) {\n\t  target = target || document.head;\n\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t  lastHeadApplyNode = style;\n\t  return target.insertBefore(style, after);\n\t}\n\t\n\tfunction createScopeStyle(cssText, moniker) {\n\t  var style = document.createElement('style');\n\t  if (moniker) {\n\t    style.setAttribute('scope', moniker);\n\t  }\n\t  style.textContent = cssText;\n\t  return style;\n\t}\n\t\n\tvar lastHeadApplyNode = null;\n\t\n\t// insert a comment node as a styling position placeholder.\n\tfunction applyStylePlaceHolder(moniker) {\n\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t  var scope = document.head;\n\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t  lastHeadApplyNode = placeHolder;\n\t  return placeHolder;\n\t}\n\t\n\t\n\t\n\t// cssBuildTypeForModule: function (module) {\n\t//   let dm = Polymer.DomModule.import(module);\n\t//   if (dm) {\n\t//     return getCssBuildType(dm);\n\t//   }\n\t// },\n\t//\n\t\n\t\n\t// Walk from text[start] matching parens\n\t// returns position of the outer end paren\n\tfunction findMatchingParen(text, start) {\n\t  var level = 0;\n\t  for (var i = start, l = text.length; i < l; i++) {\n\t    if (text[i] === '(') {\n\t      level++;\n\t    } else if (text[i] === ')') {\n\t      if (--level === 0) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tfunction processVariableAndFallback(str, callback) {\n\t  // find 'var('\n\t  var start = str.indexOf('var(');\n\t  if (start === -1) {\n\t    // no var?, everything is prefix\n\t    return callback(str, '', '', '');\n\t  }\n\t  //${prefix}var(${inner})${suffix}\n\t  var end = findMatchingParen(str, start + 3);\n\t  var inner = str.substring(start + 4, end);\n\t  var prefix = str.substring(0, start);\n\t  // suffix may have other variables\n\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t  var comma = inner.indexOf(',');\n\t  // value and fallback args should be trimmed to match in property lookup\n\t  if (comma === -1) {\n\t    // variable, no fallback\n\t    return callback(prefix, inner.trim(), '', suffix);\n\t  }\n\t  // var(${value},${fallback})\n\t  var value = inner.substring(0, comma).trim();\n\t  var fallback = inner.substring(comma + 1).trim();\n\t  return callback(prefix, value, fallback, suffix);\n\t}\n\t\n\tvar rx = {\n\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t  IS_VAR: /^--/,\n\t  BRACKETED: /\\{[^}]*\\}/g,\n\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\n\t* scoping:\n\t\n\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t  * selectors re-written as follows:\n\t\n\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\n\t* :host -> scopeName\n\t\n\t* :host(...) -> scopeName...\n\t\n\t* ::slotted(...) -> scopeName > ...\n\t\n\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\n\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\n\t*/\n\tvar SCOPE_NAME = 'style-scope';\n\t\n\tvar StyleTransformer = {\n\t\n\t  // Given a node and scope name, add a scoping class to each node\n\t  // in the tree. This facilitates transforming css into scoped rules.\n\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t    // one time optimization to skip scoping...\n\t    if (node.__styleScoped) {\n\t      node.__styleScoped = null;\n\t    } else {\n\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t    }\n\t  },\n\t\n\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t    if (node.classList) {\n\t      this.element(node, selector, shouldRemoveScope);\n\t    }\n\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t    if (c$) {\n\t      for (var i = 0; i < c$.length; i++) {\n\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t      }\n\t    }\n\t  },\n\t\n\t  element: function element(_element, scope, shouldRemoveScope) {\n\t    // note: if using classes, we add both the general 'style-scope' class\n\t    // as well as the specific scope. This enables easy filtering of all\n\t    // `style-scope` elements\n\t    if (scope) {\n\t      // note: svg on IE does not have classList so fallback to class\n\t      if (_element.classList) {\n\t        if (shouldRemoveScope) {\n\t          _element.classList.remove(SCOPE_NAME);\n\t          _element.classList.remove(scope);\n\t        } else {\n\t          _element.classList.add(SCOPE_NAME);\n\t          _element.classList.add(scope);\n\t        }\n\t      } else if (_element.getAttribute) {\n\t        var c = _element.getAttribute(CLASS);\n\t        if (shouldRemoveScope) {\n\t          if (c) {\n\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t          }\n\t        } else {\n\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t    var cssBuildType = element.__cssBuild;\n\t    // no need to shim selectors if settings.useNativeShadow, also\n\t    // a shady css build will already have transformed selectors\n\t    // NOTE: This method may be called as part of static or property shimming.\n\t    // When there is a targeted build it will not be called for static shimming,\n\t    // but when the property shim is used it is called and should opt out of\n\t    // static shimming work when a proper build exists.\n\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t    return cssText.trim();\n\t  },\n\t\n\t  // Given a string of cssText and a scoping string (scope), returns\n\t  // a string of scoped css where each selector is transformed to include\n\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t  // (e.g. :host) to use the scoping selector.\n\t  css: function css(rules, scope, ext, callback) {\n\t    var hostScope = this._calcHostScope(scope, ext);\n\t    scope = this._calcElementScope(scope);\n\t    var self = this;\n\t    return toCssText(rules, function (rule) {\n\t      if (!rule.isScoped) {\n\t        self.rule(rule, scope, hostScope);\n\t        rule.isScoped = true;\n\t      }\n\t      if (callback) {\n\t        callback(rule, scope, hostScope);\n\t      }\n\t    });\n\t  },\n\t\n\t  _calcElementScope: function _calcElementScope(scope) {\n\t    if (scope) {\n\t      return CSS_CLASS_PREFIX + scope;\n\t    } else {\n\t      return '';\n\t    }\n\t  },\n\t\n\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t    return ext ? '[is=' + scope + ']' : scope;\n\t  },\n\t\n\t  rule: function rule(_rule, scope, hostScope) {\n\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t  },\n\t\n\t  // transforms a css rule to a scoped rule.\n\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t    // against selectors (e.g. when calculating style properties)\n\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t  },\n\t\n\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t    // we want to skip transformation of rules that appear in keyframes,\n\t    // because they are keyframe selectors, not element selectors.\n\t    if (!isKeyframesSelector(rule)) {\n\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t      }\n\t    }\n\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t  },\n\t\n\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t    var _this = this;\n\t\n\t    var stop = false;\n\t    selector = selector.trim();\n\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t    });\n\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t      if (!stop) {\n\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t        stop = stop || info.stop;\n\t        c = info.combinator;\n\t        s = info.value;\n\t      }\n\t      return c + s;\n\t    });\n\t    return selector;\n\t  },\n\t\n\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t    // replace :host with host scoping class\n\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t    if (selector.indexOf(HOST) >= 0) {\n\t      selector = this._transformHostSelector(selector, hostScope);\n\t      // replace other selectors with scoping class\n\t    } else if (slottedIndex !== 0) {\n\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t    }\n\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t    // also ignore left-side combinator\n\t    var slotted = false;\n\t    if (slottedIndex >= 0) {\n\t      combinator = '';\n\t      slotted = true;\n\t    }\n\t    // process scope jumping selectors up to the scope jump and then stop\n\t    var stop = void 0;\n\t    if (slotted) {\n\t      stop = true;\n\t      if (slotted) {\n\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t          return ' > ' + paren;\n\t        });\n\t      }\n\t    }\n\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t    });\n\t    return { value: selector, combinator: combinator, stop: stop };\n\t  },\n\t\n\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t    p$[0] += scope;\n\t    return p$.join(PSEUDO_PREFIX);\n\t  },\n\t\n\t  // :host(...) -> scopeName...\n\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t    var m = selector.match(HOST_PAREN);\n\t    var paren = m && m[2].trim() || '';\n\t    if (paren) {\n\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t        // paren starts with a type selector\n\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t        // if the type selector is our hostScope then avoid pre-pending it\n\t        if (typeSelector === hostScope) {\n\t          return paren;\n\t          // otherwise, this selector should not match in this scope so\n\t          // output a bogus selector.\n\t        } else {\n\t          return SELECTOR_NO_MATCH;\n\t        }\n\t      } else {\n\t        // make sure to do a replace here to catch selectors like:\n\t        // `:host(.foo)::before`\n\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t          return hostScope + paren;\n\t        });\n\t      }\n\t      // if no paren, do a straight :host replacement.\n\t      // TODO(sorvell): this should not strictly be necessary but\n\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t      // which have been improperly used under Shady DOM. This should be\n\t      // deprecated.\n\t    } else {\n\t      return selector.replace(HOST, hostScope);\n\t    }\n\t  },\n\t\n\t  documentRule: function documentRule(rule) {\n\t    // reset selector in case this is redone.\n\t    rule.selector = rule.parsedSelector;\n\t    this.normalizeRootSelector(rule);\n\t    this._transformRule(rule, this._transformDocumentSelector);\n\t  },\n\t\n\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t    if (rule.selector === ROOT) {\n\t      rule.selector = 'html';\n\t    }\n\t  },\n\t\n\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t  },\n\t  SCOPE_NAME: SCOPE_NAME\n\t};\n\t\n\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\tvar COMPLEX_SELECTOR_SEP = ',';\n\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\tvar HOST = ':host';\n\tvar ROOT = ':root';\n\tvar SLOTTED = '::slotted';\n\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t// NOTE: this supports 1 nested () pair for things like\n\t// :host(:not([selected]), more general support requires\n\t// parsing which seems like overkill\n\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t// similar to HOST_PAREN\n\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\tvar CSS_CLASS_PREFIX = '.';\n\tvar PSEUDO_PREFIX = ':';\n\tvar CLASS = 'class';\n\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar StyleInfo = function () {\n\t  createClass(StyleInfo, null, [{\n\t    key: 'get',\n\t    value: function get(node) {\n\t      return node.__styleInfo;\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(node, styleInfo) {\n\t      node.__styleInfo = styleInfo;\n\t      return styleInfo;\n\t    }\n\t  }]);\n\t\n\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t    classCallCheck(this, StyleInfo);\n\t\n\t    this.styleRules = ast || null;\n\t    this.placeholder = placeholder || null;\n\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t    this.overrideStyleProperties = {};\n\t    this.elementName = elementName || '';\n\t    this.cssBuild = cssBuild || '';\n\t    this.typeExtension = typeExtension || '';\n\t    this.styleProperties = null;\n\t    this.scopeSelector = null;\n\t    this.customStyle = null;\n\t  }\n\t\n\t  return StyleInfo;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO: dedupe with shady\n\tvar p = window.Element.prototype;\n\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\n\tvar StyleProperties = {\n\t\n\t  // decorates styles with rule info and returns an array of used style\n\t  // property names\n\t  decorateStyles: function decorateStyles(rules) {\n\t    var self = this,\n\t        props = {},\n\t        keyframes = [],\n\t        ruleIndex = 0;\n\t    forEachRule(rules, function (rule) {\n\t      self.decorateRule(rule);\n\t      // mark in-order position of ast rule in styles block, used for cache key\n\t      rule.index = ruleIndex++;\n\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t    }, function onKeyframesRule(rule) {\n\t      keyframes.push(rule);\n\t    });\n\t    // Cache all found keyframes rules for later reference:\n\t    rules._keyframes = keyframes;\n\t    // return this list of property names *consumes* in these styles.\n\t    var names = [];\n\t    for (var i in props) {\n\t      names.push(i);\n\t    }\n\t    return names;\n\t  },\n\t\n\t  // decorate a single rule with property info\n\t  decorateRule: function decorateRule(rule) {\n\t    if (rule.propertyInfo) {\n\t      return rule.propertyInfo;\n\t    }\n\t    var info = {},\n\t        properties = {};\n\t    var hasProperties = this.collectProperties(rule, properties);\n\t    if (hasProperties) {\n\t      info.properties = properties;\n\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t      rule.rules = null;\n\t    }\n\t    info.cssText = this.collectCssText(rule);\n\t    rule.propertyInfo = info;\n\t    return info;\n\t  },\n\t\n\t  // collects the custom properties from a rule's cssText\n\t  collectProperties: function collectProperties(rule, properties) {\n\t    var info = rule.propertyInfo;\n\t    if (info) {\n\t      if (info.properties) {\n\t        Object.assign(properties, info.properties);\n\t        return true;\n\t      }\n\t    } else {\n\t      var m = void 0,\n\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t      var cssText = rule.parsedCssText;\n\t      var value = void 0;\n\t      var any = void 0;\n\t      while (m = rx$$1.exec(cssText)) {\n\t        // note: group 2 is var, 3 is mixin\n\t        value = (m[2] || m[3]).trim();\n\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t        if (value !== 'inherit' || value !== 'unset') {\n\t          properties[m[1].trim()] = value;\n\t        }\n\t        any = true;\n\t      }\n\t      return any;\n\t    }\n\t  },\n\t\n\t  // returns cssText of properties that consume variables/mixins\n\t  collectCssText: function collectCssText(rule) {\n\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t  },\n\t\n\t  // NOTE: we support consumption inside mixin assignment\n\t  // but not production, so strip out {...}\n\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t  },\n\t\n\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t    var m = void 0;\n\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t      var name = m[1];\n\t      // This regex catches all variable names, and following non-whitespace char\n\t      // If next char is not ':', then variable is a consumer\n\t      if (m[2] !== ':') {\n\t        props[name] = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  // turns custom properties into realized values.\n\t  reify: function reify(props) {\n\t    // big perf optimization here: reify only *own* properties\n\t    // since this object has __proto__ of the element's scope properties\n\t    var names = Object.getOwnPropertyNames(props);\n\t    for (var i = 0, n; i < names.length; i++) {\n\t      n = names[i];\n\t      props[n] = this.valueForProperty(props[n], props);\n\t    }\n\t  },\n\t\n\t  // given a property value, returns the reified value\n\t  // a property value may be:\n\t  // (1) a literal value like: red or 5px;\n\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t  // var(--a, var(--b));\n\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t  valueForProperty: function valueForProperty(property, props) {\n\t    var _this = this;\n\t\n\t    // case (1) default\n\t    // case (3) defines a mixin and we have to reify the internals\n\t    if (property) {\n\t      if (property.indexOf(';') >= 0) {\n\t        property = this.valueForProperties(property, props);\n\t      } else {\n\t        (function () {\n\t          // case (2) variable\n\t          var self = _this;\n\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t            if (!value) {\n\t              return prefix + suffix;\n\t            }\n\t            var propertyValue = self.valueForProperty(props[value], props);\n\t            // if value is \"initial\", then the variable should be treated as unset\n\t            if (!propertyValue || propertyValue === 'initial') {\n\t              // fallback may be --a or var(--a) or literal\n\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t              // for use with native css variables.\n\t              // Since we have full control, we can use `inherit` directly.\n\t              propertyValue = 'inherit';\n\t            }\n\t            return prefix + (propertyValue || '') + suffix;\n\t          };\n\t          property = processVariableAndFallback(property, fn);\n\t        })();\n\t      }\n\t    }\n\t    return property && property.trim() || '';\n\t  },\n\t\n\t  // note: we do not yet support mixin within mixin\n\t  valueForProperties: function valueForProperties(property, props) {\n\t    var parts = property.split(';');\n\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t      if (_p = parts[i]) {\n\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t        if (m) {\n\t          _p = this.valueForProperty(props[m[1]], props);\n\t        } else {\n\t          var colon = _p.indexOf(':');\n\t          if (colon !== -1) {\n\t            var pp = _p.substring(colon);\n\t            pp = pp.trim();\n\t            pp = this.valueForProperty(pp, props) || pp;\n\t            _p = _p.substring(0, colon) + pp;\n\t          }\n\t        }\n\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t        // strip trailing ;\n\t        _p.slice(0, -1) : _p || '';\n\t      }\n\t    }\n\t    return parts.join(';');\n\t  },\n\t\n\t  applyProperties: function applyProperties(rule, props) {\n\t    var output = '';\n\t    // dynamically added sheets may not be decorated so ensure they are.\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (rule.propertyInfo.cssText) {\n\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t  // functions which take in cssText and spit out transformed cssText.\n\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t    var input = rule.cssText;\n\t    var output = rule.cssText;\n\t    if (rule.hasAnimations == null) {\n\t      // Cache whether or not the rule has any animations to begin with:\n\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t    }\n\t    // If there are no animations referenced, we can skip transforms:\n\t    if (rule.hasAnimations) {\n\t      var transform = void 0;\n\t      // If we haven't transformed this rule before, we iterate over all\n\t      // transforms:\n\t      if (rule.keyframeNamesToTransform == null) {\n\t        rule.keyframeNamesToTransform = [];\n\t        for (var keyframe in keyframeTransforms) {\n\t          transform = keyframeTransforms[keyframe];\n\t          output = transform(input);\n\t          // If the transform actually changed the CSS text, we cache the\n\t          // transform name for future use:\n\t          if (input !== output) {\n\t            input = output;\n\t            rule.keyframeNamesToTransform.push(keyframe);\n\t          }\n\t        }\n\t      } else {\n\t        // If we already have a list of keyframe names that apply to this\n\t        // rule, we apply only those keyframe name transforms:\n\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t          input = transform(input);\n\t        }\n\t        output = input;\n\t      }\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Test if the rules in these styles matches the given `element` and if so,\n\t  // collect any custom properties into `props`.\n\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t    var props = {},\n\t        self = this;\n\t    // generates a unique key for these matches\n\t    var o = [];\n\t    // note: active rules excludes non-matching @media rules\n\t    forEachRule(rules, function (rule) {\n\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t      // time to only include ones that have properties\n\t      if (!rule.propertyInfo) {\n\t        self.decorateRule(rule);\n\t      }\n\t      // match element against transformedSelector: selector may contain\n\t      // unwanted uniquification and parsedSelector does not directly match\n\t      // for :host selectors.\n\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t          self.collectProperties(rule, props);\n\t          // produce numeric key for these matches for lookup\n\t          addToBitMask(rule.index, o);\n\t        }\n\t      }\n\t    }, null, true);\n\t    return { properties: props, key: o };\n\t  },\n\t\n\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (!rule.propertyInfo.properties) {\n\t      return;\n\t    }\n\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t    var parsedSelector = rule.parsedSelector;\n\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t    // build info is either in scope (when scope is an element) or in the style\n\t    // when scope is the default scope; note: this allows default scope to have\n\t    // mixed mode built and unbuilt styles.\n\t    if (cssBuild === 'shady') {\n\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t    }\n\t    if (cssBuild === 'shadow') {\n\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t      isHost = isHost && !isRoot;\n\t    }\n\t    if (!isRoot && !isHost) {\n\t      return;\n\t    }\n\t    var selectorToMatch = hostScope;\n\t    if (isHost) {\n\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t      if (nativeShadow && !rule.transformedSelector) {\n\t        // transform :host into a matchable selector\n\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t      }\n\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t    }\n\t    callback({\n\t      selector: selectorToMatch,\n\t      isHost: isHost,\n\t      isRoot: isRoot\n\t    });\n\t  },\n\t\n\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t    var hostProps = {},\n\t        rootProps = {},\n\t        self = this;\n\t    // note: active rules excludes non-matching @media rules\n\t    var cssBuild = rules && rules.__cssBuild;\n\t    forEachRule(rules, function (rule) {\n\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t        var element = scope._element || scope;\n\t        if (matchesSelector.call(element, info.selector)) {\n\t          if (info.isHost) {\n\t            self.collectProperties(rule, hostProps);\n\t          } else {\n\t            self.collectProperties(rule, rootProps);\n\t          }\n\t        }\n\t      });\n\t    }, null, true);\n\t    return { rootProps: rootProps, hostProps: hostProps };\n\t  },\n\t\n\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t    var self = this;\n\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t    var rules = StyleInfo.get(element).styleRules;\n\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t      self.applyProperties(rule, properties);\n\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t        // is not necessary to apply them in ShadowDOM.\n\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t      }\n\t    });\n\t  },\n\t\n\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t    var keyframesRules = rules._keyframes;\n\t    var keyframeTransforms = {};\n\t    if (!nativeShadow && keyframesRules) {\n\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t      // advance for the current scope. This allows us to catch keyframes\n\t      // rules that appear anywhere in the stylesheet:\n\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t      }\n\t    }\n\t    return keyframeTransforms;\n\t  },\n\t\n\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t  // particular scoped keyframes rule.\n\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t    return function (cssText) {\n\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t    };\n\t  },\n\t\n\t  // Transforms `@keyframes` names to be unique for the current host.\n\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t  },\n\t\n\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t  // have low specificity. They are overrideable by class selectors but,\n\t  // unfortunately, not by type selectors (e.g. overriding via\n\t  // `.special` is ok, but not by `x-foo`).\n\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    var selector = rule.transformedSelector;\n\t    var scope = '.' + scopeId;\n\t    var parts = selector.split(',');\n\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t    }\n\t    rule.selector = parts.join(',');\n\t  },\n\t\n\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t    var c = element.getAttribute('class') || '';\n\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t    if (c !== v) {\n\t      element.setAttribute('class', v);\n\t    }\n\t  },\n\t\n\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t    // calculate cssText to apply\n\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t    // if shady and we have a cached style that is not style, decrement\n\t    var styleInfo = StyleInfo.get(element);\n\t    var s = styleInfo.customStyle;\n\t    if (s && !nativeShadow && s !== style) {\n\t      s._useCount--;\n\t      if (s._useCount <= 0 && s.parentNode) {\n\t        s.parentNode.removeChild(s);\n\t      }\n\t    }\n\t    // apply styling always under native or if we generated style\n\t    // or the cached style is not in document(!)\n\t    if (nativeShadow) {\n\t      // update existing style only under native\n\t      if (styleInfo.customStyle) {\n\t        styleInfo.customStyle.textContent = cssText;\n\t        style = styleInfo.customStyle;\n\t        // otherwise, if we have css to apply, do so\n\t      } else if (cssText) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t      }\n\t    } else {\n\t      // shady and no cache hit\n\t      if (!style) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        if (cssText) {\n\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t        }\n\t        // shady and cache hit but not in document\n\t      } else if (!style.parentNode) {\n\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t      }\n\t    }\n\t    // ensure this style is our custom style and increment its use count.\n\t    if (style) {\n\t      style._useCount = style._useCount || 0;\n\t      // increment use count if we changed styles\n\t      if (styleInfo.customStyle != style) {\n\t        style._useCount++;\n\t      }\n\t      styleInfo.customStyle = style;\n\t    }\n\t    // @media rules may be stale in IE 10 and 11\n\t    if (IS_IE) {\n\t      style.textContent = style.textContent;\n\t    }\n\t    return style;\n\t  },\n\t\n\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t    var rules = rulesForStyle(style);\n\t    var self = this;\n\t    style.textContent = toCssText(rules, function (rule) {\n\t      var css = rule.cssText = rule.parsedCssText;\n\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t        // remove property assignments\n\t        // so next function isn't confused\n\t        // NOTE: we have 3 categories of css:\n\t        // (1) normal properties,\n\t        // (2) custom property assignments (--foo: red;),\n\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t        // are not and this makes this case unique.\n\t        css = removeCustomPropAssignment(css);\n\t        // replace with reified properties, scenario is same as mixin\n\t        rule.cssText = self.valueForProperties(css, properties);\n\t      }\n\t    });\n\t  },\n\t\n\t  rx: rx,\n\t  XSCOPE_NAME: 'x-scope'\n\t};\n\t\n\tfunction addToBitMask(n, bits) {\n\t  var o = parseInt(n / 32);\n\t  var v = 1 << n % 32;\n\t  bits[o] = (bits[o] || 0) | v;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar templateMap = {};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar placeholderMap = {};\n\t\n\tvar ce = window.customElements;\n\tif (ce && !nativeShadow) {\n\t  (function () {\n\t    var origDefine = ce.define;\n\t    ce.define = function (name, clazz, options) {\n\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t      return origDefine.call(ce, name, clazz, options);\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\tvar StyleCache = function () {\n\t  function StyleCache() {\n\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t    classCallCheck(this, StyleCache);\n\t\n\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t    this.cache = {};\n\t    this.typeMax = typeMax;\n\t  }\n\t\n\t  createClass(StyleCache, [{\n\t    key: '_validate',\n\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t        var pn = ownPropertyNames[idx];\n\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'store',\n\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t      var list = this.cache[tagname] || [];\n\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t      if (list.length > this.typeMax) {\n\t        list.shift();\n\t      }\n\t      this.cache[tagname] = list;\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t      var list = this.cache[tagname];\n\t      if (!list) {\n\t        return;\n\t      }\n\t      // reverse list for most-recent lookups\n\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t        var entry = list[idx];\n\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t          return entry;\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t  return StyleCache;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/**\n\t * The apply shim simulates the behavior of `@apply` proposed at\n\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t * The approach is to convert a property like this:\n\t *\n\t *    --foo: {color: red; background: blue;}\n\t *\n\t * to this:\n\t *\n\t *    --foo_-_color: red;\n\t *    --foo_-_background: blue;\n\t *\n\t * Then where `@apply --foo` is used, that is converted to:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background);\n\t *\n\t * This approach generally works but there are some issues and limitations.\n\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t * another element sets it to:\n\t *\n\t *    --foo: { border: 2px solid red; }\n\t *\n\t * We must now ensure that the color and background from the previous setting\n\t * do not apply. This is accomplished by changing the property set to this:\n\t *\n\t *    --foo_-_border: 2px solid red;\n\t *    --foo_-_color: initial;\n\t *    --foo_-_background: initial;\n\t *\n\t * This works but introduces one new issue.\n\t * Consider this setup at the point where the `@apply` is used:\n\t *\n\t *    background: orange;\n\t *    @apply --foo;\n\t *\n\t * In this case the background will be unset (initial) rather than the desired\n\t * `orange`. We address this by altering the property set to use a fallback\n\t * value like this:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background, orange);\n\t *    border: var(--foo_-_border);\n\t *\n\t * Note that the default is retained in the property set and the `background` is\n\t * the desired `orange`. This leads us to a limitation.\n\t *\n\t * Limitation 1:\n\t\n\t * Only properties in the rule where the `@apply`\n\t * is used are considered as default values.\n\t * If another rule matches the element and sets `background` with\n\t * less specificity than the rule in which `@apply` appears,\n\t * the `background` will not be set.\n\t *\n\t * Limitation 2:\n\t *\n\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t * `@apply` properties.\n\t\n\t*/\n\t\n\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\n\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\n\t// separator used between mixin-name and mixin-property-name when producing properties\n\t// NOTE: plain '-' may cause collisions in user styles\n\tvar MIXIN_VAR_SEP = '_-_';\n\t\n\t// map of mixin to property names\n\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\n\tvar MixinMap = function () {\n\t  function MixinMap() {\n\t    classCallCheck(this, MixinMap);\n\t\n\t    this._map = {};\n\t  }\n\t\n\t  createClass(MixinMap, [{\n\t    key: 'set',\n\t    value: function set(name, props) {\n\t      name = name.trim();\n\t      this._map[name] = {\n\t        properties: props,\n\t        dependants: {}\n\t      };\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(name) {\n\t      name = name.trim();\n\t      return this._map[name];\n\t    }\n\t  }]);\n\t  return MixinMap;\n\t}();\n\t\n\tvar ApplyShim = function () {\n\t  function ApplyShim() {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, ApplyShim);\n\t\n\t    this._currentTemplate = null;\n\t    this._measureElement = null;\n\t    this._map = new MixinMap();\n\t    this._separator = MIXIN_VAR_SEP;\n\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t    };\n\t  }\n\t\n\t  createClass(ApplyShim, [{\n\t    key: 'transformStyle',\n\t    value: function transformStyle(style, elementName) {\n\t      var ast = rulesForStyle(style);\n\t      this.transformRules(ast, elementName);\n\t      return ast;\n\t    }\n\t  }, {\n\t    key: 'transformRules',\n\t    value: function transformRules(rules, elementName) {\n\t      var _this2 = this;\n\t\n\t      this._currentTemplate = templateMap[elementName];\n\t      forEachRule(rules, function (r) {\n\t        _this2.transformRule(r);\n\t      });\n\t      if (this._currentTemplate) {\n\t        this._currentTemplate.__applyShimInvalid = false;\n\t      }\n\t      this._currentTemplate = null;\n\t    }\n\t  }, {\n\t    key: 'transformRule',\n\t    value: function transformRule(rule) {\n\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t      // :root was only used for variable assignment in property shim,\n\t      // but generates invalid selectors with real properties.\n\t      // replace with `:host > *`, which serves the same effect\n\t      if (rule.selector === ':root') {\n\t        rule.selector = ':host > *';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'transformCssText',\n\t    value: function transformCssText(cssText) {\n\t      // produce variables\n\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t      // consume mixins\n\t      return this._consumeCssProperties(cssText);\n\t    }\n\t  }, {\n\t    key: '_getInitialValueForProperty',\n\t    value: function _getInitialValueForProperty(property) {\n\t      if (!this._measureElement) {\n\t        this._measureElement = document.createElement('meta');\n\t        this._measureElement.style.all = 'initial';\n\t        document.head.appendChild(this._measureElement);\n\t      }\n\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t    }\n\t    // replace mixin consumption with variable consumption\n\t\n\t  }, {\n\t    key: '_consumeCssProperties',\n\t    value: function _consumeCssProperties(text) {\n\t      var m = void 0;\n\t      // loop over text until all mixins with defintions have been applied\n\t      while (m = MIXIN_MATCH.exec(text)) {\n\t        var matchText = m[0];\n\t        var mixinName = m[1];\n\t        var idx = m.index;\n\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t        var applyPos = idx + matchText.indexOf('@apply');\n\t        var afterApplyPos = idx + matchText.length;\n\t        // find props defined before this @apply\n\t        var textBeforeApply = text.slice(0, applyPos);\n\t        var textAfterApply = text.slice(afterApplyPos);\n\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t        // use regex match position to replace mixin, keep linear processing time\n\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t        // move regex search to _after_ replacement\n\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t      }\n\t      return text;\n\t    }\n\t    // produce variable consumption at the site of mixin consumption\n\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t    // Example:\n\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\n\t  }, {\n\t    key: '_atApplyToCssProperties',\n\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t      var vars = [];\n\t      var mixinEntry = this._map.get(mixinName);\n\t      // if we depend on a mixin before it is created\n\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t      if (!mixinEntry) {\n\t        this._map.set(mixinName, {});\n\t        mixinEntry = this._map.get(mixinName);\n\t      }\n\t      if (mixinEntry) {\n\t        if (this._currentTemplate) {\n\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t        }\n\t        var p = void 0,\n\t            parts = void 0,\n\t            f = void 0;\n\t        for (p in mixinEntry.properties) {\n\t          f = fallbacks && fallbacks[p];\n\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t          if (f) {\n\t            parts.push(',', f);\n\t          }\n\t          parts.push(')');\n\t          vars.push(parts.join(''));\n\t        }\n\t      }\n\t      return vars.join('; ');\n\t    }\n\t  }, {\n\t    key: '_replaceInitialOrInherit',\n\t    value: function _replaceInitialOrInherit(property, value) {\n\t      var match = INITIAL_INHERIT.exec(value);\n\t      if (match) {\n\t        if (match[1]) {\n\t          // initial\n\t          // replace `initial` with the concrete initial value for this property\n\t          value = ApplyShim._getInitialValueForProperty(property);\n\t        } else {\n\t          // inherit\n\t          // with this purposfully illegal value, the variable will be invalid at\n\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t          // and for inheriting values, will behave similarly\n\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t          value = 'apply-shim-inherit';\n\t        }\n\t      }\n\t      return value;\n\t    }\n\t\n\t    // \"parse\" a mixin definition into a map of properties and values\n\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\n\t  }, {\n\t    key: '_cssTextToMap',\n\t    value: function _cssTextToMap(text) {\n\t      var props = text.split(';');\n\t      var property = void 0,\n\t          value = void 0;\n\t      var out = {};\n\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t        p = props[i];\n\t        if (p) {\n\t          sp = p.split(':');\n\t          // ignore lines that aren't definitions like @media\n\t          if (sp.length > 1) {\n\t            property = sp[0].trim();\n\t            // some properties may have ':' in the value, like data urls\n\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t            out[property] = value;\n\t          }\n\t        }\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_invalidateMixinEntry',\n\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t      for (var elementName in mixinEntry.dependants) {\n\t        if (elementName !== this._currentTemplate) {\n\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_produceCssProperties',\n\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t      var _this3 = this;\n\t\n\t      // handle case where property value is a mixin\n\t      if (valueProperty) {\n\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t          if (value && _this3._map.get(value)) {\n\t            valueMixin = '@apply ' + value + ';';\n\t          }\n\t        });\n\t      }\n\t      if (!valueMixin) {\n\t        return matchText;\n\t      }\n\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t      var combinedProps = mixinValues;\n\t      var mixinEntry = this._map.get(propertyName);\n\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t      if (oldProps) {\n\t        // NOTE: since we use mixin, the map of properties is updated here\n\t        // and this is what we want.\n\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t      } else {\n\t        this._map.set(propertyName, combinedProps);\n\t      }\n\t      var out = [];\n\t      var p = void 0,\n\t          v = void 0;\n\t      // set variables defined by current mixin\n\t      var needToInvalidate = false;\n\t      for (p in combinedProps) {\n\t        v = mixinValues[p];\n\t        // if property not defined by current mixin, set initial\n\t        if (v === undefined) {\n\t          v = 'initial';\n\t        }\n\t        if (oldProps && !(p in oldProps)) {\n\t          needToInvalidate = true;\n\t        }\n\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t      }\n\t      if (needToInvalidate) {\n\t        this._invalidateMixinEntry(mixinEntry);\n\t      }\n\t      if (mixinEntry) {\n\t        mixinEntry.properties = combinedProps;\n\t      }\n\t      // because the mixinMap is global, the mixin might conflict with\n\t      // a different scope's simple variable definition:\n\t      // Example:\n\t      // some style somewhere:\n\t      // --mixin1:{ ... }\n\t      // --mixin2: var(--mixin1);\n\t      // some other element:\n\t      // --mixin1: 10px solid red;\n\t      // --foo: var(--mixin1);\n\t      // In this case, we leave the original variable definition in place.\n\t      if (valueProperty) {\n\t        prefix = matchText + ';' + prefix;\n\t      }\n\t      return prefix + out.join('; ') + ';';\n\t    }\n\t  }]);\n\t  return ApplyShim;\n\t}();\n\t\n\tvar applyShim = new ApplyShim();\n\twindow['ApplyShim'] = applyShim;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar flush = function flush() {};\n\t\n\tif (!nativeShadow) {\n\t  (function () {\n\t    var handler = function handler(mxns) {\n\t      for (var x = 0; x < mxns.length; x++) {\n\t        var mxn = mxns[x];\n\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t          var n = mxn.addedNodes[i];\n\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t            var root = n.getRootNode();\n\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t              // may no longer be in a shadowroot\n\t              var host = root.host;\n\t              if (host) {\n\t                var scope = host.is || host.localName;\n\t                StyleTransformer.dom(n, scope);\n\t              }\n\t            }\n\t          }\n\t        }\n\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t          var _n = mxn.removedNodes[_i];\n\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t            if (classIdx >= 0) {\n\t              // NOTE: relies on the scoping class always being adjacent to the\n\t              // SCOPE_NAME class.\n\t              var _scope = _n.classList[classIdx + 1];\n\t              if (_scope) {\n\t                StyleTransformer.dom(_n, _scope, true);\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var observer = new MutationObserver(handler);\n\t    var startState = 'interactive';\n\t\n\t    var start = function start() {\n\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t    };\n\t    if (window.HTMLImports) {\n\t      window.HTMLImports.whenReady(start);\n\t    } else if (document.readyState === startState) {\n\t      requestAnimationFrame(start);\n\t    } else {\n\t      document.addEventListener('readystatechange', function () {\n\t        if (document.readyState === startState) {\n\t          start();\n\t        }\n\t      });\n\t    }\n\t\n\t    flush = function flush() {\n\t      handler(observer.takeRecords());\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(dfreedm): consider spliting into separate global\n\tvar styleCache = new StyleCache();\n\t\n\tvar ShadyCSS = {\n\t  flush: flush,\n\t  scopeCounter: {},\n\t  nativeShadow: nativeShadow,\n\t  nativeCss: nativeCssVariables,\n\t  nativeCssApply: nativeCssApply,\n\t  _documentOwner: document.documentElement,\n\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t    return name + '-' + id;\n\t  },\n\t  getStyleAst: function getStyleAst(style) {\n\t    return rulesForStyle(style);\n\t  },\n\t  styleAstToString: function styleAstToString(ast) {\n\t    return toCssText(ast);\n\t  },\n\t  _gatherStyles: function _gatherStyles(template) {\n\t    var styles = template.content.querySelectorAll('style');\n\t    var cssText = [];\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var s = styles[i];\n\t      cssText.push(s.textContent);\n\t      s.parentNode.removeChild(s);\n\t    }\n\t    return cssText.join('').trim();\n\t  },\n\t  _getCssBuild: function _getCssBuild(template) {\n\t    var style = template.content.querySelector('style');\n\t    if (!style) {\n\t      return '';\n\t    }\n\t    return style.getAttribute('css-build') || '';\n\t  },\n\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t    if (template._prepared) {\n\t      return;\n\t    }\n\t    template._prepared = true;\n\t    template.name = elementName;\n\t    template.extends = typeExtension;\n\t    templateMap[elementName] = template;\n\t    var cssBuild = this._getCssBuild(template);\n\t    var cssText = this._gatherStyles(template);\n\t    var info = {\n\t      is: elementName,\n\t      extends: typeExtension,\n\t      __cssBuild: cssBuild\n\t    };\n\t    if (!this.nativeShadow) {\n\t      StyleTransformer.dom(template.content, elementName);\n\t    }\n\t    var ast = parse(cssText);\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      applyShim.transformRules(ast, elementName);\n\t    }\n\t    template._styleAst = ast;\n\t\n\t    var ownPropertyNames = [];\n\t    if (!this.nativeCss) {\n\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t    }\n\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t      var root = this.nativeShadow ? template.content : null;\n\t      var placeholder = placeholderMap[elementName];\n\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t      template._style = style;\n\t    }\n\t    template._ownPropertyNames = ownPropertyNames;\n\t  },\n\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t    if (cssText.length) {\n\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t    }\n\t  },\n\t  _prepareHost: function _prepareHost(host) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var typeExtension = void 0;\n\t    if (is !== host.localName) {\n\t      typeExtension = host.localName;\n\t    }\n\t    var placeholder = placeholderMap[is];\n\t    var template = templateMap[is];\n\t    var ast = void 0;\n\t    var ownStylePropertyNames = void 0;\n\t    var cssBuild = void 0;\n\t    if (template) {\n\t      ast = template._styleAst;\n\t      ownStylePropertyNames = template._ownPropertyNames;\n\t      cssBuild = template._cssBuild;\n\t    }\n\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t  },\n\t  applyStyle: function applyStyle(host, overrideProps) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    if (window.CustomStyle) {\n\t      var CS = window.CustomStyle;\n\t      if (CS._documentDirty) {\n\t        CS.findStyles();\n\t        if (!this.nativeCss) {\n\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t        } else if (!this.nativeCssApply) {\n\t          CS._revalidateApplyShim();\n\t        }\n\t        CS.applyStyles();\n\t        CS._documentDirty = false;\n\t      }\n\t    }\n\t    var styleInfo = StyleInfo.get(host);\n\t    if (!styleInfo) {\n\t      styleInfo = this._prepareHost(host);\n\t    }\n\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t    if (this.nativeCss) {\n\t      var template = templateMap[is];\n\t      if (template && template.__applyShimInvalid && template._style) {\n\t        // update template\n\t        applyShim.transformRules(template._styleAst, is);\n\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        // update instance if native shadowdom\n\t        if (this.nativeShadow) {\n\t          var style = host.shadowRoot.querySelector('style');\n\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        }\n\t        styleInfo.styleRules = template._styleAst;\n\t      }\n\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t    } else {\n\t      this._updateProperties(host, styleInfo);\n\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t        // TODO: use caching\n\t        this._applyStyleProperties(host, styleInfo);\n\t      }\n\t    }\n\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t    // note: some elements may not have a root!\n\t    if (root) {\n\t      this._applyToDescendants(root);\n\t    }\n\t  },\n\t  _applyToDescendants: function _applyToDescendants(root) {\n\t    var c$ = root.children;\n\t    for (var i = 0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (c.shadowRoot) {\n\t        this.applyStyle(c);\n\t      }\n\t      this._applyToDescendants(c);\n\t    }\n\t  },\n\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t    var root = node.getRootNode();\n\t    var host = root.host;\n\t    if (host) {\n\t      if (StyleInfo.get(host)) {\n\t        return host;\n\t      } else {\n\t        return this._styleOwnerForNode(host);\n\t      }\n\t    }\n\t    return this._documentOwner;\n\t  },\n\t  _isRootOwner: function _isRootOwner(node) {\n\t    return node === this._documentOwner;\n\t  },\n\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t    // only generate new scope if cached style is not found\n\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t    if (!this.nativeShadow) {\n\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t    }\n\t    if (!cacheEntry) {\n\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t    }\n\t    return style;\n\t  },\n\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t    var owner = this._styleOwnerForNode(host);\n\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t    var props = Object.create(ownerProperties || null);\n\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t    var propertiesMatchingHost = propertyData.properties;\n\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t    StyleProperties.reify(props);\n\t    styleInfo.styleProperties = props;\n\t  },\n\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t    for (var p in overrides) {\n\t      var v = overrides[p];\n\t      // skip override props if they are not truthy or 0\n\t      // in order to fall back to inherited values\n\t      if (v || v === 0) {\n\t        props[p] = v;\n\t      }\n\t    }\n\t  },\n\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t    // remove previous properties\n\t    for (var p in properties) {\n\t      // NOTE: for bc with shim, don't apply null values.\n\t      if (p === null) {\n\t        element.style.removeProperty(p);\n\t      } else {\n\t        element.style.setProperty(p, properties[p]);\n\t      }\n\t    }\n\t  },\n\t  updateStyles: function updateStyles(properties) {\n\t    if (window.CustomStyle) {\n\t      window.CustomStyle._documentDirty = true;\n\t    }\n\t    this.applyStyle(this._documentOwner, properties);\n\t  },\n\t\n\t  /* Custom Style operations */\n\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t    var _this = this;\n\t\n\t    var ast = rulesForStyle(style);\n\t    forEachRule(ast, function (rule) {\n\t      if (nativeShadow) {\n\t        StyleTransformer.normalizeRootSelector(rule);\n\t      } else {\n\t        StyleTransformer.documentRule(rule);\n\t      }\n\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t        applyShim.transformRule(rule);\n\t      }\n\t    });\n\t    if (this.nativeCss) {\n\t      style.textContent = toCssText(ast);\n\t    } else {\n\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t    }\n\t  },\n\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      var ast = rulesForStyle(style);\n\t      applyShim.transformRules(ast);\n\t      style.textContent = toCssText(ast);\n\t    }\n\t  },\n\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t    if (!this.nativeCss) {\n\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t    }\n\t  },\n\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t    var value = void 0;\n\t    if (!this.nativeCss) {\n\t      // element is either a style host, or an ancestor of a style host\n\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t      value = styleInfo.styleProperties[property];\n\t    }\n\t    // fall back to the property value from the computed styling\n\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t    // trim whitespace that can come after the `:` in css\n\t    // example: padding: 2px -> \" 2px\"\n\t    return value.trim();\n\t  },\n\t\n\t  // given an element and a classString, replaces\n\t  // the element's class with the provided classString and adds\n\t  // any necessary ShadyCSS static and property based scoping selectors\n\t  // NOTE: this method is suitable to be called in an environment in which\n\t  // setAttribute('class', ...) and className setter have been overridden so\n\t  // it cannot rely on those methods.\n\t  setElementClass: function setElementClass(element, classString) {\n\t    var _element$classList;\n\t\n\t    // use classList to clear existing classes\n\t    while (element.classList.length) {\n\t      element.classList.remove(element.classList[0]);\n\t    }\n\t    // add user classString\n\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t    // add static scoping: scope by shadyRoot\n\t    var root = element.getRootNode();\n\t    if (root.host) {\n\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t    }\n\t    // add property scoping: scope by special selector\n\t    if (!this.nativeCss) {\n\t      var styleInfo = StyleInfo.get(element);\n\t      if (styleInfo && styleInfo.scopeSelector) {\n\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t      }\n\t    }\n\t  },\n\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t    return StyleInfo.get(node);\n\t  }\n\t};\n\t\n\twindow['ShadyCSS'] = ShadyCSS;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\n\tExample:\n\t<shady-style>\n\t  <style>\n\t  ...\n\t  </style>\n\t</shady-style>\n\t*/\n\t\n\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\n\tvar enqueued = false;\n\t\n\tvar customStyles = [];\n\t\n\tvar hookFn = null;\n\t\n\t/*\n\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\tas all the instances will boot asynchronously after page load.\n\t\n\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t*/\n\tfunction enqueueDocumentValidation() {\n\t  if (enqueued) {\n\t    return;\n\t  }\n\t  enqueued = true;\n\t  if (window.HTMLImports) {\n\t    window.HTMLImports.whenReady(validateDocument);\n\t  } else if (document.readyState === 'complete') {\n\t    requestAnimationFrame(validateDocument);\n\t  } else {\n\t    document.addEventListener('readystatechange', function () {\n\t      if (document.readyState === 'complete') {\n\t        validateDocument();\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t// helps ensure that the first run of validateDocument will actually\n\t// have access to all the custom-style's created via loading imports.\n\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t// then the enqueue immediately calls validateDocument and work that could be\n\t// batched is not.\n\tenqueueDocumentValidation();\n\t\n\tfunction validateDocument() {\n\t  if (enqueued) {\n\t    ShadyCSS$1.updateStyles();\n\t    enqueued = false;\n\t  }\n\t}\n\t\n\tfunction CustomStyle() {\n\t  /*\n\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t  CustomElement polyfill replacement that can be `.call`ed\n\t  */\n\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t  customStyles.push(self);\n\t  enqueueDocumentValidation();\n\t  return self;\n\t}\n\t\n\tObject.defineProperties(CustomStyle, {\n\t  /*\n\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t   The function must take a <style> element as input, and return nothing.\n\t  */\n\t  processHook: {\n\t    get: function get() {\n\t      return hookFn;\n\t    },\n\t    set: function set(fn) {\n\t      hookFn = fn;\n\t      return fn;\n\t    }\n\t  },\n\t  _customStyles: {\n\t    get: function get() {\n\t      return customStyles;\n\t    }\n\t  },\n\t  _documentDirty: {\n\t    get: function get() {\n\t      return enqueued;\n\t    },\n\t    set: function set(value) {\n\t      enqueued = value;\n\t      return value;\n\t    }\n\t  }\n\t});\n\t\n\tCustomStyle.findStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._findStyle();\n\t  }\n\t};\n\t\n\tCustomStyle._revalidateApplyShim = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    var s = customStyles[i];\n\t    if (s._style) {\n\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t    }\n\t  }\n\t};\n\t\n\tCustomStyle.applyStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._applyStyle();\n\t  }\n\t};\n\t\n\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t  'constructor': {\n\t    value: CustomStyle,\n\t    configurable: true,\n\t    writable: true\n\t  }\n\t});\n\t\n\tCustomStyle.prototype._findStyle = function () {\n\t  if (!this._style) {\n\t    var style = this.querySelector('style');\n\t    if (!style) {\n\t      return;\n\t    }\n\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t    // which is referenced with __appliedElement.\n\t    // Also, we must copy over the attributes.\n\t    if (style.__appliedElement) {\n\t      for (var i = 0; i < style.attributes.length; i++) {\n\t        var attr = style.attributes[i];\n\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t      }\n\t    }\n\t    this._style = style.__appliedElement || style;\n\t    if (hookFn) {\n\t      hookFn(this._style);\n\t    }\n\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t  }\n\t};\n\t\n\tCustomStyle.prototype._applyStyle = function () {\n\t  if (this._style) {\n\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t  }\n\t};\n\t\n\twindow.customElements.define('custom-style', CustomStyle);\n\twindow['CustomStyle'] = CustomStyle;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/*\n\tSmall module to load ShadyCSS and CustomStyle together\n\t*/\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadycss.min.js.map\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-web-components/dist/index.js\n// module id = 1\n// module chunks = 0","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('incremental-dom'), require('window-or-global')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n}(this, (function (exports,incrementalDom,root) {\n\nroot = 'default' in root ? root['default'] : root;\n\nfunction keys() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref$enumOnly = _ref.enumOnly;\n  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\n  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n}\n\n// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\nvar assign = (function (obj) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(function (arg) {\n    return keys(arg).forEach(function (name) {\n      return obj[name] = arg[name];\n    });\n  }); // eslint-disable-line no-return-assign\n  return obj;\n});\n\nvar empty = function (val) {\n  return typeof val === 'undefined' || val === null;\n};\n\n/**\n * Attributes value can only be null or string;\n */\nvar toNullOrString = function toNullOrString(val) {\n  return empty(val) ? null : String(val);\n};\n\nfunction create(def) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.unshift({}, def);\n    return assign.apply(undefined, args);\n  };\n}\n\nvar array = create({\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : empty(val) ? null : [val];\n  },\n  default: function _default() {\n    return [];\n  },\n  deserialize: function deserialize(val) {\n    return empty(val) ? null : JSON.parse(val);\n  },\n  serialize: JSON.stringify\n});\n\nvar boolean = create({\n  coerce: function coerce(val) {\n    return !!val;\n  },\n  default: false,\n  // todo: 'false' string must deserialize to false for angular 1.x to work\n  // This breaks one existing test.\n  // deserialize: val => !(val === null || val === 'false'),\n  deserialize: function deserialize(val) {\n    return !(val === null);\n  },\n  serialize: function serialize(val) {\n    return val ? '' : null;\n  }\n});\n\n// defaults empty to 0 and allows NaN\nvar zeroIfEmptyOrNumberIncludesNaN = function zeroIfEmptyOrNumberIncludesNaN(val) {\n  return empty(val) ? 0 : Number(val);\n};\n\nvar number = create({\n  default: 0,\n  coerce: zeroIfEmptyOrNumberIncludesNaN,\n  deserialize: zeroIfEmptyOrNumberIncludesNaN,\n  serialize: toNullOrString\n});\n\nvar string = create({\n  default: '',\n  coerce: toNullOrString,\n  deserialize: toNullOrString,\n  serialize: toNullOrString\n});\n\nvar prop = Object.freeze({\n\tcreate: create,\n\tarray: array,\n\tboolean: boolean,\n\tnumber: number,\n\tstring: string\n});\n\nvar connected = '____skate_connected';\nvar created = '____skate_created';\n\n// DEPRECATED\n//\n// This is the only \"symbol\" that must stay a string. This is because it is\n// relied upon across several versions. We should remove it, but ensure that\n// it's considered a breaking change that whatever version removes it cannot\n// be passed to vdom functions as tag names.\nvar name = '____skate_name';\n\n// Used on the Constructor\nvar ctorCreateInitProps = '____skate_ctor_createInitProps';\nvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\nvar ctorProps = '____skate_ctor_props';\nvar ctorPropsMap = '____skate_ctor_propsMap';\n\n// Used on the Element\nvar props = '____skate_props';\nvar ref$1 = '____skate_ref';\nvar renderer$1 = '____skate_renderer';\nvar rendering = '____skate_rendering';\nvar rendererDebounced = '____skate_rendererDebounced';\nvar updated$1 = '____skate_updated';\n\n// DEPRECTAED\n//\n// We should not be relying on internals for symbols as this creates version\n// coupling. We will move forward with platform agnostic ways of doing this.\n\n\nvar symbols$1 = Object.freeze({\n\tname: name\n});\n\nfunction enter(object, props) {\n  var saved = {};\n  Object.keys(props).forEach(function (key) {\n    saved[key] = object[key];\n    object[key] = props[key];\n  });\n  return saved;\n}\n\nfunction exit(object, saved) {\n  assign(object, saved);\n}\n\n// Decorates a function with a side effect that changes the properties of an\n// object during its execution, and restores them after. There is no error\n// handling here, if the wrapped function throws an error, properties are not\n// restored and all bets are off.\nvar propContext = function (object, props) {\n  return function (func) {\n    return function () {\n      var saved = enter(object, props);\n      var result = func.apply(undefined, arguments);\n      exit(object, saved);\n      return result;\n    };\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/* eslint no-plusplus: 0 */\n\nvar customElements = root.customElements;\nvar HTMLElement = root.HTMLElement;\n\nvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\n// A stack of children that corresponds to the current function helper being\n// executed.\nvar stackChren = [];\n\nvar $skip = '__skip';\nvar $currentEventHandlers = '__events';\nvar $stackCurrentHelperProps = '__props';\n\n// The current function helper in the stack.\nvar stackCurrentHelper = void 0;\n\n// This is used for the Incremental DOM overrides to keep track of what args\n// to pass the main elementOpen() function.\nvar overrideArgs = void 0;\n\n// The number of levels deep after skipping a tree.\nvar skips = 0;\n\nvar noop = function noop() {};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent(elem, ename, newFunc) {\n  var events = elem[$currentEventHandlers];\n\n  if (!events) {\n    events = elem[$currentEventHandlers] = {};\n  }\n\n  // Undefined indicates that there is no listener yet.\n  if (typeof events[ename] === 'undefined') {\n    // We only add a single listener once. Originally this was a workaround for\n    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n    // also a simpler model for binding / unbinding events because you only\n    // have a single handler you need to worry about and a single place where\n    // you only store one event handler\n    elem.addEventListener(ename, function (e) {\n      if (events[ename]) {\n        events[ename].call(this, e);\n      }\n    });\n  }\n\n  // Not undefined indicates that we have set a listener, so default to null.\n  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n}\n\nvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n  // Attributes that shouldn't be applied to the DOM.\n  key: noop,\n  statics: noop,\n\n  // Attributes that *must* be set via a property on all elements.\n  checked: incrementalDom.applyProp,\n  className: incrementalDom.applyProp,\n  disabled: incrementalDom.applyProp,\n  value: incrementalDom.applyProp,\n\n  // Ref handler.\n  ref: function ref(elem, name$$1, value) {\n    elem[ref$1] = value;\n  },\n\n\n  // Skip handler.\n  skip: function skip(elem, name$$1, value) {\n    if (value) {\n      elem[$skip] = true;\n    } else {\n      delete elem[$skip];\n    }\n  }\n}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n  var _ref = customElements.get(elem.localName) || {\n    props: {},\n    prototype: {}\n  };\n\n  var props$$1 = _ref.props;\n  var prototype = _ref.prototype;\n\n  // TODO when refactoring properties to not have to workaround the old\n  // WebKit bug we can remove the \"name in props\" check below.\n  //\n  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n  // elements that set a property that isn't explicitly specified in \"props\"\n  // or \"prototype\" unless it is added to the element explicitly as a\n  // property prior to passing the prop to the vdom function. For example, if\n  // it were added in a lifecycle callback because it wouldn't have been\n  // upgraded yet.\n  //\n  // We prefer setting props, so we do this if there's a property matching\n  // name that was passed. However, certain props on SVG elements are\n  // readonly and error when you try to set them.\n\n  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n    incrementalDom.applyProp(elem, name$$1, value);\n    return;\n  }\n\n  // Explicit false removes the attribute.\n  if (value === false) {\n    applyDefault(elem, name$$1);\n    return;\n  }\n\n  // Handle built-in and custom events.\n  if (name$$1.indexOf('on') === 0) {\n    var firstChar = name$$1[2];\n    var eventName = void 0;\n\n    if (firstChar === '-') {\n      eventName = name$$1.substring(3);\n    } else if (firstChar === firstChar.toUpperCase()) {\n      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n    }\n\n    if (eventName) {\n      applyEvent(elem, eventName, value);\n      return;\n    }\n  }\n\n  applyDefault(elem, name$$1, value);\n}));\n\nfunction resolveTagName(name$$1) {\n  // We return falsy values as some wrapped IDOM functions allow empty values.\n  if (!name$$1) {\n    return name$$1;\n  }\n\n  // We try and return the cached tag name, if one exists.\n  if (name$$1[name]) {\n    return name$$1[name];\n  }\n\n  // If it's a custom element, we get the tag name by constructing it and\n  // caching it.\n  if (name$$1.prototype instanceof HTMLElement) {\n    // eslint-disable-next-line\n    var elem = new name$$1();\n    return name$$1[name] = elem.localName;\n  }\n\n  // Pass all other values through so IDOM gets what it's expecting.\n  return name$$1;\n}\n\n// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n// so it's the only function we need to execute in the context of our attributes.\nvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\nfunction elementOpenStart(tag) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  overrideArgs = [tag, key, statics];\n}\n\nfunction elementOpenEnd() {\n  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n  overrideArgs = null;\n  return node;\n}\n\nfunction wrapIdomFunc(func) {\n  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n  return function wrap() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args[0] = resolveTagName(args[0]);\n    stackCurrentHelper = null;\n    if (typeof args[0] === 'function') {\n      // If we've encountered a function, handle it according to the type of\n      // function that is being wrapped.\n      stackCurrentHelper = args[0];\n      return tnameFuncHandler.apply(undefined, args);\n    } else if (stackChren.length) {\n      // We pass the wrap() function in here so that when it's called as\n      // children, it will queue up for the next stack, if there is one.\n      stackChren[stackChren.length - 1].push([wrap, args]);\n    } else {\n      if (func === elementOpen$1) {\n        if (skips) {\n          return ++skips;\n        }\n\n        var elem = func.apply(undefined, args);\n\n        if (elem[$skip]) {\n          ++skips;\n        }\n\n        return elem;\n      }\n\n      if (func === incrementalDom.elementClose) {\n        if (skips === 1) {\n          incrementalDom.skip();\n        }\n\n        // We only want to skip closing if it's not the last closing tag in the\n        // skipped tree because we keep the element that initiated the skpping.\n        if (skips && --skips) {\n          return;\n        }\n\n        var _elem = func.apply(undefined, args);\n        var ref$$1 = _elem[ref$1];\n\n        // We delete so that it isn't called again for the same element. If the\n        // ref changes, or the element changes, this will be defined again.\n        delete _elem[ref$1];\n\n        // Execute the saved ref after esuring we've cleand up after it.\n        if (typeof ref$$1 === 'function') {\n          ref$$1(_elem);\n        }\n\n        return _elem;\n      }\n\n      // We must call elementOpenStart and elementOpenEnd even if we are\n      // skipping because they queue up attributes and then call elementClose.\n      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n        return func.apply(undefined, args);\n      }\n    }\n  };\n}\n\nfunction newAttr() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (stackCurrentHelper) {\n    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n  } else if (stackChren.length) {\n    stackChren[stackChren.length - 1].push([newAttr, args]);\n  } else {\n    overrideArgs.push(args[0]);\n    overrideArgs.push(args[1]);\n  }\n}\n\nfunction stackOpen(tname, key, statics) {\n  var props$$1 = { key: key, statics: statics };\n\n  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n    attrs[_key3 - 3] = arguments[_key3];\n  }\n\n  for (var a = 0; a < attrs.length; a += 2) {\n    props$$1[attrs[a]] = attrs[a + 1];\n  }\n  tname[$stackCurrentHelperProps] = props$$1;\n  stackChren.push([]);\n}\n\nfunction stackClose(tname) {\n  var chren = stackChren.pop();\n  var props$$1 = tname[$stackCurrentHelperProps];\n  delete tname[$stackCurrentHelperProps];\n  var elemOrFn = tname(props$$1, function () {\n    return chren.forEach(function (args) {\n      return args[0].apply(args, toConsumableArray(args[1]));\n    });\n  });\n  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n}\n\n// Incremental DOM overrides\n// -------------------------\n\n// We must override internal functions that call internal Incremental DOM\n// functions because we can't override the internal references. This means\n// we must roughly re-implement their behaviour. Luckily, they're fairly\n// simple.\nvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\nvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\n// Standard open / closed overrides don't need to reproduce internal behaviour\n// because they are the ones referenced from *End and *Start.\nvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\nvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\n// Ensure we call our overridden functions instead of the internal ones.\nfunction newElementVoid(tag) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  newElementOpen.apply(undefined, [tag].concat(args));\n  return newElementClose(tag);\n}\n\n// Text override ensures their calls can queue if using function helpers.\nvar newText = wrapIdomFunc(incrementalDom.text);\n\n// Convenience function for declaring an Incremental DOM element using\n// hyperscript-style syntax.\nfunction element(tname, attrs) {\n  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\n  // If attributes are a function, then they should be treated as children.\n\n  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    chren[_key5 - 2] = arguments[_key5];\n  }\n\n  if (atype === 'function' || atype === 'string' || atype === 'number') {\n    chren.unshift(attrs);\n  }\n\n  // Ensure the attributes are an object. Null is considered an object so we\n  // have to test for this explicitly.\n  if (attrs === null || atype !== 'object') {\n    attrs = {};\n  }\n\n  // We open the element so we can set attrs after.\n  newElementOpenStart(tname, attrs.key, attrs.statics);\n\n  // Delete so special attrs don't actually get set.\n  delete attrs.key;\n  delete attrs.statics;\n\n  // Set attributes.\n  Object.keys(attrs).forEach(function (name$$1) {\n    return newAttr(name$$1, attrs[name$$1]);\n  });\n\n  // Close before we render the descendant tree.\n  newElementOpenEnd(tname);\n\n  chren.forEach(function (ch) {\n    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n    if (ctype === 'function') {\n      ch();\n    } else if (ctype === 'string' || ctype === 'number') {\n      newText(ch);\n    } else if (Array.isArray(ch)) {\n      ch.forEach(function (sch) {\n        return sch();\n      });\n    }\n  });\n\n  return newElementClose(tname);\n}\n\n// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n// transpiles for JSX (React.createElement() / h).\nfunction builder() {\n  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    tags[_key6] = arguments[_key6];\n  }\n\n  if (tags.length === 0) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return element.bind.apply(element, [null].concat(args));\n    };\n  }\n  return tags.map(function (tag) {\n    return function () {\n      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return element.bind.apply(element, [null, tag].concat(args));\n    };\n  });\n}\n\n\n\nvar vdom = Object.freeze({\n\telement: element,\n\tbuilder: builder,\n\tattr: newAttr,\n\telementClose: newElementClose,\n\telementOpen: newElementOpen,\n\telementOpenEnd: newElementOpenEnd,\n\telementOpenStart: newElementOpenStart,\n\telementVoid: newElementVoid,\n\ttext: newText\n});\n\nfunction createSymbol(description) {\n  return typeof Symbol === 'function' ? Symbol(description) : description;\n}\n\nvar data = function (element) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n};\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\nvar native = (function (fn) {\n  return nativeHints.map(function (hint) {\n    return (fn || '').toString().indexOf([hint]) > -1;\n  }).reduce(function (a, b) {\n    return a || b;\n  });\n});\n\nvar MutationObserver = root.MutationObserver;\n\n\nfunction microtaskDebounce(cbFunc) {\n  var scheduled = false;\n  var i = 0;\n  var cbArgs = [];\n  var elem = document.createElement('span');\n  var observer = new MutationObserver(function () {\n    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n    scheduled = false;\n    cbArgs = null;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = '' + i;\n      i += 1;\n    }\n  };\n}\n\n// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n// polyfill requires that the element be in the document to trigger Mutation\n// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n//\n// The soonest we can set the timeout for in IE is 1 as they have issues when\n// setting to 0.\nfunction taskDebounce(cbFunc) {\n  var scheduled = false;\n  var cbArgs = [];\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n      }, 1);\n    }\n  };\n}\nvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\nvar isFunction = function isFunction(val) {\n  return typeof val === 'function';\n};\nvar isUndefined = function isUndefined(val) {\n  return typeof val === 'undefined';\n};\n\n/**\n * @internal\n * Attributes Manager\n *\n * Postpones attributes updates until when connected.\n */\n\nvar AttributesManager = function () {\n  function AttributesManager(elem) {\n    classCallCheck(this, AttributesManager);\n\n    this.elem = elem;\n    this.connected = false;\n    this.pendingValues = {};\n    this.lastSetValues = {};\n  }\n\n  /**\n   * Called from disconnectedCallback\n   */\n\n\n  createClass(AttributesManager, [{\n    key: 'suspendAttributesUpdates',\n    value: function suspendAttributesUpdates() {\n      this.connected = false;\n    }\n\n    /**\n     * Called from connectedCallback\n     */\n\n  }, {\n    key: 'resumeAttributesUpdates',\n    value: function resumeAttributesUpdates() {\n      var _this = this;\n\n      this.connected = true;\n      var names = Object.keys(this.pendingValues);\n      names.forEach(function (name) {\n        var value = _this.pendingValues[name];\n        // Skip if already cleared\n        if (!isUndefined(value)) {\n          delete _this.pendingValues[name];\n          _this._syncAttrValue(name, value);\n        }\n      });\n    }\n\n    /**\n     * Returns true if the value is different from the one set internally\n     * using setAttrValue()\n     */\n\n  }, {\n    key: 'onAttributeChanged',\n    value: function onAttributeChanged(name, value) {\n      value = toNullOrString(value);\n\n      // A new attribute value voids the pending one\n      this._clearPendingValue(name);\n\n      var changed = this.lastSetValues[name] !== value;\n      this.lastSetValues[name] = value;\n      return changed;\n    }\n\n    /**\n     * Updates or removes the attribute if value === null.\n     *\n     * When the component is not connected the value is saved and\n     * the attribute is only updated when the component is re-connected.\n     */\n\n  }, {\n    key: 'setAttrValue',\n    value: function setAttrValue(name, value) {\n      value = toNullOrString(value);\n\n      this.lastSetValues[name] = value;\n\n      if (this.connected) {\n        this._clearPendingValue(name);\n        this._syncAttrValue(name, value);\n      } else {\n        this.pendingValues[name] = value;\n      }\n    }\n  }, {\n    key: '_syncAttrValue',\n    value: function _syncAttrValue(name, value) {\n      var currAttrValue = toNullOrString(this.elem.getAttribute(name));\n      if (value !== currAttrValue) {\n        if (value === null) {\n          this.elem.removeAttribute(name);\n        } else {\n          this.elem.setAttribute(name, value);\n        }\n      }\n    }\n  }, {\n    key: '_clearPendingValue',\n    value: function _clearPendingValue(name) {\n      if (name in this.pendingValues) {\n        delete this.pendingValues[name];\n      }\n    }\n  }]);\n  return AttributesManager;\n}();\n\n// Only used by getAttrMgr\n\n\nvar $attributesMgr = '____skate_attributesMgr';\n\n/**\n * @internal\n * Returns attribute manager instance for the given Component\n */\nfunction getAttrMgr(elem) {\n  var mgr = elem[$attributesMgr];\n  if (!mgr) {\n    mgr = new AttributesManager(elem);\n    elem[$attributesMgr] = mgr;\n  }\n  return mgr;\n}\n\nvar getOwnPropertyDescriptors = function () {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return keys(obj).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n};\n\nvar dashCase = function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return '' + one + dash + two.toLowerCase();\n  });\n};\n\nfunction error$1(message) {\n  var DEBUG = root.DEBUG;\n\n  if (!isUndefined(DEBUG) && DEBUG) {\n    console.error(message);\n  } else {\n    throw new Error(message);\n  }\n}\n\n/**\n * @internal\n * Property Definition\n *\n * Internal meta data and strategies for a property.\n * Created from the options of a PropOptions config object.\n *\n * Once created a PropDefinition should be treated as immutable and final.\n * 'getPropsMap' function memoizes PropDefinitions by Component's Class.\n *\n * The 'attribute' option is normalized into the 'attrName' property.\n */\n\nvar PropDefinition = function () {\n  function PropDefinition(nameOrSymbol, propOptions) {\n    var _this = this;\n\n    classCallCheck(this, PropDefinition);\n\n    this._name = nameOrSymbol;\n\n    propOptions = propOptions || {};\n\n    // default 'attrName': no linked attribute\n    this.attrName = null;\n\n    // default 'coerce': identity function\n    this.coerce = function (value) {\n      return value;\n    };\n\n    // default 'default': set prop to 'null'\n    this.default = null;\n\n    // default 'deserialize': return attribute's value (string or null)\n    this.deserialize = function (value) {\n      return value;\n    };\n\n    // default 'get': no function\n    this.get = null;\n\n    // 'initial' default: unspecified\n    // 'initial' option is truly optional and it cannot be initialized.\n    // Its presence is tested using: ('initial' in propDef)\n\n    // 'serialize' default: return string value or null\n    this.serialize = function (value) {\n      return empty(value) ? null : String(value);\n    };\n\n    // default 'set': no function\n    this.set = null;\n\n    // Note: option key is always a string (no symbols here)\n    Object.keys(propOptions).forEach(function (option) {\n      var optVal = propOptions[option];\n\n      // Only accept documented options and perform minimal input validation.\n      switch (option) {\n        case 'attribute':\n          _this.attrName = resolveAttrName(optVal, nameOrSymbol);\n          break;\n        case 'coerce':\n        case 'deserialize':\n        case 'get':\n        case 'serialize':\n        case 'set':\n          if (isFunction(optVal)) {\n            _this[option] = optVal;\n          } else {\n            error$1(option + ' must be a function.');\n          }\n          break;\n        case 'default':\n        case 'initial':\n          _this[option] = optVal;\n          break;\n        default:\n          error$1(option + ' is not a valid option. Options are: attribute, initial, default, coerce, deserialize, serialize.');\n          break;\n      }\n    });\n  }\n\n  createClass(PropDefinition, [{\n    key: 'name',\n    get: function get() {\n      return this._name;\n    }\n  }]);\n  return PropDefinition;\n}();\n\nfunction resolveAttrName(attrOption, nameOrSymbol) {\n  if ((typeof nameOrSymbol === 'undefined' ? 'undefined' : _typeof(nameOrSymbol)) === 'symbol') {\n    error$1(nameOrSymbol.toString() + ' symbol property cannot have an attribute.');\n  } else {\n    if (attrOption === true) {\n      return dashCase(String(nameOrSymbol));\n    }\n    if (typeof attrOption === 'string') {\n      return attrOption;\n    }\n  }\n  return null;\n}\n\n/**\n * This is needed to avoid IE11 \"stack size errors\" when creating\n * a new property on the constructor of an HTMLElement\n */\nfunction setCtorNativeProperty(Ctor, propName, value) {\n  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n}\n\n/**\n * Memoizes a map of PropDefinition for the given component class.\n * Keys in the map are the properties name which can a string or a symbol.\n *\n * The map is created from the result of: static get props\n */\nfunction getPropsMap(Ctor) {\n  // Must be defined on constructor and not from a superclass\n  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n    (function () {\n      var props$$1 = Ctor.props || {};\n\n      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n        result[propNameOrSymbol] = new PropDefinition(propNameOrSymbol, props$$1[propNameOrSymbol]);\n        return result;\n      }, {});\n      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n    })();\n  }\n\n  return Ctor[ctorPropsMap];\n}\n\nfunction get$2(elem) {\n  var props$$1 = {};\n\n  keys(getPropsMap(elem.constructor)).forEach(function (propNameOrSymbol) {\n    props$$1[propNameOrSymbol] = elem[propNameOrSymbol];\n  });\n\n  return props$$1;\n}\n\nfunction set$2(elem, newProps) {\n  assign(elem, newProps);\n  if (elem[renderer$1]) {\n    elem[renderer$1]();\n  }\n}\n\nvar props$1 = function (elem, newProps) {\n  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n};\n\nfunction getDefaultValue(elem, propDef) {\n  return typeof propDef.default === 'function' ? propDef.default(elem, { name: propDef.name }) : propDef.default;\n}\n\nfunction getInitialValue(elem, propDef) {\n  return typeof propDef.initial === 'function' ? propDef.initial(elem, { name: propDef.name }) : propDef.initial;\n}\n\nfunction getPropData(elem, name) {\n  var elemData = data(elem, 'props');\n  return elemData[name] || (elemData[name] = {});\n}\n\nfunction createNativePropertyDescriptor(propDef) {\n  var nameOrSymbol = propDef.name;\n\n  var prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.beforeDefineProperty = function (elem) {\n    var propData = getPropData(elem, nameOrSymbol);\n    var attrName = propDef.attrName;\n\n    // Store attribute to property link.\n    if (attrName) {\n      data(elem, 'attributeLinks')[attrName] = nameOrSymbol;\n    }\n\n    // prop value before upgrading\n    var initialValue = elem[nameOrSymbol];\n\n    // Set up initial value if it wasn't specified.\n    var valueFromAttribute = false;\n    if (empty(initialValue)) {\n      if (attrName && elem.hasAttribute(attrName)) {\n        valueFromAttribute = true;\n        initialValue = propDef.deserialize(elem.getAttribute(attrName));\n      } else if ('initial' in propDef) {\n        initialValue = getInitialValue(elem, propDef);\n      } else {\n        initialValue = getDefaultValue(elem, propDef);\n      }\n    }\n\n    initialValue = propDef.coerce(initialValue);\n\n    propData.internalValue = initialValue;\n\n    // Reflect to attribute unless valueFromAttribute\n    if (!valueFromAttribute && attrName && !empty(initialValue)) {\n      var serializedValue = propDef.serialize(initialValue);\n      getAttrMgr(elem).setAttrValue(propDef.attrName, serializedValue);\n    }\n  };\n\n  prop.get = function get() {\n    var propData = getPropData(this, nameOrSymbol);\n    var internalValue = propData.internalValue;\n\n    return propDef.get ? propDef.get(this, { name: nameOrSymbol, internalValue: internalValue }) : internalValue;\n  };\n\n  prop.set = function set(newValue) {\n    var propData = getPropData(this, nameOrSymbol);\n\n    var useDefaultValue = empty(newValue);\n    if (useDefaultValue) {\n      newValue = getDefaultValue(this, propDef);\n    }\n\n    newValue = propDef.coerce(newValue);\n\n    if (propDef.set) {\n      var oldValue = propData.oldValue;\n\n\n      if (empty(oldValue)) {\n        oldValue = null;\n      }\n      var changeData = { name: nameOrSymbol, newValue: newValue, oldValue: oldValue };\n      propDef.set(this, changeData);\n    }\n\n    // Queue a re-render.\n    this[rendererDebounced](this);\n\n    // Update prop data so we can use it next time.\n    propData.internalValue = propData.oldValue = newValue;\n\n    // Link up the attribute.\n    if (propDef.attrName && !propData.settingProp) {\n      // Note: setting the prop to empty implies the default value\n      // and therefore no attribute should be present!\n      var serializedValue = useDefaultValue ? null : propDef.serialize(newValue);\n      getAttrMgr(this).setAttrValue(propDef.attrName, serializedValue);\n    }\n  };\n\n  return prop;\n}\n\nvar objectIs = (function (x, y) {\n  if (Object.is) {\n    return Object.is(x, y);\n  }\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n});\n\nvar HTMLElement$1 = root.HTMLElement || function () {\n  function _class() {\n    classCallCheck(this, _class);\n  }\n\n  return _class;\n}();\nvar _prevName = createSymbol('prevName');\nvar _prevOldValue = createSymbol('prevOldValue');\nvar _prevNewValue = createSymbol('prevNewValue');\n\nfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n}\n\n// TODO remove when not catering to Safari < 10.\nfunction createNativePropertyDescriptors(Ctor) {\n  var propDefs = getPropsMap(Ctor);\n  return keys(propDefs).reduce(function (propDescriptors, propName) {\n    propDescriptors[propName] = createNativePropertyDescriptor(propDefs[propName]);\n    return propDescriptors;\n  }, {});\n}\n\n// TODO refactor when not catering to Safari < 10.\n//\n// We should be able to simplify this where all we do is Object.defineProperty().\nfunction createInitProps(Ctor) {\n  var propDescriptors = createNativePropertyDescriptors(Ctor);\n\n  return function (elem) {\n    keys(propDescriptors).forEach(function (name$$1) {\n      var propDescriptor = propDescriptors[name$$1];\n      propDescriptor.beforeDefineProperty(elem);\n\n      // We check here before defining to see if the prop was specified prior\n      // to upgrading.\n      var hasPropBeforeUpgrading = name$$1 in elem;\n\n      // This is saved prior to defining so that we can set it after it it was\n      // defined prior to upgrading. We don't want to invoke the getter if we\n      // don't need to, so we only get the value if we need to re-sync.\n      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name$$1, propDescriptor);\n\n      // DEPRECATED\n      //\n      // We'll be removing get / set callbacks on properties. Use the\n      // updatedCallback() instead.\n      //\n      // We re-set the prop if it was specified prior to upgrading because we\n      // need to ensure set() is triggered both in polyfilled environments and\n      // in native where the definition may be registerd after elements it\n      // represents have already been created.\n      if (hasPropBeforeUpgrading) {\n        elem[name$$1] = valueBeforeUpgrading;\n      }\n    });\n  };\n}\n\nvar _class2 = function (_HTMLElement) {\n  inherits(_class2, _HTMLElement);\n  createClass(_class2, null, [{\n    key: 'observedAttributes',\n\n    /**\n     * Returns unique attribute names configured with props and\n     * those set on the Component constructor if any\n     */\n    get: function get() {\n      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n      var propDefs = getPropsMap(this);\n\n      // Use Object.keys to skips symbol props since they have no linked attributes\n      var attrsFromLinkedProps = Object.keys(propDefs).map(function (propName) {\n        return propDefs[propName].attrName;\n      }).filter(Boolean);\n\n      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n      return all.filter(function (item, index) {\n        return all.indexOf(item) === index;\n      });\n    },\n    set: function set(value) {\n      value = Array.isArray(value) ? value : [];\n      setCtorNativeProperty(this, 'observedAttributes', value);\n    }\n\n    // Returns superclass props overwritten with this Component props\n\n  }, {\n    key: 'props',\n    get: function get() {\n      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n    },\n    set: function set(value) {\n      setCtorNativeProperty(this, ctorProps, value);\n    }\n\n    // Passing args is designed to work with document-register-element. It's not\n    // necessary for the webcomponents/custom-element polyfill.\n\n  }]);\n\n  function _class2() {\n    var _ref;\n\n    classCallCheck(this, _class2);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\n\n    var constructor = _this.constructor;\n\n    // Used for the ready() function so it knows when it can call its callback.\n\n    _this[created] = true;\n\n    // TODO refactor to not cater to Safari < 10. This means we can depend on\n    // built-in property descriptors.\n    // Must be defined on constructor and not from a superclass\n    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n    }\n\n    // Set up a renderer that is debounced for property sets to call directly.\n    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\n    // Set up property lifecycle.\n    var propDefsCount = keys(getPropsMap(constructor)).length;\n    if (propDefsCount && constructor[ctorCreateInitProps]) {\n      constructor[ctorCreateInitProps](_this);\n    }\n\n    // DEPRECATED\n    //\n    // static render()\n    // Note that renderCallback is an optional method!\n    if (!_this.renderCallback && constructor.render) {\n      _this.renderCallback = constructor.render.bind(constructor, _this);\n    }\n\n    // DEPRECATED\n    //\n    // static created()\n    //\n    // Props should be set up before calling this.\n    var created$$1 = constructor.created;\n\n    if (isFunction(created$$1)) {\n      created$$1(_this);\n    }\n\n    // DEPRECATED\n    //\n    // Feature has rarely been used.\n    //\n    // Created should be set before invoking the ready listeners.\n    var elemData = data(_this);\n    var readyCallbacks = elemData.readyCallbacks;\n    if (readyCallbacks) {\n      readyCallbacks.forEach(function (cb) {\n        return cb(_this);\n      });\n      delete elemData.readyCallbacks;\n    }\n    return _this;\n  }\n\n  // Custom Elements v1\n\n\n  createClass(_class2, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      // Reflect attributes pending values\n      getAttrMgr(this).resumeAttributesUpdates();\n\n      // Used to check whether or not the component can render.\n      this[connected] = true;\n\n      // Render!\n      this[rendererDebounced]();\n\n      // DEPRECATED\n      //\n      // static attached()\n      var attached = this.constructor.attached;\n\n      if (isFunction(attached)) {\n        attached(this);\n      }\n\n      // DEPRECATED\n      //\n      // We can remove this once all browsers support :defined.\n      this.setAttribute('defined', '');\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      // Suspend updating attributes until re-connected\n      getAttrMgr(this).suspendAttributesUpdates();\n\n      // Ensures the component can't be rendered while disconnected.\n      this[connected] = false;\n\n      // DEPRECATED\n      //\n      // static detached()\n      var detached = this.constructor.detached;\n\n      if (isFunction(detached)) {\n        detached(this);\n      }\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n      // Polyfill calls this twice.\n      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n        return;\n      }\n\n      // Set data so we can prevent double calling if the polyfill.\n      this[_prevName] = name$$1;\n      this[_prevOldValue] = oldValue;\n      this[_prevNewValue] = newValue;\n\n      var propNameOrSymbol = data(this, 'attributeLinks')[name$$1];\n      if (propNameOrSymbol) {\n        var changedExternally = getAttrMgr(this).onAttributeChanged(name$$1, newValue);\n        if (changedExternally) {\n          // Sync up the property.\n          var propDef = getPropsMap(this.constructor)[propNameOrSymbol];\n          var newPropVal = newValue !== null && propDef.deserialize ? propDef.deserialize(newValue) : newValue;\n\n          var propData = data(this, 'props')[propNameOrSymbol];\n          propData.settingProp = true;\n          this[propNameOrSymbol] = newPropVal;\n          propData.settingProp = false;\n        }\n      }\n\n      // DEPRECATED\n      //\n      // static attributeChanged()\n      var attributeChanged = this.constructor.attributeChanged;\n\n      if (isFunction(attributeChanged)) {\n        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n      }\n    }\n\n    // Skate\n\n  }, {\n    key: 'updatedCallback',\n    value: function updatedCallback(prevProps) {\n      return this.constructor.updated(this, prevProps);\n    }\n\n    // Skate\n\n  }, {\n    key: 'renderedCallback',\n    value: function renderedCallback() {\n      return this.constructor.rendered(this);\n    }\n\n    // Skate\n    //\n    // Maps to the static renderer() callback. That logic should be moved here\n    // when that is finally removed.\n    // todo: finalize how to support different rendering strategies.\n\n  }, {\n    key: 'rendererCallback',\n    value: function rendererCallback() {\n      // todo: cannot move code here because tests expects renderer function to still exist on constructor!\n      return this.constructor.renderer(this);\n    }\n\n    // Skate\n    // @internal\n    // Invokes the complete render lifecycle.\n\n  }, {\n    key: renderer$1,\n    value: function value() {\n      if (this[rendering] || !this[connected]) {\n        return;\n      }\n\n      // Flag as rendering. This prevents anything from trying to render - or\n      // queueing a render - while there is a pending render.\n      this[rendering] = true;\n      if (this[updated$1]() && isFunction(this.renderCallback)) {\n        this.rendererCallback();\n        this.renderedCallback();\n      }\n\n      this[rendering] = false;\n    }\n\n    // Skate\n    // @internal\n    // Calls the updatedCallback() with previous props.\n\n  }, {\n    key: updated$1,\n    value: function value() {\n      var prevProps = this[props];\n      this[props] = props$1(this);\n      return this.updatedCallback(prevProps);\n    }\n\n    // Skate\n\n  }], [{\n    key: 'extend',\n    value: function extend() {\n      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n      // Create class for the user.\n      var Ctor = function (_Base) {\n        inherits(Ctor, _Base);\n\n        function Ctor() {\n          classCallCheck(this, Ctor);\n          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n        }\n\n        return Ctor;\n      }(Base);\n\n      // For inheriting from the object literal.\n\n\n      var opts = getOwnPropertyDescriptors(definition);\n      var prot = getOwnPropertyDescriptors(definition.prototype);\n\n      // Prototype is non configurable (but is writable).\n      delete opts.prototype;\n\n      // Pass on static and instance members from the definition.\n      Object.defineProperties(Ctor, opts);\n      Object.defineProperties(Ctor.prototype, prot);\n\n      return Ctor;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Stubbed in case any subclasses are calling it.\n\n  }, {\n    key: 'rendered',\n    value: function rendered() {}\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'renderer',\n    value: function renderer(elem) {\n      if (!elem.shadowRoot) {\n        elem.attachShadow({ mode: 'open' });\n      }\n      incrementalDom.patchInner(elem.shadowRoot, function () {\n        var possibleFn = elem.renderCallback();\n        if (isFunction(possibleFn)) {\n          possibleFn();\n        } else if (Array.isArray(possibleFn)) {\n          possibleFn.forEach(function (fn) {\n            if (isFunction(fn)) {\n              fn();\n            }\n          });\n        }\n      });\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to updatedCallback() before removing.\n\n  }, {\n    key: 'updated',\n    value: function updated(elem, prevProps) {\n      // short-circuits if this is the first time\n      if (!prevProps) {\n        return true;\n      }\n\n      // Use getAllKeys to include all props names and Symbols\n      var allKeys = keys(prevProps);\n\n      // Use classic loop because 'for ... of' skips symbols\n      for (var i = 0; i < allKeys.length; i++) {\n        var nameOrSymbol = allKeys[i];\n\n        // Object.is (NaN is equal NaN)\n        if (!objectIs(prevProps[nameOrSymbol], elem[nameOrSymbol])) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }]);\n  return _class2;\n}(HTMLElement$1);\n\nfunction uniqueId(prefix) {\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    // eslint-disable-next-line no-mixed-operators\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return (prefix || 'x') + '-' + rand;\n}\n\nvar define = function () {\n  var customElements = root.customElements;\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var name$$1 = args[0];\n  var Ctor = args[1];\n\n\n  if (!customElements) {\n    throw new Error('Skate requires native custom element support or a polyfill.');\n  }\n\n  // Support passing an anonymous definition.\n  if (args.length === 1) {\n    // We are checking string for now, but once we remove the ability to pass\n    // an object literal, we can change this to check \"function\" and invert the\n    // blocks of logic.\n    if (typeof name$$1 === 'string') {\n      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n    } else {\n      Ctor = name$$1;\n      name$$1 = uniqueId();\n    }\n  }\n\n  // Ensure there's no conflicts.\n  if (customElements.get(name$$1)) {\n    name$$1 = uniqueId(name$$1);\n  }\n\n  // DEPRECATED\n  //\n  // Object literals.\n  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n    Ctor = _class2.extend(Ctor);\n  }\n\n  // This allows us to check this before instantiating the custom element to\n  // find its name from the constructor in the vdom module, thus improving\n  // performance but still falling back to a robust method.\n  Ctor[name] = name$$1;\n\n  // Sipmle define. Not supporting customised built-ins yet.\n  customElements.define(name$$1, Ctor);\n\n  // The spec doesn't return but this allows for a simpler, more concise API.\n  return Ctor;\n};\n\nvar Event = function (TheEvent) {\n  if (TheEvent) {\n    try {\n      new TheEvent('emit-init'); // eslint-disable-line no-new\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return TheEvent;\n}(root.Event);\n\nfunction createCustomEvent(name) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var detail = opts.detail;\n\n  delete opts.detail;\n\n  var e = void 0;\n  if (Event) {\n    e = new Event(name, opts);\n    Object.defineProperty(e, 'detail', { value: detail });\n  } else {\n    e = document.createEvent('CustomEvent');\n    Object.defineProperty(e, 'composed', { value: opts.composed });\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n  }\n  return e;\n}\n\nvar emit = function (elem, name) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opts.bubbles === undefined) {\n    opts.bubbles = true;\n  }\n  if (opts.cancelable === undefined) {\n    opts.cancelable = true;\n  }\n  if (opts.composed === undefined) {\n    opts.composed = true;\n  }\n  return elem.dispatchEvent(createCustomEvent(name, opts));\n};\n\nfunction getValue(elem) {\n  var type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nvar link = function (elem, target) {\n  return function (e) {\n    var value = getValue(e.target);\n    var localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      var parts = localTarget.split('.');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n    } else {\n      props$1(elem, defineProperty({}, localTarget, value));\n    }\n  };\n};\n\nvar ready = function (elem, done) {\n  var info = data(elem);\n  if (elem[created]) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n};\n\nvar h = builder();\n\nexports.Component = _class2;\nexports.define = define;\nexports.emit = emit;\nexports.h = h;\nexports.link = link;\nexports.prop = prop;\nexports.props = props$1;\nexports.ready = ready;\nexports.symbols = symbols$1;\nexports.vdom = vdom;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs/dist/index.js\n// module id = 2\n// module chunks = 0","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/incremental-dom/dist/incremental-dom-cjs.js\n// module id = 3\n// module chunks = 0","'use strict'\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n  (typeof global === 'object' && global.global === global && global) ||\n  this\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/window-or-global/lib/index.js\n// module id = 4\n// module chunks = 0","import cssBase from 'todomvc-common/base.css';\nimport cssApp from 'todomvc-app-css/index.css';\n\nconst { head } = document;\nconst cssBaseStyle = document.createElement('style');\nconst cssAppStyle = document.createElement('style');\n\ncssBaseStyle.textContent = cssBase.toString();\ncssAppStyle.textContent = cssApp.toString();\n\nhead.appendChild(cssBaseStyle);\nhead.appendChild(cssAppStyle);\n\nexport default cssBase.toString() + cssApp.toString();\nexport const classes = { ...cssBase.locals, ...cssApp.locals };\n\n\n\n// WEBPACK FOOTER //\n// ./src/style.js","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"hr{margin:20px 0;border:0;border-top:1px dashed #c5c5c5;border-bottom:1px dashed #f7f7f7}.cPEPub0maVFxkzbgWUVOd a{font-weight:400;text-decoration:none;color:#b83f45}.cPEPub0maVFxkzbgWUVOd a:hover{text-decoration:underline;color:#787e7e}.cPEPub0maVFxkzbgWUVOd h3,.cPEPub0maVFxkzbgWUVOd h4,.cPEPub0maVFxkzbgWUVOd h5{margin:10px 0;font-weight:500;line-height:1.2;color:#000}.cPEPub0maVFxkzbgWUVOd h3{font-size:24px}.cPEPub0maVFxkzbgWUVOd h4{font-size:18px}.cPEPub0maVFxkzbgWUVOd h5{margin-bottom:0;font-size:14px}.cPEPub0maVFxkzbgWUVOd ul{padding:0;margin:0 0 30px 25px}.cPEPub0maVFxkzbgWUVOd li{line-height:20px}.cPEPub0maVFxkzbgWUVOd p{font-size:15px;font-weight:300;line-height:1.3;margin-top:0;margin-bottom:0}#_3-nj88w-cbLlFAkd9E0Nbc{display:none}._2L69OI9oxKrr_A0PkWO2KF{border:none;margin:20px 0 60px}._2L69OI9oxKrr_A0PkWO2KF p{font-style:italic}._2L69OI9oxKrr_A0PkWO2KF p:before{content:'\\\\201C';font-size:50px;opacity:.15;position:absolute;top:-20px;left:3px}._2L69OI9oxKrr_A0PkWO2KF p:after{content:'\\\\201D';font-size:50px;opacity:.15;position:absolute;bottom:-42px;right:3px}._2L69OI9oxKrr_A0PkWO2KF footer{position:absolute;bottom:-40px;right:0}._2L69OI9oxKrr_A0PkWO2KF footer img{border-radius:3px}._2L69OI9oxKrr_A0PkWO2KF footer a{margin-left:5px;vertical-align:middle}._1nt1kCjSYEPZou23lObNdv{position:relative;padding:10px;background:rgba(0,0,0,.04);border-radius:5px}._1nt1kCjSYEPZou23lObNdv:after{content:'';position:absolute;top:100%;right:30px;border:13px solid transparent;border-top-color:rgba(0,0,0,.04)}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{position:absolute;width:272px;top:8px;left:-300px;padding:10px;border-radius:5px;background-color:hsla(0,0%,100%,.6);transition-property:left;transition-duration:.5s}@media (min-width:899px){._2vLQrIvSjobb3988bLfSTa{width:auto;padding-left:300px}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{left:8px}}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\"issue-count\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\"issueCount\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\"speech-bubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\"speechBubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\"learn-bar\": \"_2vLQrIvSjobb3988bLfSTa\",\n\t\"learnBar\": \"_2vLQrIvSjobb3988bLfSTa\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/todomvc-common/base.css\n// module id = 6\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 7\n// module chunks = 0","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body,button,html{margin:0;padding:0}button{border:0;background:none;font-size:100%;vertical-align:baseline;font-family:inherit;font-weight:inherit;color:inherit;-webkit-appearance:none;appearance:none;-webkit-font-smoothing:antialiased}body,button{-moz-osx-font-smoothing:grayscale}body{font:14px Helvetica Neue,Helvetica,Arial,sans-serif;line-height:1.4em;background:#f5f5f5;color:#4d4d4d;min-width:230px;max-width:550px;margin:0 auto;-webkit-font-smoothing:antialiased;font-weight:300}:focus{outline:0}.RBzyqGlIYFAdozfNAWX9T{display:none}._2lTeO9Nfd9StmHCibrKyDn{background:#fff;margin:130px 0 40px;position:relative;box-shadow:0 2px 4px 0 rgba(0,0,0,.2),0 25px 50px 0 rgba(0,0,0,.1)}._2lTeO9Nfd9StmHCibrKyDn input::-webkit-input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::-moz-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn h1{position:absolute;top:-155px;width:100%;font-size:100px;font-weight:100;text-align:center;color:rgba(175,47,47,.15);-webkit-text-rendering:optimizeLegibility;-moz-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility}._3RmQY0IMcqwS7R81Tj0dlC,.vdff5WcLi7yBBYDjtZljm{position:relative;margin:0;width:100%;font-size:24px;font-family:inherit;font-weight:inherit;line-height:1.4em;border:0;color:inherit;padding:6px;border:1px solid #999;box-shadow:inset 0 -1px 5px 0 rgba(0,0,0,.2);box-sizing:border-box;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.vdff5WcLi7yBBYDjtZljm{padding:16px 16px 16px 60px;border:none;background:rgba(0,0,0,.003);box-shadow:inset 0 -2px 1px rgba(0,0,0,.03)}._3dnsc4idur8-yk5Sjjq6VG{position:relative;z-index:2;border-top:1px solid #e6e6e6}label[for=toggle-all]{display:none}.DG0VaCEN4BXUysJd_tTIb{position:absolute;top:-55px;left:-12px;width:60px;height:34px;text-align:center;border:none}.DG0VaCEN4BXUysJd_tTIb:before{content:'\\\\276F';font-size:22px;color:#e6e6e6;padding:10px 27px}.DG0VaCEN4BXUysJd_tTIb:checked:before{color:#737373}._1p_AB3iiKNbxBsOlJi5CVw{margin:0;padding:0;list-style:none}._1p_AB3iiKNbxBsOlJi5CVw li{position:relative;font-size:24px;border-bottom:1px solid #ededed}._1p_AB3iiKNbxBsOlJi5CVw li:last-child{border-bottom:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm{border-bottom:none;padding:0}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm ._3RmQY0IMcqwS7R81Tj0dlC{display:block;width:506px;padding:12px 16px;margin:0 0 0 43px}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm .oksgs4_M9fAGjexFoJHTE{display:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{text-align:center;width:40px;height:auto;position:absolute;top:0;bottom:0;margin:auto 0;border:none;-webkit-appearance:none;appearance:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#ededed\\\" stroke-width=\\\"3\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:checked:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#bddad5\\\" stroke-width=\\\"3\\\"/><path fill=\\\"#5dc2af\\\" d=\\\"M72 25L42 71 27 56l-4 4 20 20 34-52z\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li label{word-break:break-all;padding:15px 60px 15px 15px;margin-left:45px;display:block;line-height:1.2;transition:color .4s}._1p_AB3iiKNbxBsOlJi5CVw li._29S5oJEhfUYjuw83RXIvg0 label{color:#d9d9d9;text-decoration:line-through}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE{display:none;position:absolute;top:0;right:10px;bottom:0;width:40px;height:40px;margin:auto 0;font-size:30px;color:#cc9a9a;margin-bottom:11px;transition:color .2s ease-out}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:hover{color:#af5b5e}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:after{content:'\\\\D7'}._1p_AB3iiKNbxBsOlJi5CVw li:hover ._3dDZq0iA7OOgE8KkLYlAeE{display:block}._1p_AB3iiKNbxBsOlJi5CVw li ._3RmQY0IMcqwS7R81Tj0dlC{display:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm:last-child{margin-bottom:-1px}.OfZp78rLkg_PWvZV9RYDG{color:#777;padding:10px 15px;height:20px;text-align:center;border-top:1px solid #e6e6e6}.OfZp78rLkg_PWvZV9RYDG:before{content:'';position:absolute;right:0;bottom:0;left:0;height:50px;overflow:hidden;box-shadow:0 1px 1px rgba(0,0,0,.2),0 8px 0 -3px #f6f6f6,0 9px 1px -3px rgba(0,0,0,.2),0 16px 0 -6px #f6f6f6,0 17px 2px -6px rgba(0,0,0,.2)}._1r5RuM5EHD-zS8b-wG0XPc{float:left;text-align:left}._1r5RuM5EHD-zS8b-wG0XPc strong{font-weight:300}._2tY47NKf597SqoScbkboy0{margin:0;padding:0;list-style:none;position:absolute;right:0;left:0}._2tY47NKf597SqoScbkboy0 li{display:inline}._2tY47NKf597SqoScbkboy0 li a{color:inherit;margin:3px;padding:3px 7px;text-decoration:none;border:1px solid transparent;border-radius:3px}._2tY47NKf597SqoScbkboy0 li a:hover{border-color:rgba(175,47,47,.1)}._2tY47NKf597SqoScbkboy0 li a.a8u8grJpMWz2FTlLtocrT{border-color:rgba(175,47,47,.2)}._1uOFz1y8zCB-ylF3BS8V7J,html ._1uOFz1y8zCB-ylF3BS8V7J:active{float:right;position:relative;line-height:20px;text-decoration:none;cursor:pointer}._1uOFz1y8zCB-ylF3BS8V7J:hover{text-decoration:underline}._3qrb6fjG3vwl0RExKf3l_q{margin:65px auto 0;color:#bfbfbf;font-size:10px;text-shadow:0 1px 0 hsla(0,0%,100%,.5);text-align:center}._3qrb6fjG3vwl0RExKf3l_q p{line-height:1}._3qrb6fjG3vwl0RExKf3l_q a{color:inherit;text-decoration:none;font-weight:400}._3qrb6fjG3vwl0RExKf3l_q a:hover{text-decoration:underline}@media screen and (-webkit-min-device-pixel-ratio:0){._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5,.DG0VaCEN4BXUysJd_tTIb{background:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{height:40px}.DG0VaCEN4BXUysJd_tTIb{-webkit-transform:rotate(90deg);transform:rotate(90deg);-webkit-appearance:none;appearance:none}}@media (max-width:430px){.OfZp78rLkg_PWvZV9RYDG{height:50px}._2tY47NKf597SqoScbkboy0{bottom:10px}}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\"new-todo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\"newTodo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\"toggle-all\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\"toggleAll\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\"todo-list\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\"todoList\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\"todo-count\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\"todoCount\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\"clear-completed\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\"clearCompleted\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\",\n\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/todomvc-app-css/index.css\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}