{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap af0e895bf3974cd20b10","webpack:///./src/index.js","webpack:///./~/skatejs-web-components/dist/index.js","webpack:///./~/skatejs/dist/index.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///./~/window-or-global/lib/index.js","webpack:///./src/style.js","webpack:///./~/todomvc-common/base.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/todomvc-app-css/index.css"],"names":["window","customElements","getCompleted","todos","filter","todo","isCompleted","getPlural","count","getTodoMode","isEditing","editing","completed","TodoApp","handleChange","e","target","checked","todoIndex","parseFloat","getAttribute","map","currentTodoIndex","handleClear","handleRemove","preventDefault","handleSubmit","concat","description","currentValue","handleToggle","todosLength","length","todosCompletedLength","incompleteTodosLength","todoapp","header","newTodo","main","toggleAll","todoList","view","toggle","destroy","edit","footer","todoCount","clearCompleted","info","props","string","array","define","document","head","cssBaseStyle","createElement","cssAppStyle","textContent","toString","appendChild","classes","locals"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;ACpCA;;AACA;;AACA;;;;;;;;;;gfAJA;;eAM2BA,M;KAAnBC,c,WAAAA,c;;;AAER,UAASC,YAAT,CAAuBC,KAAvB,EAA8B;AAC5B,UAAOA,MAAMC,MAAN,CAAa;AAAA,YAAQC,KAAKC,WAAb;AAAA,IAAb,CAAP;AACD;;AAED,UAASC,SAAT,CAAoBC,KAApB,EAA2B;AACzB,UAAOA,UAAU,CAAV,GAAc,EAAd,GAAmB,GAA1B;AACD;;AAED,UAASC,WAAT,CAAsBJ,IAAtB,EAA4B;AAC1B,OAAIA,KAAKK,SAAT,EAAoB;AAClB,YAAO,eAAQC,OAAf;AACD;;AAED,OAAIN,KAAKC,WAAT,EAAsB;AACpB,YAAO,eAAQM,SAAf;AACD;;AAED,UAAO,EAAP;AACD;;KAEKC,O;;;;;;;;;;;;;;yLAKJC,Y,GAAe,UAACC,CAAD,EAAO;AAAA;AAAA,WACZZ,KADY,UACZA,KADY;AAAA,WAEZa,MAFY,GAEmBD,CAFnB,CAEZC,MAFY;AAAA,WAEMC,OAFN,GAEmBF,CAFnB,CAEJC,MAFI,CAEMC,OAFN;;AAGpB,WAAMC,YAAYC,WAAWH,OAAOI,YAAP,CAAoB,iBAApB,CAAX,CAAlB;AACA,aAAKjB,KAAL,GAAaA,MAAMkB,GAAN,CAAU,UAAChB,IAAD,EAAOiB,gBAAP,EAA4B;AACjD,aAAIA,qBAAqBJ,SAAzB,EAAoC;AAClCb,gBAAKC,WAAL,GAAmBW,OAAnB;AACD;AACD,gBAAOZ,IAAP;AACD,QALY,CAAb;AAMD,M,QACDkB,W,GAAc,YAAM;AAClB,aAAKpB,KAAL,GAAa,MAAKA,KAAL,CAAWC,MAAX,CAAkB;AAAA,gBAAQ,CAACC,KAAKC,WAAd;AAAA,QAAlB,CAAb;AACD,M,QACDkB,Y,GAAe,UAACT,CAAD,EAAO;AACpB,WAAMG,YAAYC,WAAWJ,EAAEC,MAAF,CAASI,YAAT,CAAsB,iBAAtB,CAAX,CAAlB;AACAL,SAAEU,cAAF;AACA,aAAKtB,KAAL,GAAa,MAAKA,KAAL,CAAWC,MAAX,CAAkB,UAACC,IAAD,EAAOiB,gBAAP;AAAA,gBAA4BA,qBAAqBJ,SAAjD;AAAA,QAAlB,CAAb;AACD,M,QACDQ,Y,GAAe,UAACX,CAAD,EAAO;AACpBA,SAAEU,cAAF;AACA,aAAKtB,KAAL,GAAa,MAAKA,KAAL,CAAWwB,MAAX,CAAkB;AAC7BrB,sBAAa,KADgB;AAE7BI,oBAAW,KAFkB;AAG7BkB,sBAAa,MAAKC;AAHW,QAAlB,CAAb;AAKA,aAAKA,YAAL,GAAoB,EAApB;AACD,M,QACDC,Y,GAAe,UAACf,CAAD,EAAO;AAAA,WACFE,OADE,GACYF,CADZ,CACZC,MADY,CACFC,OADE;;AAEpB,aAAKd,KAAL,GAAa,MAAKA,KAAL,CAAWkB,GAAX,CAAe,gBAAQ;AAClChB,cAAKC,WAAL,GAAmBW,OAAnB;AACA,gBAAOZ,IAAP;AACD,QAHY,CAAb;AAID,M;;;;;sCACiB;AAAA,WAEdwB,YAFc,GASZ,IATY,CAEdA,YAFc;AAAA,WAGdf,YAHc,GASZ,IATY,CAGdA,YAHc;AAAA,WAIdS,WAJc,GASZ,IATY,CAIdA,WAJc;AAAA,WAKdC,YALc,GASZ,IATY,CAKdA,YALc;AAAA,WAMdM,YANc,GASZ,IATY,CAMdA,YANc;AAAA,WAOdJ,YAPc,GASZ,IATY,CAOdA,YAPc;AAAA,WAQdvB,KARc,GASZ,IATY,CAQdA,KARc;AAAA,WAUA4B,WAVA,GAUgB5B,KAVhB,CAUR6B,MAVQ;;AAAA,2BAWyB9B,aAAaC,KAAb,CAXzB;AAAA,WAWA8B,oBAXA,iBAWRD,MAXQ;;AAYhB,WAAME,wBAAwBH,cAAcE,oBAA5C;;AAEA,cAAO,CACL;AAAA;AAAA;AAAA;AAAA,QADK,EAEL;AAAA;AAAA,WAAS,SAAO,eAAQE,OAAxB;AACE;AAAA;AAAA,aAAQ,SAAO,eAAQC,MAAvB;AACE;AAAA;AAAA;AAAA;AAAA,YADF;AAEE;AAAA;AAAA,eAAM,UAAUV,YAAhB;AACE;AACE,8BADF;AAEE,wBAAO,eAAQW,OAFjB;AAGE,qBAAK,cAHP;AAIE,wBAAS,mBAAK,IAAL,CAJX;AAKE,4BAAY,wBALd;AAME,sBAAOR;AANT;AADF;AAFF,UADF;AAeGE,uBACC;AAAA;AAAA,aAAS,SAAO,eAAQO,IAAxB;AACE;AACE,sBAAO,eAAQC,SADjB,EAC4B,MAAK,UADjC;AAEE,uBAAUT;AAFZ,aADF;AAKE;AAAA;AAAA,eAAO,OAAI,YAAX;AAAA;AAAA,YALF;AAME;AAAA;AAAA,eAAI,SAAO,eAAQU,QAAnB;AACGrC,mBAAMkB,GAAN,CAAU,UAAChB,IAAD,EAAOa,SAAP;AAAA,sBACT;AAAA;AAAA,mBAAI,SAAOT,YAAYJ,IAAZ,CAAX;AACE;AAAA;AAAA,qBAAK,SAAO,eAAQoC,IAApB;AACE;AACE,8BAAO,eAAQC,MADjB;AAEE,8BAASrC,KAAKC,WAFhB;AAGE,wCAAiBY,SAHnB;AAIE,+BAAUJ,YAJZ;AAKE,2BAAK;AALP,qBADF;AAQE;AAAA;AAAA;AAAQT,0BAAKuB;AAAb,oBARF;AASE;AACE,8BAAO,eAAQe,OADjB;AAEE,wCAAiBzB,SAFnB;AAGE,8BAASM;AAHX;AATF,kBADF;AAgBE,4CAAO,SAAO,eAAQoB,IAAtB,EAA4B,OAAM,2BAAlC;AAhBF,gBADS;AAAA,cAAV;AADH;AANF,UADD,GA8BG,EA7CN;AA+CGb,uBACC;AAAA;AAAA,aAAQ,SAAO,eAAQc,MAAvB;AACE;AAAA;AAAA,eAAM,SAAO,eAAQC,SAArB;AACE;AAAA;AAAA;AAASZ;AAAT,cADF;AAAA,uBAEW3B,UAAU2B,qBAAV,CAFX;AAAA,YADF;AAmBGD,kCACC;AAAA;AAAA;AACE,wBAAO,eAAQc,cADjB;AAEE,wBAASxB;AAFX;AAAA;AAAA,YADD,GAKG;AAxBN,UADD,GA2BG;AA1EN,QAFK,EA8EL;AAAA;AAAA,WAAQ,SAAO,eAAQyB,IAAvB;AACE;AAAA;AAAA;AAAA;AAAA,UADF;AAEE;AAAA;AAAA;AAAA;AAAkB;AAAA;AAAA,eAAG,MAAK,oCAAR;AAAA;AAAA;AAAlB,UAFF;AAGE;AAAA;AAAA;AAAA;AAAW;AAAA;AAAA,eAAG,MAAK,oBAAR;AAAA;AAAA;AAAX;AAHF,QA9EK,CAAP;AAoFD;;;;;;AA1IGnC,Q,CACGoC,K,GAAQ;AACbpB,iBAAc,cAAKqB,MAAL,EADD;AAEb/C,UAAO,cAAKgD,KAAL;AAFM,E;;;AA4IjBlD,gBAAemD,MAAf,CAAsB,UAAtB,EAAkCvC,OAAlC,E;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA,s3GAAq3G,iBAAiB,mDAAmD,sDAAsD,gDAAgD,mFAAmF,sBAAsB,kDAAkD,mFAAmF,sBAAsB,kDAAkD,+JAA+J,mKAAmK,uCAAuC,iCAAiC,mEAAmE,yEAAyE,sHAAsH,2CAA2C,wBAAwB,OAAO,4JAA4J,MAAM,gFAAgF,kEAAkE,iEAAiE,kDAAkD,8DAA8D,uBAAuB,4IAA4I,iKAAiK,oCAAoC,2JAA2J,qGAAqG,WAAW,mCAAmC,SAAS,QAAQ,oDAAoD,0EAA0E,sEAAsE,4EAA4E,oFAAoF,kEAAkE,wDAAwD,sDAAsD,wEAAwE,MAAM,iFAAiF,KAAK,IAAI;;AAEn3M,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,YAAY,aAAa,eAAe,eAAe,eAAe,eAAe,+CAA+C,YAAY,eAAe,oBAAoB,UAAU,YAAY,aAAa,wBAAwB,cAAc,yHAAyH,oBAAoB,UAAU,8BAA8B,yCAAyC,OAAO;AAC/e,sBAAqB,kBAAkB,wBAAwB,cAAc,kIAAkI,wBAAwB,2BAA2B,4BAA4B,oIAAoI,4BAA4B,cAAc,WAAW;AACvd,gCAA+B,SAAS,kFAAkF,WAAW,aAAa,gFAAgF,gGAAgG,sBAAsB,qHAAqH;AAC7c,kCAAiC,cAAc,2EAA2E,EAAE,gBAAgB,SAAS,uDAAuD,4BAA4B,8CAA8C,0BAA0B,WAAW,8BAA8B,0CAA0C,8BAA8B,gCAAgC,IAAI,KAAK,eAAe,gBAAgB,UAAU;AACnf,aAAY,wGAAwG,wBAAwB,SAAS,yBAAyB,WAAW,YAAY,UAAU,iBAAiB,OAAO,kBAAkB,mBAAmB,yDAAyD,0BAA0B,UAAU,0BAA0B,kDAAkD,yDAAyD;AAC9e,GAAE,wBAAwB,EAAE,+CAA+C,yBAAyB,0BAA0B,iIAAiI,0BAA0B,YAAY,WAAW,KAAK,WAAW,yBAAyB,qBAAqB,qBAAqB,aAAa,4BAA4B,aAAa,YAAY,WAAW,KAAK,WAAW,mCAAmC;AACngB,0DAAyD,2BAA2B,uBAAuB,4BAA4B,cAAc,SAAS,8BAA8B,MAAM,iCAAiC,MAAM,4CAA4C,IAAI,GAAG,sDAAsD,KAAK,QAAQ,iEAAiE,SAAS,KAAK,0CAA0C;AACxd,KAAI,gGAAgG,4BAA4B,eAAe,6EAA6E,iCAAiC,cAAc,wBAAwB,gCAAgC,uCAAuC,0BAA0B,+BAA+B,0BAA0B,YAAY,WAAW,KAAK,WAAW,mCAAmC;AACvgB,0DAAyD,GAAG,oBAAoB,uCAAuC,oBAAoB,8BAA8B,qBAAqB,uBAAuB,8BAA8B,oCAAoC,6EAA6E,MAAM,wBAAwB,kBAAkB,qDAAqD,EAAE,YAAY,WAAW,KAAK,WAAW,sBAAsB;AACxgB,oBAAmB,4BAA4B,0BAA0B,YAAY,WAAW,KAAK,WAAW,0BAA0B,4FAA4F,iDAAiD,+BAA+B,iCAAiC,gCAAgC,sCAAsC,gCAAgC,0BAA0B;AACvd,uCAAsC,oBAAoB,yBAAyB,UAAU,QAAQ,UAAU,SAAS,SAAS,wEAAwE,4EAA4E,mDAAmD,aAAa,iDAAiD,EAAE,sBAAsB,8BAA8B,oBAAoB,wBAAwB;AACxe,gBAAe,2EAA2E,qCAAqC,2DAA2D,kBAAkB,iBAAiB,SAAS,UAAU,EAAE,mBAAmB,2BAA2B,gBAAgB,uDAAuD,UAAU,qCAAqC,6CAA6C,eAAe;AACld,gDAA+C,kBAAkB,+CAA+C,0CAA0C,EAAE,uBAAuB,uBAAuB,iBAAiB;;AAE3N;;;AAGA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,mCAAkC,oBAAoB;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB,cAAc;AAClC;AACA;AACA;;AAEA;AACA,qBAAoB,iBAAiB;AACrC;;AAEA,uBAAsB,gBAAgB;AACtC,yBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA,uDAAsD,wDAAwD;;AAE9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,GAAG;AACrC;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,0CAAyC,GAAG;AAC5C;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,4CAA2C,GAAG;AAC9C;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,0CAAyC,GAAG;AAC5C;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,4BAA4B;AACnD;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB,4CAA2C,GAAG;AAC9C;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,6BAA6B;AAClD;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,mBAAkB,qBAAqB;AACvC;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,yBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,2BAA0B,sCAAsC;AAChE,wBAAuB,4CAA4C;AACnE;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,4CAA4C,SAAS;AACpF;AACA,oCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,oBAAmB;AACnB;AACA,oBAAmB;AACnB;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,iCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,mBAAkB,cAAc;AAChC;AACA;AACA,kDAAiD,cAAc;AAC/D,uBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,2BAA0B;AAC1B;AACA;AACA,6CAA4C,cAAc;AAC1D;AACA,mCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,yCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,GAAE;;AAEF;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,2BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,SAAQ;AACR;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,eAAe;AACnC;AACA;AACA,OAAM;AACN;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,KAAI;;;AAGJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,GAAE;;AAEF;;AAEA,qBAAoB,kBAAkB;;AAEtC,yBAAwB,sBAAsB;AAC9C;;AAEA,wBAAuB,qBAAqB;AAC5C;;AAEA;AACA,yBAAwB,sBAAsB;AAC9C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;AACJ,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA2C,uBAAuB;;AAElE;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,wDAAuD;AACvD;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;;AAGA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAkB,IAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,sBAAsB;AAC9D;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB,sBAAqB;;AAErB;AACA;AACA;AACA,qBAAoB,GAAG;AACvB,wBAAuB,KAAK,WAAW,SAAS,QAAQ;AACxD,uBAAsB,KAAK,WAAW,SAAS,IAAI,GAAG,IAAI,KAAK;AAC/D,iCAAgC,aAAa;AAC7C,kBAAiB,QAAQ,WAAW,SAAS;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,uCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,OAAO,MAAM,MAAM,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM,GAAG,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,GAAG,+BAA+B,KAAK,IAAI,IAAI,SAAS,GAAG;AAClF,4CAA2C;AAC3C,qCAAoC;AACpC;AACA;AACA;AACA,kBAAiB,GAAG,IAAI;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,eAAe;AACrC;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,yCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,OAAM;AACN,cAAa;AACb,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA,+CAA8C,gBAAgB;;AAE9D;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA,yCAAwC;AACxC;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,uCAAsC,aAAa;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,mCAAkC;AAClC,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA,0BAAyB;AACzB,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,yBAAwB,0CAA0C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,cAAa;AACb,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA,wBAAuB;AACvB,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA,SAAQ;AACR,OAAM;AACN,cAAa;AACb,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,2BAA2B;AACpF;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,2BAA2B;AACtE;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD,2DAA0D;AAC1D,+DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA8B,wCAAwC;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,mBAAkB,mFAAmF;AACrG;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA,aAAY,YAAY,KAAK,aAAa,oBAAoB,eAAe;;AAE7E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,qBAAqB,SAAS,gBAAgB,SAAS,IAAI,oBAAoB;AACpG;AACA,qCAAoC;;AAEpC,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAI;AACJ;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA,8BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA,mCAAkC,QAAQ;AAC1C;AACA,KAAI;AACJ;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAsB,iBAAiB;AACvC;AACA,yBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,8BAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAA+C,iCAAiC;AAChF;AACA;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,SAAQ;AACR;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,oFAAmF,YAAY;AAC/F;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,wBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA,mBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA,mBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,yBAAyB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAE;;AAEF;;;AAGA;AACA;AACA,EAAC;AACD;AACA,kC;;;;;;AC55KA;AACA;AACA;AACA,8CAA6C;AAC7C,EAAC;;AAED;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qFAAoF,aAAa;AACjG;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG,EAAE;AACL;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAmE,aAAa;AAChF;AACA;;AAEA,oBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,EAAC;;;;;;AAMD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;AAMD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA,8CAA6C,gBAAgB;;AAE7D;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,EAAC;AACD;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA8E;AAC9E;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oEAAmE,aAAa;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAoE,eAAe;AACnF;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,mBAAkB;;AAElB,0FAAyF,eAAe;AACxG;AACA;;AAEA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,yFAAwF,eAAe;AACvG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0FAAyF,eAAe;AACxG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,qEAAoE,eAAe;AACnF;AACA;;AAEA;AACA;AACA,yEAAwE,eAAe;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAwE,eAAe;AACvF;AACA;;AAEA;AACA;AACA,IAAG;AACH;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA,gEAA+D;AAC/D,gEAA+D,WAAW;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH,EAAC;;AAED;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,2BAA0B,kBAAkB;;AAE5C;AACA,oEAAmE,aAAa;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAsE,eAAe;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAAyC,mCAAmC;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO,IAAI;AACX;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yEAAwE,qBAAqB;AAC7F;;AAEA;AACA,yEAAwE,qBAAqB;AAC7F;;AAEA;AACA;AACA,gDAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA4C,mDAAmD;AAC/F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA,uBAAsB;AACtB,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA,IAAG;;AAEH;AACA;;AAEA;;AAEA,oEAAmE,aAAa;AAChF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAgC,wDAAwD;AACxF;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA,kEAAiE,aAAa;AAC9E;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC;AAChC,MAAK;AACL;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAwC,gBAAgB;AACxD,IAAG;AACH;AACA,2CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,sCAAqC;AACrC,MAAK;AACL,sCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA8C,cAAc;;AAE5D,EAAC;AACD;;;;;;;;ACr7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,mBAAmB;AAC9B,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,UAAU;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,0BAAyB,uBAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH,oCAAmC,yBAAyB;AAC5D;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,WAAW;AACtB;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA,oBAAmB,oBAAoB;AACvC,sCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,uBAAuB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,QAAQ;AAClB,WAAU,QAAQ;AAClB,WAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAW,SAAS;AACpB;;AAEA,YAAW,MAAM;AACjB;;AAEA,YAAW,MAAM;AACjB;;AAEA,YAAW,2BAA2B;AACtC;;AAEA,YAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA,YAAW,uDAAuD;AAClE,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,6BAA6B;AAC1C,cAAa,aAAa;AAC1B,cAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,2BAA2B;AACtC;AACA,YAAW,aAAa;AACxB;AACA,YAAW,GAAG;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,aAAa;AACxB;AACA;AACA,YAAW,GAAG;AACd;AACA;AACA;AACA,4BAA2B,SAAS,IAAI;;AAExC;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,SAAS;AACpB,aAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,SAAS;AACpB,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,MAAM;;AAE1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,sBAAqB,MAAM;AAC3B;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA,YAAW,KAAK;AAChB;AACA,aAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;;AAEA,SAAQ,sBAAsB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA,YAAW,KAAK;AAChB;AACA,aAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,WAAW;AACtB;AACA;AACA,YAAW,KAAK;AAChB;AACA,aAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,sBAAsB;AACjC,YAAW,8CAA8C;AACzD;AACA;AACA,aAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,OAAO;;AAElC;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gD;;;;;;AC3iCA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACHA;;;;AACA;;;;;;iBAEiBwC,Q;KAATC,I,aAAAA,I;;AACR,KAAMC,eAAeF,SAASG,aAAT,CAAuB,OAAvB,CAArB;AACA,KAAMC,cAAcJ,SAASG,aAAT,CAAuB,OAAvB,CAApB;;AAEAD,cAAaG,WAAb,GAA2B,eAAQC,QAAR,EAA3B;AACAF,aAAYC,WAAZ,GAA0B,gBAAOC,QAAP,EAA1B;;AAEAL,MAAKM,WAAL,CAAiBL,YAAjB;AACAD,MAAKM,WAAL,CAAiBH,WAAjB;;mBAEe,eAAQE,QAAR,KAAqB,gBAAOA,QAAP,E;AAC7B,KAAME,yCAAe,eAAQC,MAAvB,EAAkC,gBAAOA,MAAzC,CAAN,C;;;;;;ACdP;AACA;;;AAGA;AACA,+BAA8B,mBAAmB,cAAc,mCAAmC,sCAAsC,GAAG,8BAA8B,wBAAwB,0BAA0B,mBAAmB,GAAG,oCAAoC,+BAA+B,mBAAmB,GAAG,uFAAuF,mBAAmB,qBAAqB,qBAAqB,gBAAgB,GAAG,+BAA+B,oBAAoB,GAAG,+BAA+B,oBAAoB,GAAG,+BAA+B,qBAAqB,oBAAoB,GAAG,+BAA+B,eAAe,0BAA0B,GAAG,+BAA+B,sBAAsB,GAAG,8BAA8B,oBAAoB,qBAAqB,qBAAqB,kBAAkB,qBAAqB,GAAG,8BAA8B,kBAAkB,GAAG,8BAA8B,iBAAiB,0BAA0B,GAAG,gCAAgC,uBAAuB,GAAG,uCAAuC,sBAAsB,oBAAoB,iBAAiB,uBAAuB,eAAe,cAAc,GAAG,sCAAsC,sBAAsB,oBAAoB,iBAAiB,uBAAuB,kBAAkB,eAAe,GAAG,qCAAqC,uBAAuB,kBAAkB,aAAa,GAAG,yCAAyC,uBAAuB,GAAG,uCAAuC,qBAAqB,2BAA2B,GAAG,8BAA8B,uBAAuB,kBAAkB,mCAAmC,uBAAuB,GAAG,oCAAoC,gBAAgB,uBAAuB,cAAc,gBAAgB,mCAAmC,yCAAyC,GAAG,uDAAuD,uBAAuB,iBAAiB,aAAa,iBAAiB,kBAAkB,uBAAuB,8CAA8C,8BAA8B,+BAA+B,GAAG,+BAA+B,8BAA8B,kBAAkB,0BAA0B,KAAK,yDAAyD,gBAAgB,KAAK,GAAG;;AAEz6E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC;AACA;AACA,yCAAwC,gBAAgB;AACxD,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;;;AAGA;AACA,wCAAuC,cAAc,eAAe,GAAG,YAAY,cAAc,eAAe,cAAc,qBAAqB,oBAAoB,6BAA6B,yBAAyB,yBAAyB,mBAAmB,6BAA6B,qBAAqB,wCAAwC,uCAAuC,GAAG,UAAU,8DAA8D,uBAAuB,wBAAwB,mBAAmB,qBAAqB,qBAAqB,mBAAmB,wCAAwC,uCAAuC,qBAAqB,GAAG,YAAY,eAAe,GAAG,4BAA4B,kBAAkB,GAAG,8BAA8B,qBAAqB,2BAA2B,uBAAuB,gGAAgG,GAAG,+DAA+D,uBAAuB,qBAAqB,mBAAmB,GAAG,sDAAsD,uBAAuB,qBAAqB,mBAAmB,GAAG,uDAAuD,uBAAuB,qBAAqB,mBAAmB,GAAG,iCAAiC,uBAAuB,gBAAgB,gBAAgB,qBAAqB,qBAAqB,uBAAuB,mCAAmC,+CAA+C,4CAA4C,uCAAuC,GAAG,uDAAuD,uBAAuB,cAAc,gBAAgB,oBAAoB,yBAAyB,yBAAyB,uBAAuB,cAAc,mBAAmB,iBAAiB,2BAA2B,sDAAsD,2BAA2B,wCAAwC,uCAAuC,GAAG,4BAA4B,iCAAiC,iBAAiB,qCAAqC,kDAAkD,GAAG,8BAA8B,uBAAuB,eAAe,kCAAkC,GAAG,6BAA6B,kBAAkB,GAAG,4BAA4B,uBAAuB,eAAe,gBAAgB,gBAAgB,iBAAiB,uBAAuB,iBAAiB,uBAAuB,mCAAmC,sBAAsB,oBAAoB,mBAAmB,iCAAiC,GAAG,2CAA2C,mBAAmB,GAAG,8BAA8B,cAAc,eAAe,qBAAqB,GAAG,iCAAiC,uBAAuB,oBAAoB,qCAAqC,GAAG,4CAA4C,wBAAwB,GAAG,yDAAyD,wBAAwB,eAAe,GAAG,kFAAkF,mBAAmB,iBAAiB,uBAAuB,uBAAuB,GAAG,gFAAgF,kBAAkB,GAAG,0DAA0D,uBAAuB,gBAAgB,wFAAwF,uBAAuB,WAAW,cAAc,mBAAmB,iBAAiB,iDAAiD,qBAAqB,GAAG,gEAAgE,qCAAqC,yMAAyM,GAAG,wEAAwE,qCAAqC,4QAA4Q,GAAG,uCAAuC,0BAA0B,iCAAiC,sBAAsB,mBAAmB,qBAAqB,2BAA2B,GAAG,+DAA+D,mBAAmB,kCAAkC,GAAG,0DAA0D,kBAAkB,uBAAuB,WAAW,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,mBAAmB,wBAAwB,oCAAoC,GAAG,gEAAgE,mBAAmB,GAAG,gEAAgE,oBAAoB,GAAG,gEAAgE,mBAAmB,GAAG,0DAA0D,kBAAkB,GAAG,oEAAoE,wBAAwB,GAAG,4BAA4B,gBAAgB,uBAAuB,iBAAiB,uBAAuB,kCAAkC,GAAG,mCAAmC,gBAAgB,uBAAuB,aAAa,cAAc,YAAY,iBAAiB,qBAAqB,6NAA6N,GAAG,8BAA8B,gBAAgB,qBAAqB,GAAG,qCAAqC,qBAAqB,GAAG,8BAA8B,cAAc,eAAe,qBAAqB,uBAAuB,aAAa,YAAY,GAAG,iCAAiC,oBAAoB,GAAG,mCAAmC,mBAAmB,gBAAgB,qBAAqB,0BAA0B,kCAAkC,uBAAuB,GAAG,yCAAyC,yCAAyC,GAAG,yDAAyD,yCAAyC,GAAG,qEAAqE,iBAAiB,uBAAuB,sBAAsB,0BAA0B,oBAAoB,GAAG,oCAAoC,+BAA+B,GAAG,8BAA8B,wBAAwB,mBAAmB,oBAAoB,kDAAkD,uBAAuB,GAAG,gCAAgC,mBAAmB,GAAG,gCAAgC,mBAAmB,0BAA0B,qBAAqB,GAAG,sCAAsC,+BAA+B,GAAG,oLAAoL,qFAAqF,uBAAuB,KAAK,4DAA4D,mBAAmB,KAAK,8BAA8B,uCAAuC,+BAA+B,+BAA+B,uBAAuB,KAAK,GAAG,+BAA+B,4BAA4B,mBAAmB,KAAK,gCAAgC,mBAAmB,KAAK,GAAG;;AAEn2P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G","file":"dist/index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap af0e895bf3974cd20b10","/** @jsx h */\n\nimport 'skatejs-web-components';\nimport { Component, h, link, prop } from 'skatejs';\nimport css, { classes } from './style';\n\nconst { customElements } = window;\n\nfunction getCompleted (todos) {\n  return todos.filter(todo => todo.isCompleted);\n}\n\nfunction getPlural (count) {\n  return count === 1 ? '' : 's';\n}\n\nfunction getTodoMode (todo) {\n  if (todo.isEditing) {\n    return classes.editing;\n  }\n\n  if (todo.isCompleted) {\n    return classes.completed;\n  }\n\n  return '';\n}\n\nclass TodoApp extends Component {\n  static props = {\n    currentValue: prop.string(),\n    todos: prop.array()\n  }\n  handleChange = (e) => {\n    const { todos } = this;\n    const { target, target: { checked }} = e;\n    const todoIndex = parseFloat(target.getAttribute('data-todo-index'));\n    this.todos = todos.map((todo, currentTodoIndex) => {\n      if (currentTodoIndex === todoIndex) {\n        todo.isCompleted = checked;\n      }\n      return todo;\n    });\n  }\n  handleClear = () => {\n    this.todos = this.todos.filter(todo => !todo.isCompleted);\n  }\n  handleRemove = (e) => {\n    const todoIndex = parseFloat(e.target.getAttribute('data-todo-index'));\n    e.preventDefault();\n    this.todos = this.todos.filter((todo, currentTodoIndex) => currentTodoIndex !== todoIndex);\n  }\n  handleSubmit = (e) => {\n    e.preventDefault();\n    this.todos = this.todos.concat({\n      isCompleted: false,\n      isEditing: false,\n      description: this.currentValue\n    });\n    this.currentValue = '';\n  }\n  handleToggle = (e) => {\n    const { target: { checked } } = e;\n    this.todos = this.todos.map(todo => {\n      todo.isCompleted = checked;\n      return todo;\n    });\n  }\n  renderCallback () {\n    const {\n      currentValue,\n      handleChange,\n      handleClear,\n      handleRemove,\n      handleToggle,\n      handleSubmit,\n      todos\n    } = this;\n    const { length: todosLength } = todos;\n    const { length: todosCompletedLength } = getCompleted(todos);\n    const incompleteTodosLength = todosLength - todosCompletedLength;\n\n    return [\n      <style>{css}</style>,\n      <section class={classes.todoapp}>\n        <header class={classes.header}>\n          <h1>todos</h1>\n          <form onSubmit={handleSubmit}>\n            <input\n              autofocus\n              class={classes.newTodo}\n              name=\"currentValue\"\n              onKeyup={link(this)}\n              placeholder='What needs to be done?'\n              value={currentValue}\n            />\n          </form>\n        </header>\n\n        {todosLength ? (\n          <section class={classes.main}>\n            <input\n              class={classes.toggleAll} type='checkbox'\n              onChange={handleToggle}\n            />\n            <label for='toggle-all'>Mark all as complete</label>\n            <ul class={classes.todoList}>\n              {todos.map((todo, todoIndex) => (\n                <li class={getTodoMode(todo)}>\n                  <div class={classes.view}>\n                    <input\n                      class={classes.toggle}\n                      checked={todo.isCompleted}\n                      data-todo-index={todoIndex}\n                      onChange={handleChange}\n                      type='checkbox'\n                    />\n                    <label>{todo.description}</label>\n                    <button\n                      class={classes.destroy}\n                      data-todo-index={todoIndex}\n                      onClick={handleRemove}\n                    />\n                  </div>\n                  <input class={classes.edit} value='Create a TodoMVC template' />\n                </li>\n              ))}\n            </ul>\n          </section>\n        ) : ''}\n\n        {todosLength ? (\n          <footer class={classes.footer}>\n            <span class={classes.todoCount}>\n              <strong>{incompleteTodosLength}</strong>\n              {` item${getPlural(incompleteTodosLength)} left`}\n            </span>\n\n            {/* Remove this if you don't implement routing\n            <ul class={classes.filters}>\n              <li>\n                <a class={classes.selected} href='#/'>All</a>\n              </li>\n              <li>\n                <a href='#/active'>Active</a>\n              </li>\n              <li>\n                <a href='#/completed'>Completed</a>\n              </li>\n            </ul> */}\n\n            {todosCompletedLength ? (\n              <button\n                class={classes.clearCompleted}\n                onClick={handleClear}\n              >Clear completed</button>\n            ) : ''}\n          </footer>\n        ) : ''}\n      </section>,\n      <footer class={classes.info}>\n        <p>Double-click to edit a todo</p>\n        <p>Created by the <a href='https://github.com/skatejs/skatejs'>SkateJS Team</a></p>\n        <p>Part of <a href='http://todomvc.com'>TodoMVC</a></p>\n      </footer>\n    ];\n  }\n}\n\ncustomElements.define('todo-app', TodoApp);\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsWebComponents\"] = factory();\n\telse\n\t\troot[\"skatejsWebComponents\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// We load the Safari fix first because the custom element polyfill overrides\n\t// attachShadow() to observe the shadow root.\n\t__webpack_require__(1);\n\t\n\t// We have to include this first so that it can patch native.\n\t__webpack_require__(2);\n\t\n\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t// ShadyDOM polyfill be loaded first.\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _window = window,\n\t    HTMLElement = _window.HTMLElement,\n\t    MutationObserver = _window.MutationObserver,\n\t    navigator = _window.navigator;\n\tvar userAgent = navigator.userAgent;\n\t\n\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\tvar safariVersions = [0, 1].map(function (v) {\n\t  return '10.0.' + v;\n\t}).concat(['10.0']);\n\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\n\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\tfunction fixSafari() {\n\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\n\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t  // element as this is the only scenario where styles aren't recalculated.\n\t  var moOpts = { childList: true, subtree: true };\n\t  var mo = new MutationObserver(function (muts) {\n\t    muts.forEach(function (mut) {\n\t      var target = mut.target;\n\t\n\t      if (target.tagName === 'STYLE') {\n\t        var nextSibling = target.nextSibling,\n\t            parentNode = target.parentNode;\n\t\n\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t        // as it seems that doesn't trigger a recalc.\n\t\n\t        parentNode.removeChild(target);\n\t        parentNode.insertBefore(target, nextSibling);\n\t      }\n\t    });\n\t  });\n\t\n\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t  function newAttachShadow(opts) {\n\t    var sr = oldAttachShadow.call(this, opts);\n\t    mo.observe(sr, moOpts);\n\t    return sr;\n\t  }\n\t\n\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t    // Ensure polyfills can override it (hoping they call it back).\n\t    configurable: true,\n\t    enumerable: true,\n\t    value: newAttachShadow,\n\t    writable: true\n\t  });\n\t}\n\t\n\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t// fixes the bug.\n\tif (patch) {\n\t  fixSafari();\n\t}\n\t\n\texports.default = patch;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t Code distributed by Google as part of the polymer project is also\n\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\n\t//# sourceMappingURL=custom-elements.min.js.map\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar settings = window.ShadyDOM || {};\n\t\n\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\n\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\n\tfunction isShadyRoot(obj) {\n\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t}\n\t\n\tvar p = Element.prototype;\n\tvar matches = p.matches || p.matchesSelector ||\n\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tfunction matchesSelector(element, selector) {\n\t  return matches.call(element, selector);\n\t}\n\t\n\tfunction copyOwnProperty(name, source, target) {\n\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t  if (pd) {\n\t    Object.defineProperty(target, name, pd);\n\t  }\n\t}\n\t\n\tfunction extend(target, source) {\n\t  if (target && source) {\n\t    var n$ = Object.getOwnPropertyNames(source);\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t      copyOwnProperty(n, source, target);\n\t    }\n\t  }\n\t  return target || source;\n\t}\n\t\n\tfunction extendAll(target) {\n\t  var sources = [], len = arguments.length - 1;\n\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  for (var i=0; i < sources.length; i++) {\n\t    extend(target, sources[i]);\n\t  }\n\t  return target;\n\t}\n\t\n\tfunction mixin(target, source) {\n\t  for (var i in source) {\n\t    target[i] = source[i];\n\t  }\n\t  return target;\n\t}\n\t\n\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t  obj.__proto__ = proto;\n\t  return obj;\n\t}\n\t\n\tfunction patchPrototype(obj, mixin) {\n\t  var proto = Object.getPrototypeOf(obj);\n\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t    var patchProto = Object.create(proto);\n\t    patchProto.__sourceProto = proto;\n\t    extend(patchProto, mixin);\n\t    proto.__patchProto = patchProto;\n\t  }\n\t  setPrototypeOf(obj, proto.__patchProto);\n\t}\n\t\n\t\n\t\n\tvar common = {};\n\t\n\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\tvar promish;\n\tif (window.Promise) {\n\t  promish = Promise.resolve();\n\t} else {\n\t  promish = {\n\t    then: function(cb) {\n\t      var twiddle = document.createTextNode('');\n\t      var observer = new MutationObserver(function() {\n\t        observer.disconnect();\n\t        cb();\n\t      });\n\t      observer.observe(twiddle, {characterData: true});\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction newSplice(index, removed, addedCount) {\n\t  return {\n\t    index: index,\n\t    removed: removed,\n\t    addedCount: addedCount\n\t  };\n\t}\n\t\n\tvar EDIT_LEAVE = 0;\n\tvar EDIT_UPDATE = 1;\n\tvar EDIT_ADD = 2;\n\tvar EDIT_DELETE = 3;\n\t\n\tvar ArraySplice = {\n\t\n\t  // Note: This function is *based* on the computation of the Levenshtein\n\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t  // edits - not one. With Array splices, an update is really a delete\n\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t  // maximum array items in the original array. For example:\n\t  //\n\t  //   'xxxx123' -> '123yyyy'\n\t  //\n\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t  // leaves the substring '123' intact.\n\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t                              old, oldStart, oldEnd) {\n\t    var this$1 = this;\n\t\n\t    // \"Deletion\" columns\n\t    var rowCount = oldEnd - oldStart + 1;\n\t    var columnCount = currentEnd - currentStart + 1;\n\t    var distances = new Array(rowCount);\n\t\n\t    // \"Addition\" rows. Initialize null column.\n\t    for (var i = 0; i < rowCount; i++) {\n\t      distances[i] = new Array(columnCount);\n\t      distances[i][0] = i;\n\t    }\n\t\n\t    // Initialize null row\n\t    for (var j = 0; j < columnCount; j++)\n\t      distances[0][j] = j;\n\t\n\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t        else {\n\t          var north = distances[i$1 - 1][j$1] + 1;\n\t          var west = distances[i$1][j$1 - 1] + 1;\n\t          distances[i$1][j$1] = north < west ? north : west;\n\t        }\n\t      }\n\t    }\n\t\n\t    return distances;\n\t  },\n\t\n\t  // This starts at the final weight, and walks \"backward\" by finding\n\t  // the minimum previous weight recursively until the origin of the weight\n\t  // matrix.\n\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t    var i = distances.length - 1;\n\t    var j = distances[0].length - 1;\n\t    var current = distances[i][j];\n\t    var edits = [];\n\t    while (i > 0 || j > 0) {\n\t      if (i == 0) {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        continue;\n\t      }\n\t      if (j == 0) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        continue;\n\t      }\n\t      var northWest = distances[i - 1][j - 1];\n\t      var west = distances[i - 1][j];\n\t      var north = distances[i][j - 1];\n\t\n\t      var min;\n\t      if (west < north)\n\t        min = west < northWest ? west : northWest;\n\t      else\n\t        min = north < northWest ? north : northWest;\n\t\n\t      if (min == northWest) {\n\t        if (northWest == current) {\n\t          edits.push(EDIT_LEAVE);\n\t        } else {\n\t          edits.push(EDIT_UPDATE);\n\t          current = northWest;\n\t        }\n\t        i--;\n\t        j--;\n\t      } else if (min == west) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        current = west;\n\t      } else {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        current = north;\n\t      }\n\t    }\n\t\n\t    edits.reverse();\n\t    return edits;\n\t  },\n\t\n\t  /**\n\t   * Splice Projection functions:\n\t   *\n\t   * A splice map is a representation of how a previous array of items\n\t   * was transformed into a new array of items. Conceptually it is a list of\n\t   * tuples of\n\t   *\n\t   *   <index, removed, addedCount>\n\t   *\n\t   * which are kept in ascending index order of. The tuple represents that at\n\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t   * from |index|, |addedCount| items were added.\n\t   */\n\t\n\t  /**\n\t   * Lacking individual splice mutation information, the minimal set of\n\t   * splices can be synthesized given the previous state and final state of an\n\t   * array. The basic approach is to calculate the edit distance matrix and\n\t   * choose the shortest path through it.\n\t   *\n\t   * Complexity: O(l * p)\n\t   *   l: The length of the current array\n\t   *   p: The length of the old array\n\t   */\n\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t                        old, oldStart, oldEnd) {\n\t    var prefixCount = 0;\n\t    var suffixCount = 0;\n\t    var splice;\n\t\n\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t    if (currentStart == 0 && oldStart == 0)\n\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\n\t    if (currentEnd == current.length && oldEnd == old.length)\n\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\n\t    currentStart += prefixCount;\n\t    oldStart += prefixCount;\n\t    currentEnd -= suffixCount;\n\t    oldEnd -= suffixCount;\n\t\n\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t      return [];\n\t\n\t    if (currentStart == currentEnd) {\n\t      splice = newSplice(currentStart, [], 0);\n\t      while (oldStart < oldEnd)\n\t        splice.removed.push(old[oldStart++]);\n\t\n\t      return [ splice ];\n\t    } else if (oldStart == oldEnd)\n\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\n\t    var ops = this.spliceOperationsFromEditDistances(\n\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t                               old, oldStart, oldEnd));\n\t\n\t    splice = undefined;\n\t    var splices = [];\n\t    var index = currentStart;\n\t    var oldIndex = oldStart;\n\t    for (var i = 0; i < ops.length; i++) {\n\t      switch(ops[i]) {\n\t        case EDIT_LEAVE:\n\t          if (splice) {\n\t            splices.push(splice);\n\t            splice = undefined;\n\t          }\n\t\n\t          index++;\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_UPDATE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_ADD:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t          break;\n\t        case EDIT_DELETE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (splice) {\n\t      splices.push(splice);\n\t    }\n\t    return splices;\n\t  },\n\t\n\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t    var this$1 = this;\n\t\n\t    for (var i = 0; i < searchLength; i++)\n\t      if (!this$1.equals(current[i], old[i]))\n\t        return i;\n\t    return searchLength;\n\t  },\n\t\n\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t    var index1 = current.length;\n\t    var index2 = old.length;\n\t    var count = 0;\n\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t      count++;\n\t\n\t    return count;\n\t  },\n\t\n\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t                            previous.length);\n\t  },\n\t\n\t  equals: function equals(currentValue, previousValue) {\n\t    return currentValue === previousValue;\n\t  }\n\t\n\t};\n\t\n\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t// for now this is stuck on `utils`\n\t//import {patchNode} from './patch'\n\t// native add/remove\n\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\tvar nativeAppendChild = Element.prototype.appendChild;\n\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\n\t/**\n\t * `tree` is a dom manipulation library used by ShadyDom to\n\t * manipulate composed and logical trees.\n\t */\n\tvar tree = {\n\t\n\t  // sad but faster than slice...\n\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopy: function arrayCopy(a$) {\n\t    var l = a$.length;\n\t    var copy = new Array(l);\n\t    for (var i=0; i < l; i++) {\n\t      copy[i] = a$[i];\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes(node) {\n\t    tree.Logical.saveChildNodes(node);\n\t    if (!tree.Composed.hasParentNode(node)) {\n\t      tree.Composed.saveComposedData(node);\n\t      //tree.Composed.saveParentNode(node);\n\t    }\n\t    tree.Composed.saveChildNodes(node);\n\t  }\n\t\n\t};\n\t\n\ttree.Logical = {\n\t\n\t  hasParentNode: function hasParentNode(node) {\n\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes(node) {\n\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes(node) {\n\t    // note: we're distinguishing here between undefined and false-y:\n\t    // hasChildNodes uses undefined check to see if this element has logical\n\t    // children; the false-y check indicates whether or not we should rebuild\n\t    // the cached childNodes array.\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      tree.Composed.getChildNodes(node);\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes(node) {\n\t    if (!node.__dom.childNodes) {\n\t      node.__dom.childNodes = [];\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        node.__dom.childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.childNodes;\n\t  },\n\t\n\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t  // element will store firstChild/lastChild, and in case (2), the element\n\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t  // the mere existence of __dom is not enough to know if the requested\n\t  // logical data is available and instead we do an explicit undefined check.\n\t  getParentNode: function getParentNode(node) {\n\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t  },\n\t\n\t  getLastChild: function getLastChild(node) {\n\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t  },\n\t\n\t  getNextSibling: function getNextSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      this._getFirstElementChild(node) :\n\t      tree.Composed.getFirstElementChild(node);\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t    var n = node.__dom.firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild(node) {\n\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t      this._getLastElementChild(node) :\n\t      tree.Composed.getLastElementChild(node);\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild(node) {\n\t    var n = node.__dom.lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t      this._getNextElementSibling(node) :\n\t      tree.Composed.getNextElementSibling(node);\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t      this._getPreviousElementSibling(node) :\n\t      tree.Composed.getPreviousElementSibling(node);\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  // Capture the list of light children. It's important to do this before we\n\t  // start transforming the DOM into \"rendered\" state.\n\t  // Children may be added to this list dynamically. It will be treated as the\n\t  // source of truth for the light children of the element. This element's\n\t  // actual children will be treated as the rendered state once this function\n\t  // has been called.\n\t  saveChildNodes: function saveChildNodes$1(node) {\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.firstChild;\n\t      node.__dom.lastChild = node.lastChild;\n\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        n.__dom = n.__dom || {};\n\t        n.__dom.parentNode = node;\n\t        n.__dom.nextSibling = c$[i+1] || null;\n\t        n.__dom.previousSibling = c$[i-1] || null;\n\t        common.patchNode(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t  // already been distributed.\n\t  // NOTE: ensure `node` is patched...\n\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var c$ = tree.arrayCopyChildNodes(node);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1._linkNode(c$[i], container, ref_node);\n\t      }\n\t      // cleanup logical dom in doc fragment.\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t      node.__dom.childNodes = null;\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t    common.patchNode(node);\n\t    ref_node = ref_node || null;\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t      container.__dom.lastChild;\n\t    if (node.__dom.previousSibling) {\n\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.nextSibling = ref_node;\n\t    if (node.__dom.nextSibling) {\n\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.lastChild = node;\n\t      if (!container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.firstChild) {\n\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t    }\n\t    if (node === container.__dom.lastChild) {\n\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t    }\n\t    var p = node.__dom.previousSibling;\n\t    var n = node.__dom.nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.previousSibling = p;\n\t    }\n\t    // When an element is removed, logical data is no longer tracked.\n\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t    // from `null` which is set if info is null.\n\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t      node.__dom.nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  }\n\t\n\t}\n\t\n\t\n\t// TODO(sorvell): composed tree manipulation is made available\n\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t// to the tree for optional patching pluggability.\n\ttree.Composed = {\n\t\n\t  hasParentNode: function hasParentNode$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes$1(node) {\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes$1(node) {\n\t    if (!node.__dom.$childNodes) {\n\t      node.__dom.$childNodes = [];\n\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t        node.__dom.$childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getParentNode: function getParentNode$1(node) {\n\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t      (!node.__patched && node.parentNode);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild$1(node) {\n\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t  },\n\t\n\t  getLastChild: function getLastChild$1(node) {\n\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t  },\n\t\n\t  getNextSibling: function getNextSibling$1(node) {\n\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t    return node.__patched ? this._getFirstElementChild(node) :\n\t      node.firstElementChild;\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t    var n = node.__dom.$firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild$1(node) {\n\t    return node.__patched ? this._getLastElementChild(node) :\n\t      node.lastElementChild;\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t    var n = node.__dom.$lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t    return node.__patched ? this._getNextElementSibling(node) :\n\t      node.nextElementSibling;\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t      node.previousElementSibling;\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes$2(node) {\n\t    var this$1 = this;\n\t\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.$firstChild = node.firstChild;\n\t      node.__dom.$lastChild = node.lastChild;\n\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        this$1.saveComposedData(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  saveComposedData: function saveComposedData(node) {\n\t    node.__dom = node.__dom || {};\n\t    if (node.__dom.$parentNode === undefined) {\n\t      node.__dom.$parentNode = node.parentNode;\n\t    }\n\t    if (node.__dom.$nextSibling === undefined) {\n\t      node.__dom.$nextSibling = node.nextSibling;\n\t    }\n\t    if (node.__dom.$previousSibling === undefined) {\n\t      node.__dom.$previousSibling = node.previousSibling;\n\t    }\n\t  },\n\t\n\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.$childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      // TODO(sorvell): remember this for patching:\n\t      // the act of setting this info can affect patched nodes\n\t      // getters; therefore capture childNodes before patching.\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        this$1._linkNode(n, container, ref_node);\n\t      }\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t      container.__dom.$lastChild;\n\t    if (node.__dom.$previousSibling) {\n\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.$nextSibling = ref_node;\n\t    if (node.__dom.$nextSibling) {\n\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.$parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.$lastChild = node;\n\t      if (!container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.$firstChild) {\n\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t    }\n\t    if (node === container.__dom.$lastChild) {\n\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t    }\n\t    var p = node.__dom.$previousSibling;\n\t    var n = node.__dom.$nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.$nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.$previousSibling = p;\n\t    }\n\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t      node.__dom.$nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  clearChildNodes: function clearChildNodes(node) {\n\t    var this$1 = this;\n\t\n\t    var c$ = this.getChildNodes(node);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      this$1.recordRemoveChild(c, node);\n\t      nativeRemoveChild.call(node, c)\n\t    }\n\t  },\n\t\n\t  saveParentNode: function saveParentNode(node) {\n\t    node.__dom = node.__dom || {};\n\t    node.__dom.$parentNode = node.parentNode;\n\t  },\n\t\n\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t    this.saveChildNodes(parentNode);\n\t    // remove from current location.\n\t    this._addChild(parentNode, newChild, refChild);\n\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t  },\n\t\n\t  appendChild: function appendChild(parentNode, newChild) {\n\t    this.saveChildNodes(parentNode);\n\t    this._addChild(parentNode, newChild);\n\t    return nativeAppendChild.call(parentNode, newChild);\n\t  },\n\t\n\t  removeChild: function removeChild(parentNode, node) {\n\t    var currentParent = this.getParentNode(node);\n\t    this.saveChildNodes(parentNode);\n\t    this._removeChild(parentNode, node);\n\t    if (currentParent === parentNode) {\n\t      return nativeRemoveChild.call(parentNode, node);\n\t    }\n\t  },\n\t\n\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t    var this$1 = this;\n\t\n\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t    var oldParent = this.getParentNode(newChild);\n\t    if (oldParent) {\n\t      this._removeChild(oldParent, newChild);\n\t    }\n\t    if (isFrag) {\n\t      var c$ = this.getChildNodes(newChild);\n\t      for (var i=0; i < c$.length; i++) {\n\t        var c = c$[i];\n\t        // unlink document fragment children\n\t        this$1._removeChild(newChild, c);\n\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t      }\n\t    } else {\n\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t    }\n\t  },\n\t\n\t  _removeChild: function _removeChild(parentNode, node) {\n\t    this.recordRemoveChild(node, parentNode);\n\t  }\n\t\n\t};\n\t\n\t// for testing...\n\tvar descriptors = {};\n\tfunction getNativeProperty(element, property) {\n\t  if (!descriptors[property]) {\n\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t      HTMLElement.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Element.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Node.prototype, property);\n\t  }\n\t  return descriptors[property].get.call(element);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// NOTE: normalize event contruction where necessary (IE11)\n\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t  function(inType, params) {\n\t    params = params || {};\n\t    var e = document.createEvent('Event');\n\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t    return e;\n\t  };\n\t\n\tvar Distributor = (function () {\n\t  function anonymous(root) {\n\t    this.root = root;\n\t    this.insertionPointTag = 'slot';\n\t  }\n\t\n\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t  };\n\t\n\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t    return Boolean(this.root._insertionPoints &&\n\t      this.root._insertionPoints.length);\n\t  };\n\t\n\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t    return node.localName && node.localName == this.insertionPointTag;\n\t  };\n\t\n\t  anonymous.prototype.distribute = function distribute () {\n\t    if (this.hasInsertionPoint()) {\n\t      return this.distributePool(this.root, this.collectPool());\n\t    }\n\t    return [];\n\t  };\n\t\n\t  // Gather the pool of nodes that should be distributed. We will combine\n\t  // these with the \"content root\" to arrive at the composed tree.\n\t  anonymous.prototype.collectPool = function collectPool () {\n\t    return tree.arrayCopy(\n\t      tree.Logical.getChildNodes(this.root.host));\n\t  };\n\t\n\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t  // instead elements are distributed into storage\n\t  // array where applicable.\n\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t    var this$1 = this;\n\t\n\t    var dirtyRoots = [];\n\t    var p$ = this.root._insertionPoints;\n\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t      this$1.distributeInsertionPoint(p, pool);\n\t      // provoke redistribution on insertion point parents\n\t      // must do this on all candidate hosts since distribution in this\n\t      // scope invalidates their distribution.\n\t      // only get logical parent.\n\t      var parent = tree.Logical.getParentNode(p);\n\t      if (parent && parent.shadyRoot &&\n\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t        dirtyRoots.push(parent.shadyRoot);\n\t      }\n\t    }\n\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t      var p$1 = pool[i$1];\n\t      if (p$1) {\n\t        p$1._assignedSlot = undefined;\n\t        // remove undistributed elements from physical dom.\n\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t        if (parent$1) {\n\t          tree.Composed.removeChild(parent$1, p$1);\n\t        }\n\t      }\n\t    }\n\t    return dirtyRoots;\n\t  };\n\t\n\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t    var this$1 = this;\n\t\n\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t    if (prevAssignedNodes) {\n\t      this.clearAssignedSlots(insertionPoint, true);\n\t    }\n\t    insertionPoint._assignedNodes = [];\n\t    var needsSlotChange = false;\n\t    // distribute nodes from the pool that this selector matches\n\t    var anyDistributed = false;\n\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t      node=pool[i];\n\t      // skip nodes that were already used\n\t      if (!node) {\n\t        continue;\n\t      }\n\t      // distribute this node if it matches\n\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node, insertionPoint)\n\t        // remove this node from the pool\n\t        pool[i] = undefined;\n\t        // since at least one node matched, we won't need fallback content\n\t        anyDistributed = true;\n\t      }\n\t    }\n\t    // Fallback content if nothing was distributed here\n\t    if (!anyDistributed) {\n\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t      for (var j = 0, node$1; j < children.length; j++) {\n\t        node$1 = children[j];\n\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t      }\n\t    }\n\t    // we're already dirty if a node was newly added to the slot\n\t    // and we're also dirty if the assigned count decreased.\n\t    if (prevAssignedNodes) {\n\t      // TODO(sorvell): the tracking of previously assigned slots\n\t      // could instead by done with a Set and then we could\n\t      // avoid needing to iterate here to clear the info.\n\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t      }\n\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t        needsSlotChange = true;\n\t      }\n\t    }\n\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t    if (needsSlotChange) {\n\t      this._fireSlotChange(insertionPoint);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t    var n$ = slot._assignedNodes;\n\t    if (n$) {\n\t      for (var i=0; i < n$.length; i++) {\n\t        var n = n$[i];\n\t        if (savePrevious) {\n\t          n.__prevAssignedSlot = n._assignedSlot;\n\t        }\n\t        // only clear if it was previously set to this slot;\n\t        // this helps ensure that if the node has otherwise been distributed\n\t        // ignore it.\n\t        if (n._assignedSlot === slot) {\n\t          n._assignedSlot = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t    var slotName = insertionPoint.getAttribute('name');\n\t    slotName = slotName ? slotName.trim() : '';\n\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t    slot = slot ? slot.trim() : '';\n\t    return (slot == slotName);\n\t  };\n\t\n\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t    insertionPoint._assignedNodes.push(child);\n\t    child._assignedSlot = insertionPoint;\n\t  };\n\t\n\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t    var this$1 = this;\n\t\n\t    var n$ = insertionPoint._assignedNodes;\n\t    insertionPoint._distributedNodes = [];\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t      if (this$1.isInsertionPoint(n)) {\n\t        var d$ = n._distributedNodes;\n\t        if (d$) {\n\t          for (var j=0; j < d$.length; j++) {\n\t            insertionPoint._distributedNodes.push(d$[j]);\n\t          }\n\t        }\n\t      } else {\n\t        insertionPoint._distributedNodes.push(n$[i]);\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t    // Safari tech preview does not bubble but chrome does\n\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t    if (insertionPoint._assignedSlot) {\n\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t    return !(insertionPoint._assignedSlot);\n\t  };\n\t\n\t  return anonymous;\n\t}())\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t  polyfill across browsers.\n\t*/\n\tvar ShadyRoot = function ShadyRoot(host) {\n\t  if (!host) {\n\t    throw 'Must provide a host';\n\t  }\n\t  // NOTE: this strange construction is necessary because\n\t  // DocumentFragment cannot be subclassed on older browsers.\n\t  var frag = document.createDocumentFragment();\n\t  frag.__proto__ = ShadyFragmentMixin;\n\t  frag._init(host);\n\t  return frag;\n\t};\n\t\n\tvar ShadyMixin = {\n\t\n\t  _init: function _init(host) {\n\t    // NOTE: set a fake local name so this element can be\n\t    // distinguished from a DocumentFragment when patching.\n\t    // FF doesn't allow this to be `localName`\n\t    this.__localName = 'ShadyRoot';\n\t    // root <=> host\n\t    host.shadyRoot = this;\n\t    this.host = host;\n\t    // logical dom setup\n\t    tree.Logical.saveChildNodes(host);\n\t    tree.Logical.saveChildNodes(this);\n\t    // state flags\n\t    this._clean = true;\n\t    this._hasRendered = false;\n\t    this._distributor = new Distributor(this);\n\t    this.update();\n\t  },\n\t\n\t  // async render the \"top\" distributor (this is all that is needed to\n\t  // distribute this host).\n\t  update: function update() {\n\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t    if (distributionRoot._clean) {\n\t      distributionRoot._clean = false;\n\t      enqueue(function() {\n\t        distributionRoot.render();\n\t      });\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t  // this should only return a shadowRoot.\n\t  // returns the host that's the top of this host's distribution tree\n\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t    var root = element.shadyRoot;\n\t    while (element && this._elementNeedsDistribution(element)) {\n\t      root = element.getRootNode();\n\t      element = root && root.host;\n\t    }\n\t    return root;\n\t  },\n\t\n\t  // Return true if a host's children includes\n\t  // an insertion point that selects selectively\n\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t    var this$1 = this;\n\t\n\t    var c$ = tree.Logical.getChildNodes(element);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t        return element.getRootNode();\n\t      }\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    if (!this._clean) {\n\t      this._clean = true;\n\t      if (!this._skipUpdateInsertionPoints) {\n\t        this.updateInsertionPoints();\n\t      } else if (!this._hasRendered) {\n\t        this._insertionPoints = [];\n\t      }\n\t      this._skipUpdateInsertionPoints = false;\n\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t      // that would avoid distribution for initial render if\n\t      // no insertion points exist. We cannot currently do this because\n\t      // it relies on elements being in the physical shadowRoot element\n\t      // so that native methods will be used. The current append code\n\t      // simply provokes distribution in this case and does not put the\n\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t      // consider if the special processing is worth the perf gain.\n\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t      //   tree.Composed.clearChildNodes(this.host);\n\t      //   tree.Composed.appendChild(this.host, this);\n\t      // } else {\n\t      // logical\n\t      this.distribute();\n\t      // physical\n\t      this.compose();\n\t      this._hasRendered = true;\n\t    }\n\t  },\n\t\n\t  forceRender: function forceRender() {\n\t    this._clean = false;\n\t    this.render();\n\t  },\n\t\n\t  distribute: function distribute() {\n\t    var dirtyRoots = this._distributor.distribute();\n\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t      dirtyRoots[i].forceRender();\n\t    }\n\t  },\n\t\n\t  updateInsertionPoints: function updateInsertionPoints() {\n\t    var this$1 = this;\n\t\n\t    var i$ = this.__insertionPoints;\n\t    // if any insertion points have been removed, clear their distribution info\n\t    if (i$) {\n\t      for (var i=0, c; i < i$.length; i++) {\n\t        c = i$[i];\n\t        if (c.getRootNode() !== this$1) {\n\t          this$1._distributor.clearAssignedSlots(c);\n\t        }\n\t      }\n\t    }\n\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t    // ensure insertionPoints's and their parents have logical dom info.\n\t    // save logical tree info\n\t    // a. for shadyRoot\n\t    // b. for insertion points (fallback)\n\t    // c. for parents of insertion points\n\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t      c$1 = i$[i$1];\n\t      tree.Logical.saveChildNodes(c$1);\n\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t    }\n\t  },\n\t\n\t  get _insertionPoints() {\n\t    if (!this.__insertionPoints) {\n\t      this.updateInsertionPoints();\n\t    }\n\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t  },\n\t\n\t  set _insertionPoints(insertionPoints) {\n\t    this.__insertionPoints = insertionPoints;\n\t  },\n\t\n\t  hasInsertionPoint: function hasInsertionPoint() {\n\t    return this._distributor.hasInsertionPoint();\n\t  },\n\t\n\t  compose: function compose() {\n\t    // compose self\n\t    // note: it's important to mark this clean before distribution\n\t    // so that attachment that provokes additional distribution (e.g.\n\t    // adding something to your parentNode) works\n\t    this._composeTree();\n\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t    // (these seem unnecessary)\n\t  },\n\t\n\t  // Reify dom such that it is at its correct rendering position\n\t  // based on logical distribution.\n\t  _composeTree: function _composeTree() {\n\t    var this$1 = this;\n\t\n\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t    var p$ = this._insertionPoints || [];\n\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t      parent = tree.Logical.getParentNode(p);\n\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t      }\n\t    }\n\t  },\n\t\n\t  // Returns the list of nodes which should be rendered inside `node`.\n\t  _composeNode: function _composeNode(node) {\n\t    var this$1 = this;\n\t\n\t    var children = [];\n\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t    for (var i = 0; i < c$.length; i++) {\n\t      var child = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t        var distributedNodes = child._distributedNodes ||\n\t          (child._distributedNodes = []);\n\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t          var distributedNode = distributedNodes[j];\n\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t            children.push(distributedNode);\n\t          }\n\t        }\n\t      } else {\n\t        children.push(child);\n\t      }\n\t    }\n\t    return children;\n\t  },\n\t\n\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t    return this._distributor.isFinalDestination(\n\t      insertionPoint, node);\n\t  },\n\t\n\t  // Ensures that the rendered node list inside `container` is `children`.\n\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t    var composed = tree.Composed.getChildNodes(container);\n\t    var splices = calculateSplices(children, composed);\n\t    // process removals\n\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t        // check if the node is still where we expect it is before trying\n\t        // to remove it; this can happen if we move a node and\n\t        // then schedule its previous host for distribution resulting in\n\t        // the node being removed here.\n\t        if (tree.Composed.getParentNode(n) === container) {\n\t          tree.Composed.removeChild(container, n);\n\t        }\n\t        composed.splice(s.index + d, 1);\n\t      }\n\t      d -= s.addedCount;\n\t    }\n\t    // process adds\n\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t      next = composed[s$1.index];\n\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t        n$1 = children[j$1];\n\t        tree.Composed.insertBefore(container, n$1, next);\n\t        // TODO(sorvell): is this splice strictly needed?\n\t        composed.splice(j$1, 0, n$1);\n\t      }\n\t    }\n\t  },\n\t\n\t  getInsertionPointTag: function getInsertionPointTag() {\n\t    return this._distributor.insertionPointTag;\n\t  }\n\t\n\t}\n\t\n\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\textend(ShadyFragmentMixin, ShadyMixin);\n\t\n\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\n\t// function upgradeLogicalChildren(children) {\n\t//   if (needsUpgrade && children) {\n\t//     for (let i=0; i < children.length; i++) {\n\t//       CustomElements.upgrade(children[i]);\n\t//     }\n\t//   }\n\t// }\n\t\n\t// render enqueuer/flusher\n\tvar customElements = window.customElements;\n\tvar flushList = [];\n\tvar scheduled;\n\tvar flushCount = 0;\n\tvar flushMax = 100;\n\tfunction enqueue(callback) {\n\t  if (!scheduled) {\n\t    scheduled = true;\n\t    promish.then(flush$1);\n\t  }\n\t  flushList.push(callback);\n\t}\n\t\n\tfunction flush$1() {\n\t  scheduled = false;\n\t  flushCount++;\n\t  while (flushList.length) {\n\t    flushList.shift()();\n\t  }\n\t  if (customElements && customElements.flush) {\n\t    customElements.flush();\n\t  }\n\t  // continue flushing after elements are upgraded...\n\t  var isFlushedMaxed = (flushCount > flushMax);\n\t  if (flushList.length && !isFlushedMaxed) {\n\t      flush$1();\n\t  }\n\t  flushCount = 0;\n\t  if (isFlushedMaxed) {\n\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t  }\n\t}\n\t\n\tflush$1.list = flushList;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// Cribbed from ShadowDOM polyfill\n\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t/////////////////////////////////////////////////////////////////////////////\n\t// innerHTML and outerHTML\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\n\tfunction escapeReplace(c) {\n\t  switch (c) {\n\t    case '&':\n\t      return '&amp;';\n\t    case '<':\n\t      return '&lt;';\n\t    case '>':\n\t      return '&gt;';\n\t    case '\"':\n\t      return '&quot;';\n\t    case '\\u00A0':\n\t      return '&nbsp;';\n\t  }\n\t}\n\t\n\tfunction escapeAttr(s) {\n\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t}\n\t\n\tfunction escapeData(s) {\n\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t}\n\t\n\tfunction makeSet(arr) {\n\t  var set = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    set[arr[i]] = true;\n\t  }\n\t  return set;\n\t}\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\tvar voidElements = makeSet([\n\t  'area',\n\t  'base',\n\t  'br',\n\t  'col',\n\t  'command',\n\t  'embed',\n\t  'hr',\n\t  'img',\n\t  'input',\n\t  'keygen',\n\t  'link',\n\t  'meta',\n\t  'param',\n\t  'source',\n\t  'track',\n\t  'wbr'\n\t]);\n\t\n\tvar plaintextParents = makeSet([\n\t  'style',\n\t  'script',\n\t  'xmp',\n\t  'iframe',\n\t  'noembed',\n\t  'noframes',\n\t  'plaintext',\n\t  'noscript'\n\t]);\n\t\n\tfunction getOuterHTML(node, parentNode, composed) {\n\t  switch (node.nodeType) {\n\t    case Node.ELEMENT_NODE: {\n\t      var tagName = node.localName;\n\t      var s = '<' + tagName;\n\t      var attrs = node.attributes;\n\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t      }\n\t      s += '>';\n\t      if (voidElements[tagName]) {\n\t        return s;\n\t      }\n\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t    }\n\t    case Node.TEXT_NODE: {\n\t      var data = node.data;\n\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t        return data;\n\t      }\n\t      return escapeData(data);\n\t    }\n\t    case Node.COMMENT_NODE: {\n\t      return '<!--' + node.data + '-->';\n\t    }\n\t    default: {\n\t      window.console.error(node);\n\t      throw new Error('not implemented');\n\t    }\n\t  }\n\t}\n\t\n\tfunction getInnerHTML(node, composed) {\n\t  if (node.localName === 'template') {\n\t    node = node.content;\n\t  }\n\t  var s = '';\n\t  var c$ = composed ? composed(node) : node.childNodes;\n\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t    s += getOuterHTML(child, node, composed);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar mixinImpl = {\n\t\n\t  // Try to add node. Record logical info, track insertion points, perform\n\t  // distribution iff needed. Return true if the add is handled.\n\t  addNode: function addNode(container, node, ref_node) {\n\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t    if (ownerRoot) {\n\t      // optimization: special insertion point tracking\n\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t      }\n\t      // note: we always need to see if an insertion point is added\n\t      // since this saves logical tree info; however, invalidation state\n\t      // needs\n\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t      // invalidate insertion points IFF not already invalid!\n\t      if (ipAdded) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t      }\n\t    }\n\t    if (tree.Logical.hasChildNodes(container)) {\n\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t    }\n\t    // if not distributing and not adding to host, do a fast path addition\n\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t      container.shadyRoot;\n\t    return handled;\n\t  },\n\t\n\t  // Try to remove node: update logical info and perform distribution iff\n\t  // needed. Return true if the removal has been handled.\n\t  // note that it's possible for both the node's host and its parent\n\t  // to require distribution... both cases are handled here.\n\t  removeNode: function removeNode(node) {\n\t    // important that we want to do this only if the node has a logical parent\n\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t      tree.Logical.getParentNode(node);\n\t    var distributed;\n\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t    if (logicalParent) {\n\t      // distribute node's parent iff needed\n\t      distributed = this.maybeDistributeParent(node);\n\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t      // remove node from root and distribute it iff needed\n\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    this._removeOwnerShadyRoot(node);\n\t    return distributed;\n\t  },\n\t\n\t\n\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t    var observer = node.__dom && node.__dom.observer;\n\t    if (observer) {\n\t      if (addedNode) {\n\t        observer.addedNodes.push(addedNode);\n\t      }\n\t      if (removedNode) {\n\t        observer.removedNodes.push(removedNode);\n\t      }\n\t      observer.schedule();\n\t    }\n\t  },\n\t\n\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t    if (parent) {\n\t      this._scheduleObserver(parent, null, node);\n\t      this.removeNode(node);\n\t    } else {\n\t      this._removeOwnerShadyRoot(node);\n\t    }\n\t  },\n\t\n\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t  },\n\t\n\t  getRootNode: function getRootNode$1(node) {\n\t    if (!node || !node.nodeType) {\n\t      return;\n\t    }\n\t    var root = node.__ownerShadyRoot;\n\t    if (root === undefined) {\n\t      if (isShadyRoot(node)) {\n\t        root = node;\n\t      } else {\n\t        var parent = tree.Logical.getParentNode(node);\n\t        root = parent ? this.getRootNode(parent) : node;\n\t      }\n\t      // memo-ize result for performance but only memo-ize\n\t      // result if node is in the document. This avoids a problem where a root\n\t      // can be cached while an element is inside a fragment.\n\t      // If this happens and we cache the result, the value can become stale\n\t      // because for perf we avoid processing the subtree of added fragments.\n\t      if (document.documentElement.contains(node)) {\n\t        node.__ownerShadyRoot = root;\n\t      }\n\t    }\n\t    return root;\n\t  },\n\t\n\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t    var root = this.getRootNode(node);\n\t    if (isShadyRoot(root)) {\n\t      return root;\n\t    }\n\t  },\n\t\n\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t    // <content> children but since this case is assumed to be exceedingly\n\t    // rare, we avoid the cost and will address with some specific api\n\t    // when the need arises.  For now, the user must call\n\t    // distributeContent(true), which updates insertion points manually\n\t    // and forces distribution.\n\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t      !node.__noInsertionPoint &&\n\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t    var wrappedContent = fragContent &&\n\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t    // There are 3 possible cases where a distribution may need to occur:\n\t    // 1. <content> being inserted (the host of the shady root where\n\t    //    content is inserted needs distribution)\n\t    // 2. children being inserted into parent with a shady root (parent\n\t    //    needs distribution)\n\t    // 3. container is an insertionPoint\n\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t      if (ownerRoot) {\n\t        // note, insertion point list update is handled after node\n\t        // mutations are complete\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    var needsDist = this._nodeNeedsDistribution(container);\n\t    if (needsDist) {\n\t      container.shadyRoot.update();\n\t    }\n\t    // Return true when distribution will fully handle the composition\n\t    // Note that if a content was being inserted that was wrapped by a node,\n\t    // and the parent does not need distribution, return false to allow\n\t    // the nodes to be added directly, after which children may be\n\t    // distributed and composed into the wrapping node(s)\n\t    return needsDist || (hasContent && !wrappedContent);\n\t  },\n\t\n\t  /* note: parent argument is required since node may have an out\n\t  of date parent at this point; returns true if a <content> is being added */\n\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t    var this$1 = this;\n\t\n\t    var added;\n\t    var insertionPointTag = root.getInsertionPointTag();\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t      !node.__noInsertionPoint) {\n\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t        np = tree.Logical.getParentNode(n);\n\t        // don't allow node's parent to be fragment itself\n\t        if (np === node) {\n\t          np = parent;\n\t        }\n\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t        added = added || na;\n\t      }\n\t    } else if (node.localName === insertionPointTag) {\n\t      tree.Logical.saveChildNodes(parent);\n\t      tree.Logical.saveChildNodes(node);\n\t      added = true;\n\t    }\n\t    return added;\n\t  },\n\t\n\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t    return node && node.shadyRoot &&\n\t      node.shadyRoot.hasInsertionPoint();\n\t  },\n\t\n\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t    var this$1 = this;\n\t\n\t    var hostNeedsDist;\n\t    var ip$ = root._insertionPoints;\n\t    for (var i=0; i<ip$.length; i++) {\n\t      var insertionPoint = ip$[i];\n\t      if (this$1._contains(container, insertionPoint)) {\n\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t        for (var j=0; j<dc$.length; j++) {\n\t          hostNeedsDist = true;\n\t          var node = dc$[j];\n\t          var parent = tree.Composed.getParentNode(node);\n\t          if (parent) {\n\t            tree.Composed.removeChild(parent, node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return hostNeedsDist;\n\t  },\n\t\n\t  _contains: function _contains(container, node) {\n\t    while (node) {\n\t      if (node == container) {\n\t        return true;\n\t      }\n\t      node = tree.Logical.getParentNode(node);\n\t    }\n\t  },\n\t\n\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t    var this$1 = this;\n\t\n\t    // optimization: only reset the tree if node is actually in a root\n\t    if (this._hasCachedOwnerRoot(node)) {\n\t      var c$ = tree.Logical.getChildNodes(node);\n\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t        this$1._removeOwnerShadyRoot(n);\n\t      }\n\t    }\n\t    node.__ownerShadyRoot = undefined;\n\t  },\n\t\n\t  // TODO(sorvell): This will fail if distribution that affects this\n\t  // question is pending; this is expected to be exceedingly rare, but if\n\t  // the issue comes up, we can force a flush in this case.\n\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t    var root = this.getRootNode(insertionPoint);\n\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t      // means that we're composed to this spot.\n\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t        return n;\n\t      }\n\t    }\n\t  },\n\t\n\t  clearNode: function clearNode(node) {\n\t    while (node.firstChild) {\n\t      node.removeChild(node.firstChild);\n\t    }\n\t  },\n\t\n\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t    var parent = tree.Logical.getParentNode(node);\n\t    if (this._nodeNeedsDistribution(parent)) {\n\t      parent.shadyRoot.update();\n\t      return true;\n\t    }\n\t  },\n\t\n\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t    if (name === 'slot') {\n\t      this.maybeDistributeParent(node);\n\t    } else if (node.localName === 'slot' && name === 'name') {\n\t      var root = this.ownerShadyRootForNode(node);\n\t      if (root) {\n\t        root.update();\n\t      }\n\t    }\n\t  },\n\t\n\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t  // but it's also generally useful to recurse through the element tree\n\t  // and is used by Polymer's styling system.\n\t  query: function query(node, matcher, halter) {\n\t    var list = [];\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t    return list;\n\t  },\n\t\n\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t    var this$1 = this;\n\t\n\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t          this$1._queryElement(c, matcher, halter, list)) {\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t    var result = matcher(node);\n\t    if (result) {\n\t      list.push(node);\n\t    }\n\t    if (halter && halter(result)) {\n\t      return result;\n\t    }\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t  },\n\t\n\t  activeElementForNode: function activeElementForNode(node) {\n\t    var this$1 = this;\n\t\n\t    var active = document.activeElement;\n\t    if (!active) {\n\t      return null;\n\t    }\n\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t    if (node !== document) {\n\t      // If this node isn't a document or shady root, then it doesn't have\n\t      // an active element.\n\t      if (!isShadyRoot$$1) {\n\t        return null;\n\t      }\n\t      // If this shady root's host is the active element or the active\n\t      // element is not a descendant of the host (in the composed tree),\n\t      // then it doesn't have an active element.\n\t      if (node.host === active ||\n\t          !node.host.contains(active)) {\n\t        return null;\n\t      }\n\t    }\n\t    // This node is either the document or a shady root of which the active\n\t    // element is a (composed) descendant of its host; iterate upwards to\n\t    // find the active element's most shallow host within it.\n\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t    while (activeRoot && activeRoot !== node) {\n\t      active = activeRoot.host;\n\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t    }\n\t    if (node === document) {\n\t      // This node is the document, so activeRoot should be null.\n\t      return activeRoot ? null : active;\n\t    } else {\n\t      // This node is a non-document shady root, and it should be\n\t      // activeRoot.\n\t      return activeRoot === node ? active : null;\n\t    }\n\t  }\n\t\n\t};\n\t\n\tvar nativeCloneNode = Element.prototype.cloneNode;\n\tvar nativeImportNode = Document.prototype.importNode;\n\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\n\tvar setAttribute = function(attr, value) {\n\t  if (window.ShadyCSS && attr === 'class') {\n\t    window.ShadyCSS.setElementClass(this, value);\n\t  } else {\n\t    nativeSetAttribute.call(this, attr, value);\n\t  }\n\t}\n\t\n\tvar NodeMixin = {};\n\t\n\tObject.defineProperties(NodeMixin, {\n\t\n\t  parentElement: {\n\t    get: function get() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  parentNode: {\n\t    get: function get$1() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextSibling: {\n\t    get: function get$2() {\n\t      return tree.Logical.getNextSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousSibling: {\n\t    get: function get$3() {\n\t      return tree.Logical.getPreviousSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextElementSibling: {\n\t    get: function get$4() {\n\t      return tree.Logical.getNextElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousElementSibling: {\n\t    get: function get$5() {\n\t      return tree.Logical.getPreviousElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  assignedSlot: {\n\t    get: function get$6() {\n\t      return this._assignedSlot;\n\t    },\n\t    configurable: true\n\t  }\n\t});\n\t\n\tvar FragmentMixin = {\n\t\n\t  appendChild: function appendChild(node) {\n\t    return this.insertBefore(node);\n\t  },\n\t\n\t  // cases in which we may not be able to just do standard native call\n\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t  // has an insertion point)\n\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t  // container to container.host.\n\t  // 3. node is <content> (host of container needs distribution)\n\t  insertBefore: function insertBefore(node, ref_node) {\n\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t        'of this node');\n\t    }\n\t    // remove node from its current position iff it's in a tree.\n\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var parent = tree.Logical.getParentNode(node);\n\t      mixinImpl.removeNodeFromParent(node, parent);\n\t    }\n\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t      if (ref_node) {\n\t        // if ref_node is an insertion point replace with first distributed node\n\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t        if (root) {\n\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t        }\n\t      }\n\t      // if adding to a shadyRoot, add to host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host : this;\n\t      if (ref_node) {\n\t        tree.Composed.insertBefore(container, node, ref_node);\n\t      } else {\n\t        tree.Composed.appendChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, node);\n\t    return node;\n\t  },\n\t\n\t  /**\n\t    Removes the given `node` from the element's `lightChildren`.\n\t    This method also performs dom composition.\n\t  */\n\t  removeChild: function removeChild(node) {\n\t    if (tree.Logical.getParentNode(node) !== this) {\n\t      throw Error('The node to be removed is not a child of this node: ' +\n\t        node);\n\t    }\n\t    if (!mixinImpl.removeNode(node)) {\n\t      // if removing from a shadyRoot, remove form host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host :\n\t        this;\n\t      // not guaranteed to physically be in container; e.g.\n\t      // undistributed nodes.\n\t      var parent = tree.Composed.getParentNode(node);\n\t      if (container === parent) {\n\t        tree.Composed.removeChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, null, node);\n\t    return node;\n\t  },\n\t\n\t  replaceChild: function replaceChild(node, ref_node) {\n\t    this.insertBefore(node, ref_node);\n\t    this.removeChild(ref_node);\n\t    return node;\n\t  },\n\t\n\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t  querySelector: function querySelector(selector) {\n\t    // match selector and halt on first result.\n\t    var result = mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    }, function(n) {\n\t      return Boolean(n);\n\t    })[0];\n\t    return result || null;\n\t  },\n\t\n\t  querySelectorAll: function querySelectorAll(selector) {\n\t    return mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    });\n\t  },\n\t\n\t  cloneNode: function cloneNode(deep) {\n\t    if (this.localName == 'template') {\n\t      return nativeCloneNode.call(this, deep);\n\t    } else {\n\t      var n = nativeCloneNode.call(this, false);\n\t      if (deep) {\n\t        var c$ = this.childNodes;\n\t        for (var i=0, nc; i < c$.length; i++) {\n\t          nc = c$[i].cloneNode(true);\n\t          n.appendChild(nc);\n\t        }\n\t      }\n\t      return n;\n\t    }\n\t  },\n\t\n\t  importNode: function importNode(externalNode, deep) {\n\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t    var doc = this instanceof Document ? this :\n\t      this.ownerDocument;\n\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t    if (deep) {\n\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t      common.patchNode(n);\n\t      for (var i=0, nc; i < c$.length; i++) {\n\t        nc = doc.importNode(c$[i], true);\n\t        n.appendChild(nc);\n\t      }\n\t    }\n\t    return n;\n\t  }\n\t};\n\t\n\tObject.defineProperties(FragmentMixin, {\n\t\n\t  childNodes: {\n\t    get: function get$7() {\n\t      var c$ = tree.Logical.getChildNodes(this);\n\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  children: {\n\t    get: function get$8() {\n\t      if (tree.Logical.hasChildNodes(this)) {\n\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t        });\n\t      } else {\n\t        return tree.arrayCopyChildren(this);\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstChild: {\n\t    get: function get$9() {\n\t      return tree.Logical.getFirstChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastChild: {\n\t    get: function get$10() {\n\t      return tree.Logical.getLastChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstElementChild: {\n\t    get: function get$11() {\n\t      return tree.Logical.getFirstElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastElementChild: {\n\t    get: function get$12() {\n\t      return tree.Logical.getLastElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t  // textContent / innerHTML\n\t  textContent: {\n\t    get: function get$13() {\n\t      if (this.childNodes) {\n\t        var tc = [];\n\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t            tc.push(c.textContent);\n\t          }\n\t        }\n\t        return tc.join('');\n\t      }\n\t      return '';\n\t    },\n\t    set: function set(text) {\n\t      mixinImpl.clearNode(this);\n\t      if (text) {\n\t        this.appendChild(document.createTextNode(text));\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  innerHTML: {\n\t    get: function get$14() {\n\t      return getInnerHTML(this);\n\t    },\n\t    set: function set$1(text) {\n\t      var this$1 = this;\n\t\n\t      mixinImpl.clearNode(this);\n\t      var d = document.createElement('div');\n\t      d.innerHTML = text;\n\t      // here, appendChild may move nodes async so we cannot rely\n\t      // on node position when copying\n\t      var c$ = tree.arrayCopyChildNodes(d);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1.appendChild(c$[i]);\n\t      }\n\t    },\n\t    configurable: true\n\t  }\n\t\n\t});\n\t\n\tvar ElementMixin = {\n\t\n\t  // TODO(sorvell): should only exist on <slot>\n\t  assignedNodes: function assignedNodes(options) {\n\t    return (options && options.flatten ? this._distributedNodes :\n\t      this._assignedNodes) || [];\n\t  },\n\t\n\t\n\t  setAttribute: function setAttribute$1(name, value) {\n\t    setAttribute.call(this, name, value);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  },\n\t\n\t  removeAttribute: function removeAttribute(name) {\n\t    nativeRemoveAttribute.call(this, name);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  }\n\t\n\t};\n\t\n\tObject.defineProperties(ElementMixin, {\n\t\n\t  shadowRoot: {\n\t    get: function get$15() {\n\t      return this.shadyRoot;\n\t    }\n\t  },\n\t\n\t  slot: {\n\t    get: function get$16() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set$2(value) {\n\t      this.setAttribute('slot', value);\n\t    }\n\t  }\n\t\n\t});\n\t\n\tvar activeElementDescriptor = {\n\t  get: function get$17() {\n\t    return mixinImpl.activeElementForNode(this);\n\t  }\n\t}\n\t\n\tvar ActiveElementMixin = {};\n\tObject.defineProperties(ActiveElementMixin, {\n\t  activeElement: activeElementDescriptor\n\t});\n\t\n\tvar UnderActiveElementMixin = {};\n\tObject.defineProperties(UnderActiveElementMixin, {\n\t  _activeElement: activeElementDescriptor\n\t});\n\t\n\tvar Mixins = {\n\t\n\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\n\t  Fragment: extendAll({__patched: 'Fragment'},\n\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\n\t  Element: extendAll({__patched: 'Element'},\n\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\n\t  // Note: activeElement cannot be patched on document!\n\t  Document: extendAll({__patched: 'Document'},\n\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\n\t};\n\t\n\tvar getRootNode = function(node) {\n\t  return mixinImpl.getRootNode(node);\n\t}\n\t\n\tfunction filterMutations(mutations, target) {\n\t  var targetRootNode = getRootNode(target);\n\t  return mutations.filter(function(mutation) {\n\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t    if (mutationInScope && mutation.addedNodes) {\n\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t        return (targetRootNode === getRootNode(n));\n\t      });\n\t      Object.defineProperty(mutation, 'addedNodes', {\n\t        value: nodes,\n\t        configurable: true\n\t      });\n\t    }\n\t    return mutationInScope &&\n\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t  });\n\t}\n\t\n\t// const promise = Promise.resolve();\n\t\n\tvar AsyncObserver = function AsyncObserver() {\n\t  this._scheduled = false;\n\t  this.addedNodes = [];\n\t  this.removedNodes = [];\n\t  this.callbacks = new Set();\n\t};\n\t\n\tAsyncObserver.prototype.schedule = function schedule () {\n\t    var this$1 = this;\n\t\n\t  if (!this._scheduled) {\n\t    this._scheduled = true;\n\t    promish.then(function () {\n\t      this$1.flush();\n\t    });\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.flush = function flush () {\n\t  if (this._scheduled) {\n\t    this._scheduled = false;\n\t    var mutations = this.takeRecords();\n\t    if (mutations.length) {\n\t      this.callbacks.forEach(function(cb) {\n\t        cb(mutations);\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t    var mutations = [{\n\t      addedNodes: this.addedNodes,\n\t      removedNodes: this.removedNodes\n\t    }];\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    return mutations;\n\t  }\n\t  return [];\n\t};\n\t\n\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t// directly so that users do not have to fork their code.\n\t// Supporting the entire api may be challenging: e.g. filtering out\n\t// removed nodes in the wrong scope and seeing non-distributing\n\t// subtree child mutations.\n\tvar observeChildren = function(node, callback) {\n\t  common.patchNode(node);\n\t  if (!node.__dom.observer) {\n\t    node.__dom.observer = new AsyncObserver();\n\t  }\n\t  node.__dom.observer.callbacks.add(callback);\n\t  var observer = node.__dom.observer;\n\t  return {\n\t    _callback: callback,\n\t    _observer: observer,\n\t    _node: node,\n\t    takeRecords: function takeRecords() {\n\t      return observer.takeRecords()\n\t    }\n\t  };\n\t}\n\t\n\tvar unobserveChildren = function(handle) {\n\t  var observer = handle && handle._observer;\n\t  if (observer) {\n\t    observer.callbacks.delete(handle._callback);\n\t    if (!observer.callbacks.size) {\n\t      handle._node.__dom.observer = null;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tvar patchedCount = 0;\n\t\n\tvar log = false;\n\t\n\tvar patchImpl = {\n\t\n\t  canPatchNode: function(node) {\n\t    switch (node) {\n\t      case document.head:\n\t      case document.documentElement:\n\t        return false;\n\t      default:\n\t        return true;\n\t    }\n\t  },\n\t\n\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t    window.Node.prototype, 'textContent')),\n\t\n\t  patch: function(node) {\n\t    patchedCount++;\n\t    log && window.console.warn('patch node', node);\n\t    if (this.hasPrototypeDescriptors) {\n\t      patchPrototype(node, this.mixinForObject(node));\n\t    } else {\n\t      window.console.warn('Patching instance rather than prototype', node);\n\t      extend(node, this.mixinForNode(node));\n\t    }\n\t  },\n\t\n\t  mixinForObject: function(obj) {\n\t    switch (obj.nodeType) {\n\t      case Node.ELEMENT_NODE:\n\t        return Mixins.Element;\n\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t        return Mixins.Fragment;\n\t      case Node.DOCUMENT_NODE:\n\t        return Mixins.Document;\n\t      case Node.TEXT_NODE:\n\t      case Node.COMMENT_NODE:\n\t        return Mixins.Node;\n\t    }\n\t  },\n\t\n\t  unpatch: function(obj) {\n\t    if (obj.__sourceProto) {\n\t      obj.__proto__ = obj.__sourceProto;\n\t\n\t    }\n\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t  }\n\t\n\t};\n\t\n\tfunction patchNode(node) {\n\t  if (!settings.inUse) {\n\t    return;\n\t  }\n\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t    tree.saveChildNodes(node);\n\t    patchImpl.patch(node);\n\t  }\n\t}\n\t\n\tfunction unpatchNode(node) {\n\t  patchImpl.unpatch(node);\n\t}\n\t\n\tfunction isNodePatched(node) {\n\t  return Boolean(node.__patched);\n\t}\n\t\n\t// TODO(sorvell): fake export\n\tcommon.patchNode = patchNode;\n\tcommon.isNodePatched = isNodePatched;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar origAddEventListener = Element.prototype.addEventListener;\n\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\n\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\tvar alwaysComposed = {\n\t  blur: true,\n\t  focus: true,\n\t  focusin: true,\n\t  focusout: true,\n\t  click: true,\n\t  dblclick: true,\n\t  mousedown: true,\n\t  mouseenter: true,\n\t  mouseleave: true,\n\t  mousemove: true,\n\t  mouseout: true,\n\t  mouseover: true,\n\t  mouseup: true,\n\t  wheel: true,\n\t  beforeinput: true,\n\t  input: true,\n\t  keydown: true,\n\t  keyup: true,\n\t  compositionstart: true,\n\t  compositionupdate: true,\n\t  compositionend: true,\n\t  touchstart: true,\n\t  touchend: true,\n\t  touchmove: true,\n\t  touchcancel: true,\n\t  pointerover: true,\n\t  pointerenter: true,\n\t  pointerdown: true,\n\t  pointermove: true,\n\t  pointerup: true,\n\t  pointercancel: true,\n\t  pointerout: true,\n\t  pointerleave: true,\n\t  gotpointercapture: true,\n\t  lostpointercapture: true,\n\t  dragstart: true,\n\t  drag: true,\n\t  dragenter: true,\n\t  dragleave: true,\n\t  dragover: true,\n\t  drop: true,\n\t  dragend: true,\n\t  DOMActivate: true,\n\t  DOMFocusIn: true,\n\t  DOMFocusOut: true,\n\t  keypress: true\n\t};\n\t\n\tfunction pathComposer(startNode, composed) {\n\t  var composedPath = [];\n\t  var current = startNode;\n\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t  while (current) {\n\t    composedPath.push(current);\n\t    if (current.assignedSlot) {\n\t      current = current.assignedSlot;\n\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t      current = current.host;\n\t    } else {\n\t      current = current.parentNode;\n\t    }\n\t  }\n\t  // event composedPath includes window when startNode's ownerRoot is document\n\t  if (composedPath[composedPath.length - 1] === document) {\n\t    composedPath.push(window);\n\t  }\n\t  return composedPath;\n\t}\n\t\n\tfunction retarget(refNode, path) {\n\t  if (!isShadyRoot) {\n\t    return refNode;\n\t  }\n\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t  var refNodePath = pathComposer(refNode, true);\n\t  var p$ = path;\n\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t    ancestor = p$[i];\n\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t    if (root !== lastRoot) {\n\t      rootIdx = refNodePath.indexOf(root);\n\t      lastRoot = root;\n\t    }\n\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t      return ancestor;\n\t    }\n\t  }\n\t}\n\t\n\tvar EventMixin = {\n\t\n\t  __patched: 'Event',\n\t\n\t  get composed() {\n\t    if (this.isTrusted && this.__composed === undefined) {\n\t      this.__composed = alwaysComposed[this.type];\n\t    }\n\t    return this.__composed || false;\n\t  },\n\t\n\t  composedPath: function composedPath() {\n\t    if (!this.__composedPath) {\n\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t    }\n\t    return this.__composedPath;\n\t  },\n\t\n\t  get target() {\n\t    return retarget(this.currentTarget, this.composedPath());\n\t  },\n\t\n\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t  get relatedTarget() {\n\t    if (!this.__relatedTarget) {\n\t      return null;\n\t    }\n\t    if (!this.__relatedTargetComposedPath) {\n\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t    }\n\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t  },\n\t  stopPropagation: function stopPropagation() {\n\t    Event.prototype.stopPropagation.call(this);\n\t    this.__propagationStopped = true;\n\t  },\n\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t    Event.prototype.stopImmediatePropagation.call(this);\n\t    this.__immediatePropagationStopped = true;\n\t    this.__propagationStopped = true;\n\t  }\n\t\n\t};\n\t\n\tfunction mixinComposedFlag(Base) {\n\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t  // try to do `Base.call` with a dom construtor.\n\t  var klazz = function(type, options) {\n\t    var event = new Base(type, options);\n\t    event.__composed = options && Boolean(options.composed);\n\t    return event;\n\t  }\n\t  // put constructor properties on subclass\n\t  mixin(klazz, Base);\n\t  klazz.prototype = Base.prototype;\n\t  return klazz;\n\t}\n\t\n\tvar nonBubblingEventsToRetarget = {\n\t  focus: true,\n\t  blur: true\n\t};\n\t\n\tfunction fireHandlers(event, node, phase) {\n\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t    node.__handlers[event.type][phase];\n\t  if (hs) {\n\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t      fn.call(node, event);\n\t      if (event.__immediatePropagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction retargetNonBubblingEvent(e) {\n\t  var path = e.composedPath();\n\t  var node;\n\t  // override `currentTarget` to let patched `target` calculate correctly\n\t  Object.defineProperty(e, 'currentTarget', {\n\t    get: function() {\n\t      return node;\n\t    },\n\t    configurable: true\n\t  });\n\t  for (var i = path.length - 1; i >= 0; i--) {\n\t    node = path[i];\n\t    // capture phase fires all capture handlers\n\t    fireHandlers(e, node, 'capture');\n\t    if (e.__propagationStopped) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  // set the event phase to `AT_TARGET` as in spec\n\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\n\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t  // keep track of the last seen owner root\n\t  var lastFiredRoot;\n\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t    node = path[i$1];\n\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t      fireHandlers(e, node, 'bubble');\n\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t      if (node !== window) {\n\t        lastFiredRoot = node.getRootNode();\n\t      }\n\t      if (e.__propagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t  // It's more efficient to store the node/type/options information as Array in\n\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  if (fn.__eventWrappers) {\n\t    // Stop if the wrapper function has already been created.\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        return;\n\t      }\n\t    }\n\t  } else {\n\t    fn.__eventWrappers = [];\n\t  }\n\t\n\t  var wrapperFn = function(e) {\n\t    // Support `once` option.\n\t    if (once) {\n\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t    }\n\t    if (!e.__target) {\n\t      e.__target = e.target;\n\t      e.__relatedTarget = e.relatedTarget;\n\t      patchPrototype(e, EventMixin);\n\t    }\n\t    // There are two critera that should stop events from firing on this node\n\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t        if (e.target === e.relatedTarget) {\n\t          e.stopImmediatePropagation();\n\t          return;\n\t        }\n\t      }\n\t      return fn(e);\n\t    }\n\t  };\n\t  // Store the wrapper information.\n\t  fn.__eventWrappers.push({\n\t    node: this,\n\t    type: type,\n\t    capture: capture,\n\t    once: once,\n\t    passive: passive,\n\t    wrapperFn: wrapperFn\n\t  });\n\t\n\t  if (nonBubblingEventsToRetarget[type]) {\n\t    this.__handlers = this.__handlers || {};\n\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t  } else {\n\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  // Search the wrapped function.\n\t  var wrapperFn = undefined;\n\t  if (fn.__eventWrappers) {\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t        // Cleanup.\n\t        if (!fn.__eventWrappers.length) {\n\t          fn.__eventWrappers = undefined;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t      this.__handlers && this.__handlers[type]) {\n\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t    var idx = arr.indexOf(wrapperFn);\n\t    if (idx > -1) {\n\t      arr.splice(idx, 1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction activateFocusEventOverrides() {\n\t  for (var ev in nonBubblingEventsToRetarget) {\n\t    window.addEventListener(ev, function(e) {\n\t      if (!e.__target) {\n\t        e.__target = e.target;\n\t        e.__relatedTarget = e.relatedTarget;\n\t        patchPrototype(e, EventMixin);\n\t        retargetNonBubblingEvent(e);\n\t        e.stopImmediatePropagation();\n\t      }\n\t    }, true);\n\t  }\n\t}\n\t\n\t\n\tvar PatchedEvent = mixinComposedFlag(Event);\n\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tif (settings.inUse) {\n\t\n\t  window.ShadyDOM = {\n\t    tree: tree,\n\t    getNativeProperty: getNativeProperty,\n\t    patch: patchNode,\n\t    isPatched: isNodePatched,\n\t    unpatch: unpatchNode,\n\t    isShadyRoot: isShadyRoot,\n\t    enqueue: enqueue,\n\t    flush: flush$1,\n\t    inUse: settings.inUse,\n\t    filterMutations: filterMutations,\n\t    observeChildren: observeChildren,\n\t    unobserveChildren: unobserveChildren\n\t  };\n\t\n\t  var createRootAndEnsurePatched = function(node) {\n\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t    // a timing problem with gathering composed children.\n\t    // (1) currently the child list is crawled and patched when patching occurs\n\t    // (this needs to change)\n\t    // (2) we can only patch when an element has received its parsed children\n\t    // because we cannot detect them when inserted by parser.\n\t    // let ancestor = node;\n\t    // while (ancestor) {\n\t    //   patchNode(ancestor);\n\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t    // }\n\t    patchNode(node);\n\t    var root = new ShadyRoot(node);\n\t    patchNode(root);\n\t    return root;\n\t  }\n\t\n\t  Element.prototype.attachShadow = function() {\n\t    return createRootAndEnsurePatched(this);\n\t  }\n\t\n\t  Node.prototype.addEventListener = addEventListener;\n\t  Node.prototype.removeEventListener = removeEventListener;\n\t  Event = PatchedEvent;\n\t  CustomEvent = PatchedCustomEvent;\n\t  MouseEvent = PatchedMouseEvent;\n\t  activateFocusEventOverrides();\n\t\n\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t    get: function get() {\n\t      return document.documentElement.contains(this);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Node.prototype.getRootNode = function(options) {\n\t    return getRootNode(this, options);\n\t  }\n\t\n\t  Object.defineProperty(Element.prototype, 'slot', {\n\t    get: function get$1() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set(value) {\n\t      this.setAttribute('slot', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t    get: function get$2() {\n\t      return this._assignedSlot || null;\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Element.prototype.setAttribute = setAttribute;\n\t\n\t  Object.defineProperty(Element.prototype, 'className', {\n\t    get: function get$3() {\n\t      return this.getAttribute('class');\n\t    },\n\t    set: function set$1(value) {\n\t      this.setAttribute('class', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t  // via appendChild. This either needs to be expanded or contracted.\n\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t  //   patchNode(this);\n\t  //   return this.appendChild(node);\n\t  // }\n\t\n\t}\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadydom.min.js.map\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tExtremely simple css parser. Intended to be not more than what we need\n\tand definitely not necessarily correct =).\n\t*/\n\t\n\t// given a string of css, return a simple rule tree\n\t\n\tfunction parse(text) {\n\t  text = clean(text);\n\t  return parseCss(lex(text), text);\n\t}\n\t\n\t// remove stuff we don't care about that may hinder parsing\n\tfunction clean(cssText) {\n\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t}\n\t\n\t// super simple {...} lexer that returns a node tree\n\tfunction lex(text) {\n\t  var root = {\n\t    start: 0,\n\t    end: text.length\n\t  };\n\t  var n = root;\n\t  for (var i = 0, l = text.length; i < l; i++) {\n\t    if (text[i] === OPEN_BRACE) {\n\t      if (!n.rules) {\n\t        n.rules = [];\n\t      }\n\t      var p = n;\n\t      var previous = p.rules[p.rules.length - 1];\n\t      n = {\n\t        start: i + 1,\n\t        parent: p,\n\t        previous: previous\n\t      };\n\t      p.rules.push(n);\n\t    } else if (text[i] === CLOSE_BRACE) {\n\t      n.end = i + 1;\n\t      n = n.parent || root;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// add selectors/cssText to node tree\n\tfunction parseCss(node, text) {\n\t  var t = text.substring(node.start, node.end - 1);\n\t  node.parsedCssText = node.cssText = t.trim();\n\t  if (node.parent) {\n\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t    t = text.substring(ss, node.start - 1);\n\t    t = _expandUnicodeEscapes(t);\n\t    t = t.replace(RX.multipleSpaces, ' ');\n\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t    // helps with mixin syntax\n\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t    var s = node.parsedSelector = node.selector = t.trim();\n\t    node.atRule = s.indexOf(AT_START) === 0;\n\t    // note, support a subset of rule types...\n\t    if (node.atRule) {\n\t      if (s.indexOf(MEDIA_START) === 0) {\n\t        node.type = types.MEDIA_RULE;\n\t      } else if (s.match(RX.keyframesRule)) {\n\t        node.type = types.KEYFRAMES_RULE;\n\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t      }\n\t    } else {\n\t      if (s.indexOf(VAR_START) === 0) {\n\t        node.type = types.MIXIN_RULE;\n\t      } else {\n\t        node.type = types.STYLE_RULE;\n\t      }\n\t    }\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      parseCss(r, text);\n\t    }\n\t  }\n\t  return node;\n\t}\n\t\n\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t// expanded form that doesn't require trailing space `\\000033`\n\tfunction _expandUnicodeEscapes(s) {\n\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t    var code = arguments[1],\n\t        repeat = 6 - code.length;\n\t    while (repeat--) {\n\t      code = '0' + code;\n\t    }\n\t    return '\\\\' + code;\n\t  });\n\t}\n\t\n\t// stringify parsed css.\n\tfunction stringify(node, preserveProperties, text) {\n\t  text = text || '';\n\t  // calc rule cssText\n\t  var cssText = '';\n\t  if (node.cssText || node.rules) {\n\t    var r$ = node.rules;\n\t    if (r$ && !_hasMixinRules(r$)) {\n\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t        cssText = stringify(r, preserveProperties, cssText);\n\t      }\n\t    } else {\n\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t      cssText = cssText.trim();\n\t      if (cssText) {\n\t        cssText = '  ' + cssText + '\\n';\n\t      }\n\t    }\n\t  }\n\t  // emit rule if there is cssText\n\t  if (cssText) {\n\t    if (node.selector) {\n\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t    }\n\t    text += cssText;\n\t    if (node.selector) {\n\t      text += CLOSE_BRACE + '\\n\\n';\n\t    }\n\t  }\n\t  return text;\n\t}\n\t\n\tfunction _hasMixinRules(rules) {\n\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t}\n\t\n\tfunction removeCustomProps(cssText) {\n\t  cssText = removeCustomPropAssignment(cssText);\n\t  return removeCustomPropApply(cssText);\n\t}\n\t\n\tfunction removeCustomPropAssignment(cssText) {\n\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t}\n\t\n\tfunction removeCustomPropApply(cssText) {\n\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t}\n\t\n\tvar types = {\n\t  STYLE_RULE: 1,\n\t  KEYFRAMES_RULE: 7,\n\t  MEDIA_RULE: 4,\n\t  MIXIN_RULE: 1000\n\t};\n\t\n\tvar OPEN_BRACE = '{';\n\tvar CLOSE_BRACE = '}';\n\t\n\t// helper regexp's\n\tvar RX = {\n\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t  port: /@import[^;]*;/gim,\n\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t  multipleSpaces: /\\s+/g\n\t};\n\t\n\tvar VAR_START = '--';\n\tvar MEDIA_START = '@media';\n\tvar AT_START = '@';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\n\t// experimental support for native @apply\n\tfunction detectNativeApply() {\n\t  var style = document.createElement('style');\n\t  style.textContent = '.foo { @apply --foo }';\n\t  document.head.appendChild(style);\n\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t  document.head.removeChild(style);\n\t  return nativeCssApply;\n\t}\n\t\n\tvar nativeCssApply = false && detectNativeApply();\n\t\n\tfunction parseSettings(settings) {\n\t  if (settings) {\n\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t  }\n\t}\n\t\n\tif (window.ShadyCSS) {\n\t  parseSettings(window.ShadyCSS);\n\t} else if (window.WebComponents) {\n\t  parseSettings(window.WebComponents.flags);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction toCssText(rules, callback) {\n\t  if (typeof rules === 'string') {\n\t    rules = parse(rules);\n\t  }\n\t  if (callback) {\n\t    forEachRule(rules, callback);\n\t  }\n\t  return stringify(rules, nativeCssVariables);\n\t}\n\t\n\tfunction rulesForStyle(style) {\n\t  if (!style.__cssRules && style.textContent) {\n\t    style.__cssRules = parse(style.textContent);\n\t  }\n\t  return style.__cssRules;\n\t}\n\t\n\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t// like a normal selector but is not (it has nothing to do with scoping\n\t// for example).\n\tfunction isKeyframesSelector(rule) {\n\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t}\n\t\n\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t  if (!node) {\n\t    return;\n\t  }\n\t  var skipRules = false;\n\t  if (onlyActiveRules) {\n\t    if (node.type === types.MEDIA_RULE) {\n\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t      if (matchMedia) {\n\t        // if rule is a non matching @media rule, skip subrules\n\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t          skipRules = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (node.type === types.STYLE_RULE) {\n\t    styleRuleCallback(node);\n\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t    keyframesRuleCallback(node);\n\t  } else if (node.type === types.MIXIN_RULE) {\n\t    skipRules = true;\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$ && !skipRules) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t    }\n\t  }\n\t}\n\t\n\t// add a string of cssText to the document.\n\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t  var style = createScopeStyle(cssText, moniker);\n\t  return applyStyle$1(style, target, contextNode);\n\t}\n\t\n\tfunction applyStyle$1(style, target, contextNode) {\n\t  target = target || document.head;\n\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t  lastHeadApplyNode = style;\n\t  return target.insertBefore(style, after);\n\t}\n\t\n\tfunction createScopeStyle(cssText, moniker) {\n\t  var style = document.createElement('style');\n\t  if (moniker) {\n\t    style.setAttribute('scope', moniker);\n\t  }\n\t  style.textContent = cssText;\n\t  return style;\n\t}\n\t\n\tvar lastHeadApplyNode = null;\n\t\n\t// insert a comment node as a styling position placeholder.\n\tfunction applyStylePlaceHolder(moniker) {\n\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t  var scope = document.head;\n\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t  lastHeadApplyNode = placeHolder;\n\t  return placeHolder;\n\t}\n\t\n\t\n\t\n\t// cssBuildTypeForModule: function (module) {\n\t//   let dm = Polymer.DomModule.import(module);\n\t//   if (dm) {\n\t//     return getCssBuildType(dm);\n\t//   }\n\t// },\n\t//\n\t\n\t\n\t// Walk from text[start] matching parens\n\t// returns position of the outer end paren\n\tfunction findMatchingParen(text, start) {\n\t  var level = 0;\n\t  for (var i = start, l = text.length; i < l; i++) {\n\t    if (text[i] === '(') {\n\t      level++;\n\t    } else if (text[i] === ')') {\n\t      if (--level === 0) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tfunction processVariableAndFallback(str, callback) {\n\t  // find 'var('\n\t  var start = str.indexOf('var(');\n\t  if (start === -1) {\n\t    // no var?, everything is prefix\n\t    return callback(str, '', '', '');\n\t  }\n\t  //${prefix}var(${inner})${suffix}\n\t  var end = findMatchingParen(str, start + 3);\n\t  var inner = str.substring(start + 4, end);\n\t  var prefix = str.substring(0, start);\n\t  // suffix may have other variables\n\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t  var comma = inner.indexOf(',');\n\t  // value and fallback args should be trimmed to match in property lookup\n\t  if (comma === -1) {\n\t    // variable, no fallback\n\t    return callback(prefix, inner.trim(), '', suffix);\n\t  }\n\t  // var(${value},${fallback})\n\t  var value = inner.substring(0, comma).trim();\n\t  var fallback = inner.substring(comma + 1).trim();\n\t  return callback(prefix, value, fallback, suffix);\n\t}\n\t\n\tvar rx = {\n\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t  IS_VAR: /^--/,\n\t  BRACKETED: /\\{[^}]*\\}/g,\n\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\n\t* scoping:\n\t\n\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t  * selectors re-written as follows:\n\t\n\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\n\t* :host -> scopeName\n\t\n\t* :host(...) -> scopeName...\n\t\n\t* ::slotted(...) -> scopeName > ...\n\t\n\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\n\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\n\t*/\n\tvar SCOPE_NAME = 'style-scope';\n\t\n\tvar StyleTransformer = {\n\t\n\t  // Given a node and scope name, add a scoping class to each node\n\t  // in the tree. This facilitates transforming css into scoped rules.\n\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t    // one time optimization to skip scoping...\n\t    if (node.__styleScoped) {\n\t      node.__styleScoped = null;\n\t    } else {\n\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t    }\n\t  },\n\t\n\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t    if (node.classList) {\n\t      this.element(node, selector, shouldRemoveScope);\n\t    }\n\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t    if (c$) {\n\t      for (var i = 0; i < c$.length; i++) {\n\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t      }\n\t    }\n\t  },\n\t\n\t  element: function element(_element, scope, shouldRemoveScope) {\n\t    // note: if using classes, we add both the general 'style-scope' class\n\t    // as well as the specific scope. This enables easy filtering of all\n\t    // `style-scope` elements\n\t    if (scope) {\n\t      // note: svg on IE does not have classList so fallback to class\n\t      if (_element.classList) {\n\t        if (shouldRemoveScope) {\n\t          _element.classList.remove(SCOPE_NAME);\n\t          _element.classList.remove(scope);\n\t        } else {\n\t          _element.classList.add(SCOPE_NAME);\n\t          _element.classList.add(scope);\n\t        }\n\t      } else if (_element.getAttribute) {\n\t        var c = _element.getAttribute(CLASS);\n\t        if (shouldRemoveScope) {\n\t          if (c) {\n\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t          }\n\t        } else {\n\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t    var cssBuildType = element.__cssBuild;\n\t    // no need to shim selectors if settings.useNativeShadow, also\n\t    // a shady css build will already have transformed selectors\n\t    // NOTE: This method may be called as part of static or property shimming.\n\t    // When there is a targeted build it will not be called for static shimming,\n\t    // but when the property shim is used it is called and should opt out of\n\t    // static shimming work when a proper build exists.\n\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t    return cssText.trim();\n\t  },\n\t\n\t  // Given a string of cssText and a scoping string (scope), returns\n\t  // a string of scoped css where each selector is transformed to include\n\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t  // (e.g. :host) to use the scoping selector.\n\t  css: function css(rules, scope, ext, callback) {\n\t    var hostScope = this._calcHostScope(scope, ext);\n\t    scope = this._calcElementScope(scope);\n\t    var self = this;\n\t    return toCssText(rules, function (rule) {\n\t      if (!rule.isScoped) {\n\t        self.rule(rule, scope, hostScope);\n\t        rule.isScoped = true;\n\t      }\n\t      if (callback) {\n\t        callback(rule, scope, hostScope);\n\t      }\n\t    });\n\t  },\n\t\n\t  _calcElementScope: function _calcElementScope(scope) {\n\t    if (scope) {\n\t      return CSS_CLASS_PREFIX + scope;\n\t    } else {\n\t      return '';\n\t    }\n\t  },\n\t\n\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t    return ext ? '[is=' + scope + ']' : scope;\n\t  },\n\t\n\t  rule: function rule(_rule, scope, hostScope) {\n\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t  },\n\t\n\t  // transforms a css rule to a scoped rule.\n\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t    // against selectors (e.g. when calculating style properties)\n\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t  },\n\t\n\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t    // we want to skip transformation of rules that appear in keyframes,\n\t    // because they are keyframe selectors, not element selectors.\n\t    if (!isKeyframesSelector(rule)) {\n\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t      }\n\t    }\n\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t  },\n\t\n\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t    var _this = this;\n\t\n\t    var stop = false;\n\t    selector = selector.trim();\n\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t    });\n\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t      if (!stop) {\n\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t        stop = stop || info.stop;\n\t        c = info.combinator;\n\t        s = info.value;\n\t      }\n\t      return c + s;\n\t    });\n\t    return selector;\n\t  },\n\t\n\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t    // replace :host with host scoping class\n\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t    if (selector.indexOf(HOST) >= 0) {\n\t      selector = this._transformHostSelector(selector, hostScope);\n\t      // replace other selectors with scoping class\n\t    } else if (slottedIndex !== 0) {\n\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t    }\n\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t    // also ignore left-side combinator\n\t    var slotted = false;\n\t    if (slottedIndex >= 0) {\n\t      combinator = '';\n\t      slotted = true;\n\t    }\n\t    // process scope jumping selectors up to the scope jump and then stop\n\t    var stop = void 0;\n\t    if (slotted) {\n\t      stop = true;\n\t      if (slotted) {\n\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t          return ' > ' + paren;\n\t        });\n\t      }\n\t    }\n\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t    });\n\t    return { value: selector, combinator: combinator, stop: stop };\n\t  },\n\t\n\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t    p$[0] += scope;\n\t    return p$.join(PSEUDO_PREFIX);\n\t  },\n\t\n\t  // :host(...) -> scopeName...\n\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t    var m = selector.match(HOST_PAREN);\n\t    var paren = m && m[2].trim() || '';\n\t    if (paren) {\n\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t        // paren starts with a type selector\n\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t        // if the type selector is our hostScope then avoid pre-pending it\n\t        if (typeSelector === hostScope) {\n\t          return paren;\n\t          // otherwise, this selector should not match in this scope so\n\t          // output a bogus selector.\n\t        } else {\n\t          return SELECTOR_NO_MATCH;\n\t        }\n\t      } else {\n\t        // make sure to do a replace here to catch selectors like:\n\t        // `:host(.foo)::before`\n\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t          return hostScope + paren;\n\t        });\n\t      }\n\t      // if no paren, do a straight :host replacement.\n\t      // TODO(sorvell): this should not strictly be necessary but\n\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t      // which have been improperly used under Shady DOM. This should be\n\t      // deprecated.\n\t    } else {\n\t      return selector.replace(HOST, hostScope);\n\t    }\n\t  },\n\t\n\t  documentRule: function documentRule(rule) {\n\t    // reset selector in case this is redone.\n\t    rule.selector = rule.parsedSelector;\n\t    this.normalizeRootSelector(rule);\n\t    this._transformRule(rule, this._transformDocumentSelector);\n\t  },\n\t\n\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t    if (rule.selector === ROOT) {\n\t      rule.selector = 'html';\n\t    }\n\t  },\n\t\n\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t  },\n\t  SCOPE_NAME: SCOPE_NAME\n\t};\n\t\n\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\tvar COMPLEX_SELECTOR_SEP = ',';\n\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\tvar HOST = ':host';\n\tvar ROOT = ':root';\n\tvar SLOTTED = '::slotted';\n\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t// NOTE: this supports 1 nested () pair for things like\n\t// :host(:not([selected]), more general support requires\n\t// parsing which seems like overkill\n\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t// similar to HOST_PAREN\n\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\tvar CSS_CLASS_PREFIX = '.';\n\tvar PSEUDO_PREFIX = ':';\n\tvar CLASS = 'class';\n\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar StyleInfo = function () {\n\t  createClass(StyleInfo, null, [{\n\t    key: 'get',\n\t    value: function get(node) {\n\t      return node.__styleInfo;\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(node, styleInfo) {\n\t      node.__styleInfo = styleInfo;\n\t      return styleInfo;\n\t    }\n\t  }]);\n\t\n\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t    classCallCheck(this, StyleInfo);\n\t\n\t    this.styleRules = ast || null;\n\t    this.placeholder = placeholder || null;\n\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t    this.overrideStyleProperties = {};\n\t    this.elementName = elementName || '';\n\t    this.cssBuild = cssBuild || '';\n\t    this.typeExtension = typeExtension || '';\n\t    this.styleProperties = null;\n\t    this.scopeSelector = null;\n\t    this.customStyle = null;\n\t  }\n\t\n\t  return StyleInfo;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO: dedupe with shady\n\tvar p = window.Element.prototype;\n\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\n\tvar StyleProperties = {\n\t\n\t  // decorates styles with rule info and returns an array of used style\n\t  // property names\n\t  decorateStyles: function decorateStyles(rules) {\n\t    var self = this,\n\t        props = {},\n\t        keyframes = [],\n\t        ruleIndex = 0;\n\t    forEachRule(rules, function (rule) {\n\t      self.decorateRule(rule);\n\t      // mark in-order position of ast rule in styles block, used for cache key\n\t      rule.index = ruleIndex++;\n\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t    }, function onKeyframesRule(rule) {\n\t      keyframes.push(rule);\n\t    });\n\t    // Cache all found keyframes rules for later reference:\n\t    rules._keyframes = keyframes;\n\t    // return this list of property names *consumes* in these styles.\n\t    var names = [];\n\t    for (var i in props) {\n\t      names.push(i);\n\t    }\n\t    return names;\n\t  },\n\t\n\t  // decorate a single rule with property info\n\t  decorateRule: function decorateRule(rule) {\n\t    if (rule.propertyInfo) {\n\t      return rule.propertyInfo;\n\t    }\n\t    var info = {},\n\t        properties = {};\n\t    var hasProperties = this.collectProperties(rule, properties);\n\t    if (hasProperties) {\n\t      info.properties = properties;\n\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t      rule.rules = null;\n\t    }\n\t    info.cssText = this.collectCssText(rule);\n\t    rule.propertyInfo = info;\n\t    return info;\n\t  },\n\t\n\t  // collects the custom properties from a rule's cssText\n\t  collectProperties: function collectProperties(rule, properties) {\n\t    var info = rule.propertyInfo;\n\t    if (info) {\n\t      if (info.properties) {\n\t        Object.assign(properties, info.properties);\n\t        return true;\n\t      }\n\t    } else {\n\t      var m = void 0,\n\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t      var cssText = rule.parsedCssText;\n\t      var value = void 0;\n\t      var any = void 0;\n\t      while (m = rx$$1.exec(cssText)) {\n\t        // note: group 2 is var, 3 is mixin\n\t        value = (m[2] || m[3]).trim();\n\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t        if (value !== 'inherit' || value !== 'unset') {\n\t          properties[m[1].trim()] = value;\n\t        }\n\t        any = true;\n\t      }\n\t      return any;\n\t    }\n\t  },\n\t\n\t  // returns cssText of properties that consume variables/mixins\n\t  collectCssText: function collectCssText(rule) {\n\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t  },\n\t\n\t  // NOTE: we support consumption inside mixin assignment\n\t  // but not production, so strip out {...}\n\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t  },\n\t\n\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t    var m = void 0;\n\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t      var name = m[1];\n\t      // This regex catches all variable names, and following non-whitespace char\n\t      // If next char is not ':', then variable is a consumer\n\t      if (m[2] !== ':') {\n\t        props[name] = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  // turns custom properties into realized values.\n\t  reify: function reify(props) {\n\t    // big perf optimization here: reify only *own* properties\n\t    // since this object has __proto__ of the element's scope properties\n\t    var names = Object.getOwnPropertyNames(props);\n\t    for (var i = 0, n; i < names.length; i++) {\n\t      n = names[i];\n\t      props[n] = this.valueForProperty(props[n], props);\n\t    }\n\t  },\n\t\n\t  // given a property value, returns the reified value\n\t  // a property value may be:\n\t  // (1) a literal value like: red or 5px;\n\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t  // var(--a, var(--b));\n\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t  valueForProperty: function valueForProperty(property, props) {\n\t    var _this = this;\n\t\n\t    // case (1) default\n\t    // case (3) defines a mixin and we have to reify the internals\n\t    if (property) {\n\t      if (property.indexOf(';') >= 0) {\n\t        property = this.valueForProperties(property, props);\n\t      } else {\n\t        (function () {\n\t          // case (2) variable\n\t          var self = _this;\n\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t            if (!value) {\n\t              return prefix + suffix;\n\t            }\n\t            var propertyValue = self.valueForProperty(props[value], props);\n\t            // if value is \"initial\", then the variable should be treated as unset\n\t            if (!propertyValue || propertyValue === 'initial') {\n\t              // fallback may be --a or var(--a) or literal\n\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t              // for use with native css variables.\n\t              // Since we have full control, we can use `inherit` directly.\n\t              propertyValue = 'inherit';\n\t            }\n\t            return prefix + (propertyValue || '') + suffix;\n\t          };\n\t          property = processVariableAndFallback(property, fn);\n\t        })();\n\t      }\n\t    }\n\t    return property && property.trim() || '';\n\t  },\n\t\n\t  // note: we do not yet support mixin within mixin\n\t  valueForProperties: function valueForProperties(property, props) {\n\t    var parts = property.split(';');\n\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t      if (_p = parts[i]) {\n\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t        if (m) {\n\t          _p = this.valueForProperty(props[m[1]], props);\n\t        } else {\n\t          var colon = _p.indexOf(':');\n\t          if (colon !== -1) {\n\t            var pp = _p.substring(colon);\n\t            pp = pp.trim();\n\t            pp = this.valueForProperty(pp, props) || pp;\n\t            _p = _p.substring(0, colon) + pp;\n\t          }\n\t        }\n\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t        // strip trailing ;\n\t        _p.slice(0, -1) : _p || '';\n\t      }\n\t    }\n\t    return parts.join(';');\n\t  },\n\t\n\t  applyProperties: function applyProperties(rule, props) {\n\t    var output = '';\n\t    // dynamically added sheets may not be decorated so ensure they are.\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (rule.propertyInfo.cssText) {\n\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t  // functions which take in cssText and spit out transformed cssText.\n\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t    var input = rule.cssText;\n\t    var output = rule.cssText;\n\t    if (rule.hasAnimations == null) {\n\t      // Cache whether or not the rule has any animations to begin with:\n\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t    }\n\t    // If there are no animations referenced, we can skip transforms:\n\t    if (rule.hasAnimations) {\n\t      var transform = void 0;\n\t      // If we haven't transformed this rule before, we iterate over all\n\t      // transforms:\n\t      if (rule.keyframeNamesToTransform == null) {\n\t        rule.keyframeNamesToTransform = [];\n\t        for (var keyframe in keyframeTransforms) {\n\t          transform = keyframeTransforms[keyframe];\n\t          output = transform(input);\n\t          // If the transform actually changed the CSS text, we cache the\n\t          // transform name for future use:\n\t          if (input !== output) {\n\t            input = output;\n\t            rule.keyframeNamesToTransform.push(keyframe);\n\t          }\n\t        }\n\t      } else {\n\t        // If we already have a list of keyframe names that apply to this\n\t        // rule, we apply only those keyframe name transforms:\n\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t          input = transform(input);\n\t        }\n\t        output = input;\n\t      }\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Test if the rules in these styles matches the given `element` and if so,\n\t  // collect any custom properties into `props`.\n\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t    var props = {},\n\t        self = this;\n\t    // generates a unique key for these matches\n\t    var o = [];\n\t    // note: active rules excludes non-matching @media rules\n\t    forEachRule(rules, function (rule) {\n\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t      // time to only include ones that have properties\n\t      if (!rule.propertyInfo) {\n\t        self.decorateRule(rule);\n\t      }\n\t      // match element against transformedSelector: selector may contain\n\t      // unwanted uniquification and parsedSelector does not directly match\n\t      // for :host selectors.\n\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t          self.collectProperties(rule, props);\n\t          // produce numeric key for these matches for lookup\n\t          addToBitMask(rule.index, o);\n\t        }\n\t      }\n\t    }, null, true);\n\t    return { properties: props, key: o };\n\t  },\n\t\n\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (!rule.propertyInfo.properties) {\n\t      return;\n\t    }\n\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t    var parsedSelector = rule.parsedSelector;\n\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t    // build info is either in scope (when scope is an element) or in the style\n\t    // when scope is the default scope; note: this allows default scope to have\n\t    // mixed mode built and unbuilt styles.\n\t    if (cssBuild === 'shady') {\n\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t    }\n\t    if (cssBuild === 'shadow') {\n\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t      isHost = isHost && !isRoot;\n\t    }\n\t    if (!isRoot && !isHost) {\n\t      return;\n\t    }\n\t    var selectorToMatch = hostScope;\n\t    if (isHost) {\n\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t      if (nativeShadow && !rule.transformedSelector) {\n\t        // transform :host into a matchable selector\n\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t      }\n\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t    }\n\t    callback({\n\t      selector: selectorToMatch,\n\t      isHost: isHost,\n\t      isRoot: isRoot\n\t    });\n\t  },\n\t\n\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t    var hostProps = {},\n\t        rootProps = {},\n\t        self = this;\n\t    // note: active rules excludes non-matching @media rules\n\t    var cssBuild = rules && rules.__cssBuild;\n\t    forEachRule(rules, function (rule) {\n\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t        var element = scope._element || scope;\n\t        if (matchesSelector.call(element, info.selector)) {\n\t          if (info.isHost) {\n\t            self.collectProperties(rule, hostProps);\n\t          } else {\n\t            self.collectProperties(rule, rootProps);\n\t          }\n\t        }\n\t      });\n\t    }, null, true);\n\t    return { rootProps: rootProps, hostProps: hostProps };\n\t  },\n\t\n\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t    var self = this;\n\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t    var rules = StyleInfo.get(element).styleRules;\n\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t      self.applyProperties(rule, properties);\n\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t        // is not necessary to apply them in ShadowDOM.\n\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t      }\n\t    });\n\t  },\n\t\n\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t    var keyframesRules = rules._keyframes;\n\t    var keyframeTransforms = {};\n\t    if (!nativeShadow && keyframesRules) {\n\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t      // advance for the current scope. This allows us to catch keyframes\n\t      // rules that appear anywhere in the stylesheet:\n\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t      }\n\t    }\n\t    return keyframeTransforms;\n\t  },\n\t\n\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t  // particular scoped keyframes rule.\n\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t    return function (cssText) {\n\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t    };\n\t  },\n\t\n\t  // Transforms `@keyframes` names to be unique for the current host.\n\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t  },\n\t\n\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t  // have low specificity. They are overrideable by class selectors but,\n\t  // unfortunately, not by type selectors (e.g. overriding via\n\t  // `.special` is ok, but not by `x-foo`).\n\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    var selector = rule.transformedSelector;\n\t    var scope = '.' + scopeId;\n\t    var parts = selector.split(',');\n\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t    }\n\t    rule.selector = parts.join(',');\n\t  },\n\t\n\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t    var c = element.getAttribute('class') || '';\n\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t    if (c !== v) {\n\t      element.setAttribute('class', v);\n\t    }\n\t  },\n\t\n\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t    // calculate cssText to apply\n\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t    // if shady and we have a cached style that is not style, decrement\n\t    var styleInfo = StyleInfo.get(element);\n\t    var s = styleInfo.customStyle;\n\t    if (s && !nativeShadow && s !== style) {\n\t      s._useCount--;\n\t      if (s._useCount <= 0 && s.parentNode) {\n\t        s.parentNode.removeChild(s);\n\t      }\n\t    }\n\t    // apply styling always under native or if we generated style\n\t    // or the cached style is not in document(!)\n\t    if (nativeShadow) {\n\t      // update existing style only under native\n\t      if (styleInfo.customStyle) {\n\t        styleInfo.customStyle.textContent = cssText;\n\t        style = styleInfo.customStyle;\n\t        // otherwise, if we have css to apply, do so\n\t      } else if (cssText) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t      }\n\t    } else {\n\t      // shady and no cache hit\n\t      if (!style) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        if (cssText) {\n\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t        }\n\t        // shady and cache hit but not in document\n\t      } else if (!style.parentNode) {\n\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t      }\n\t    }\n\t    // ensure this style is our custom style and increment its use count.\n\t    if (style) {\n\t      style._useCount = style._useCount || 0;\n\t      // increment use count if we changed styles\n\t      if (styleInfo.customStyle != style) {\n\t        style._useCount++;\n\t      }\n\t      styleInfo.customStyle = style;\n\t    }\n\t    // @media rules may be stale in IE 10 and 11\n\t    if (IS_IE) {\n\t      style.textContent = style.textContent;\n\t    }\n\t    return style;\n\t  },\n\t\n\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t    var rules = rulesForStyle(style);\n\t    var self = this;\n\t    style.textContent = toCssText(rules, function (rule) {\n\t      var css = rule.cssText = rule.parsedCssText;\n\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t        // remove property assignments\n\t        // so next function isn't confused\n\t        // NOTE: we have 3 categories of css:\n\t        // (1) normal properties,\n\t        // (2) custom property assignments (--foo: red;),\n\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t        // are not and this makes this case unique.\n\t        css = removeCustomPropAssignment(css);\n\t        // replace with reified properties, scenario is same as mixin\n\t        rule.cssText = self.valueForProperties(css, properties);\n\t      }\n\t    });\n\t  },\n\t\n\t  rx: rx,\n\t  XSCOPE_NAME: 'x-scope'\n\t};\n\t\n\tfunction addToBitMask(n, bits) {\n\t  var o = parseInt(n / 32);\n\t  var v = 1 << n % 32;\n\t  bits[o] = (bits[o] || 0) | v;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar templateMap = {};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar placeholderMap = {};\n\t\n\tvar ce = window.customElements;\n\tif (ce && !nativeShadow) {\n\t  (function () {\n\t    var origDefine = ce.define;\n\t    ce.define = function (name, clazz, options) {\n\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t      return origDefine.call(ce, name, clazz, options);\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\tvar StyleCache = function () {\n\t  function StyleCache() {\n\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t    classCallCheck(this, StyleCache);\n\t\n\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t    this.cache = {};\n\t    this.typeMax = typeMax;\n\t  }\n\t\n\t  createClass(StyleCache, [{\n\t    key: '_validate',\n\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t        var pn = ownPropertyNames[idx];\n\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'store',\n\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t      var list = this.cache[tagname] || [];\n\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t      if (list.length > this.typeMax) {\n\t        list.shift();\n\t      }\n\t      this.cache[tagname] = list;\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t      var list = this.cache[tagname];\n\t      if (!list) {\n\t        return;\n\t      }\n\t      // reverse list for most-recent lookups\n\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t        var entry = list[idx];\n\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t          return entry;\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t  return StyleCache;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/**\n\t * The apply shim simulates the behavior of `@apply` proposed at\n\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t * The approach is to convert a property like this:\n\t *\n\t *    --foo: {color: red; background: blue;}\n\t *\n\t * to this:\n\t *\n\t *    --foo_-_color: red;\n\t *    --foo_-_background: blue;\n\t *\n\t * Then where `@apply --foo` is used, that is converted to:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background);\n\t *\n\t * This approach generally works but there are some issues and limitations.\n\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t * another element sets it to:\n\t *\n\t *    --foo: { border: 2px solid red; }\n\t *\n\t * We must now ensure that the color and background from the previous setting\n\t * do not apply. This is accomplished by changing the property set to this:\n\t *\n\t *    --foo_-_border: 2px solid red;\n\t *    --foo_-_color: initial;\n\t *    --foo_-_background: initial;\n\t *\n\t * This works but introduces one new issue.\n\t * Consider this setup at the point where the `@apply` is used:\n\t *\n\t *    background: orange;\n\t *    @apply --foo;\n\t *\n\t * In this case the background will be unset (initial) rather than the desired\n\t * `orange`. We address this by altering the property set to use a fallback\n\t * value like this:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background, orange);\n\t *    border: var(--foo_-_border);\n\t *\n\t * Note that the default is retained in the property set and the `background` is\n\t * the desired `orange`. This leads us to a limitation.\n\t *\n\t * Limitation 1:\n\t\n\t * Only properties in the rule where the `@apply`\n\t * is used are considered as default values.\n\t * If another rule matches the element and sets `background` with\n\t * less specificity than the rule in which `@apply` appears,\n\t * the `background` will not be set.\n\t *\n\t * Limitation 2:\n\t *\n\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t * `@apply` properties.\n\t\n\t*/\n\t\n\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\n\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\n\t// separator used between mixin-name and mixin-property-name when producing properties\n\t// NOTE: plain '-' may cause collisions in user styles\n\tvar MIXIN_VAR_SEP = '_-_';\n\t\n\t// map of mixin to property names\n\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\n\tvar MixinMap = function () {\n\t  function MixinMap() {\n\t    classCallCheck(this, MixinMap);\n\t\n\t    this._map = {};\n\t  }\n\t\n\t  createClass(MixinMap, [{\n\t    key: 'set',\n\t    value: function set(name, props) {\n\t      name = name.trim();\n\t      this._map[name] = {\n\t        properties: props,\n\t        dependants: {}\n\t      };\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(name) {\n\t      name = name.trim();\n\t      return this._map[name];\n\t    }\n\t  }]);\n\t  return MixinMap;\n\t}();\n\t\n\tvar ApplyShim = function () {\n\t  function ApplyShim() {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, ApplyShim);\n\t\n\t    this._currentTemplate = null;\n\t    this._measureElement = null;\n\t    this._map = new MixinMap();\n\t    this._separator = MIXIN_VAR_SEP;\n\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t    };\n\t  }\n\t\n\t  createClass(ApplyShim, [{\n\t    key: 'transformStyle',\n\t    value: function transformStyle(style, elementName) {\n\t      var ast = rulesForStyle(style);\n\t      this.transformRules(ast, elementName);\n\t      return ast;\n\t    }\n\t  }, {\n\t    key: 'transformRules',\n\t    value: function transformRules(rules, elementName) {\n\t      var _this2 = this;\n\t\n\t      this._currentTemplate = templateMap[elementName];\n\t      forEachRule(rules, function (r) {\n\t        _this2.transformRule(r);\n\t      });\n\t      if (this._currentTemplate) {\n\t        this._currentTemplate.__applyShimInvalid = false;\n\t      }\n\t      this._currentTemplate = null;\n\t    }\n\t  }, {\n\t    key: 'transformRule',\n\t    value: function transformRule(rule) {\n\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t      // :root was only used for variable assignment in property shim,\n\t      // but generates invalid selectors with real properties.\n\t      // replace with `:host > *`, which serves the same effect\n\t      if (rule.selector === ':root') {\n\t        rule.selector = ':host > *';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'transformCssText',\n\t    value: function transformCssText(cssText) {\n\t      // produce variables\n\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t      // consume mixins\n\t      return this._consumeCssProperties(cssText);\n\t    }\n\t  }, {\n\t    key: '_getInitialValueForProperty',\n\t    value: function _getInitialValueForProperty(property) {\n\t      if (!this._measureElement) {\n\t        this._measureElement = document.createElement('meta');\n\t        this._measureElement.style.all = 'initial';\n\t        document.head.appendChild(this._measureElement);\n\t      }\n\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t    }\n\t    // replace mixin consumption with variable consumption\n\t\n\t  }, {\n\t    key: '_consumeCssProperties',\n\t    value: function _consumeCssProperties(text) {\n\t      var m = void 0;\n\t      // loop over text until all mixins with defintions have been applied\n\t      while (m = MIXIN_MATCH.exec(text)) {\n\t        var matchText = m[0];\n\t        var mixinName = m[1];\n\t        var idx = m.index;\n\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t        var applyPos = idx + matchText.indexOf('@apply');\n\t        var afterApplyPos = idx + matchText.length;\n\t        // find props defined before this @apply\n\t        var textBeforeApply = text.slice(0, applyPos);\n\t        var textAfterApply = text.slice(afterApplyPos);\n\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t        // use regex match position to replace mixin, keep linear processing time\n\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t        // move regex search to _after_ replacement\n\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t      }\n\t      return text;\n\t    }\n\t    // produce variable consumption at the site of mixin consumption\n\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t    // Example:\n\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\n\t  }, {\n\t    key: '_atApplyToCssProperties',\n\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t      var vars = [];\n\t      var mixinEntry = this._map.get(mixinName);\n\t      // if we depend on a mixin before it is created\n\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t      if (!mixinEntry) {\n\t        this._map.set(mixinName, {});\n\t        mixinEntry = this._map.get(mixinName);\n\t      }\n\t      if (mixinEntry) {\n\t        if (this._currentTemplate) {\n\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t        }\n\t        var p = void 0,\n\t            parts = void 0,\n\t            f = void 0;\n\t        for (p in mixinEntry.properties) {\n\t          f = fallbacks && fallbacks[p];\n\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t          if (f) {\n\t            parts.push(',', f);\n\t          }\n\t          parts.push(')');\n\t          vars.push(parts.join(''));\n\t        }\n\t      }\n\t      return vars.join('; ');\n\t    }\n\t  }, {\n\t    key: '_replaceInitialOrInherit',\n\t    value: function _replaceInitialOrInherit(property, value) {\n\t      var match = INITIAL_INHERIT.exec(value);\n\t      if (match) {\n\t        if (match[1]) {\n\t          // initial\n\t          // replace `initial` with the concrete initial value for this property\n\t          value = ApplyShim._getInitialValueForProperty(property);\n\t        } else {\n\t          // inherit\n\t          // with this purposfully illegal value, the variable will be invalid at\n\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t          // and for inheriting values, will behave similarly\n\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t          value = 'apply-shim-inherit';\n\t        }\n\t      }\n\t      return value;\n\t    }\n\t\n\t    // \"parse\" a mixin definition into a map of properties and values\n\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\n\t  }, {\n\t    key: '_cssTextToMap',\n\t    value: function _cssTextToMap(text) {\n\t      var props = text.split(';');\n\t      var property = void 0,\n\t          value = void 0;\n\t      var out = {};\n\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t        p = props[i];\n\t        if (p) {\n\t          sp = p.split(':');\n\t          // ignore lines that aren't definitions like @media\n\t          if (sp.length > 1) {\n\t            property = sp[0].trim();\n\t            // some properties may have ':' in the value, like data urls\n\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t            out[property] = value;\n\t          }\n\t        }\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_invalidateMixinEntry',\n\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t      for (var elementName in mixinEntry.dependants) {\n\t        if (elementName !== this._currentTemplate) {\n\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_produceCssProperties',\n\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t      var _this3 = this;\n\t\n\t      // handle case where property value is a mixin\n\t      if (valueProperty) {\n\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t          if (value && _this3._map.get(value)) {\n\t            valueMixin = '@apply ' + value + ';';\n\t          }\n\t        });\n\t      }\n\t      if (!valueMixin) {\n\t        return matchText;\n\t      }\n\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t      var combinedProps = mixinValues;\n\t      var mixinEntry = this._map.get(propertyName);\n\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t      if (oldProps) {\n\t        // NOTE: since we use mixin, the map of properties is updated here\n\t        // and this is what we want.\n\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t      } else {\n\t        this._map.set(propertyName, combinedProps);\n\t      }\n\t      var out = [];\n\t      var p = void 0,\n\t          v = void 0;\n\t      // set variables defined by current mixin\n\t      var needToInvalidate = false;\n\t      for (p in combinedProps) {\n\t        v = mixinValues[p];\n\t        // if property not defined by current mixin, set initial\n\t        if (v === undefined) {\n\t          v = 'initial';\n\t        }\n\t        if (oldProps && !(p in oldProps)) {\n\t          needToInvalidate = true;\n\t        }\n\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t      }\n\t      if (needToInvalidate) {\n\t        this._invalidateMixinEntry(mixinEntry);\n\t      }\n\t      if (mixinEntry) {\n\t        mixinEntry.properties = combinedProps;\n\t      }\n\t      // because the mixinMap is global, the mixin might conflict with\n\t      // a different scope's simple variable definition:\n\t      // Example:\n\t      // some style somewhere:\n\t      // --mixin1:{ ... }\n\t      // --mixin2: var(--mixin1);\n\t      // some other element:\n\t      // --mixin1: 10px solid red;\n\t      // --foo: var(--mixin1);\n\t      // In this case, we leave the original variable definition in place.\n\t      if (valueProperty) {\n\t        prefix = matchText + ';' + prefix;\n\t      }\n\t      return prefix + out.join('; ') + ';';\n\t    }\n\t  }]);\n\t  return ApplyShim;\n\t}();\n\t\n\tvar applyShim = new ApplyShim();\n\twindow['ApplyShim'] = applyShim;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar flush = function flush() {};\n\t\n\tif (!nativeShadow) {\n\t  (function () {\n\t    var handler = function handler(mxns) {\n\t      for (var x = 0; x < mxns.length; x++) {\n\t        var mxn = mxns[x];\n\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t          var n = mxn.addedNodes[i];\n\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t            var root = n.getRootNode();\n\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t              // may no longer be in a shadowroot\n\t              var host = root.host;\n\t              if (host) {\n\t                var scope = host.is || host.localName;\n\t                StyleTransformer.dom(n, scope);\n\t              }\n\t            }\n\t          }\n\t        }\n\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t          var _n = mxn.removedNodes[_i];\n\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t            if (classIdx >= 0) {\n\t              // NOTE: relies on the scoping class always being adjacent to the\n\t              // SCOPE_NAME class.\n\t              var _scope = _n.classList[classIdx + 1];\n\t              if (_scope) {\n\t                StyleTransformer.dom(_n, _scope, true);\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var observer = new MutationObserver(handler);\n\t    var startState = 'interactive';\n\t\n\t    var start = function start() {\n\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t    };\n\t    if (window.HTMLImports) {\n\t      window.HTMLImports.whenReady(start);\n\t    } else if (document.readyState === startState) {\n\t      requestAnimationFrame(start);\n\t    } else {\n\t      document.addEventListener('readystatechange', function () {\n\t        if (document.readyState === startState) {\n\t          start();\n\t        }\n\t      });\n\t    }\n\t\n\t    flush = function flush() {\n\t      handler(observer.takeRecords());\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(dfreedm): consider spliting into separate global\n\tvar styleCache = new StyleCache();\n\t\n\tvar ShadyCSS = {\n\t  flush: flush,\n\t  scopeCounter: {},\n\t  nativeShadow: nativeShadow,\n\t  nativeCss: nativeCssVariables,\n\t  nativeCssApply: nativeCssApply,\n\t  _documentOwner: document.documentElement,\n\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t    return name + '-' + id;\n\t  },\n\t  getStyleAst: function getStyleAst(style) {\n\t    return rulesForStyle(style);\n\t  },\n\t  styleAstToString: function styleAstToString(ast) {\n\t    return toCssText(ast);\n\t  },\n\t  _gatherStyles: function _gatherStyles(template) {\n\t    var styles = template.content.querySelectorAll('style');\n\t    var cssText = [];\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var s = styles[i];\n\t      cssText.push(s.textContent);\n\t      s.parentNode.removeChild(s);\n\t    }\n\t    return cssText.join('').trim();\n\t  },\n\t  _getCssBuild: function _getCssBuild(template) {\n\t    var style = template.content.querySelector('style');\n\t    if (!style) {\n\t      return '';\n\t    }\n\t    return style.getAttribute('css-build') || '';\n\t  },\n\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t    if (template._prepared) {\n\t      return;\n\t    }\n\t    template._prepared = true;\n\t    template.name = elementName;\n\t    template.extends = typeExtension;\n\t    templateMap[elementName] = template;\n\t    var cssBuild = this._getCssBuild(template);\n\t    var cssText = this._gatherStyles(template);\n\t    var info = {\n\t      is: elementName,\n\t      extends: typeExtension,\n\t      __cssBuild: cssBuild\n\t    };\n\t    if (!this.nativeShadow) {\n\t      StyleTransformer.dom(template.content, elementName);\n\t    }\n\t    var ast = parse(cssText);\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      applyShim.transformRules(ast, elementName);\n\t    }\n\t    template._styleAst = ast;\n\t\n\t    var ownPropertyNames = [];\n\t    if (!this.nativeCss) {\n\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t    }\n\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t      var root = this.nativeShadow ? template.content : null;\n\t      var placeholder = placeholderMap[elementName];\n\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t      template._style = style;\n\t    }\n\t    template._ownPropertyNames = ownPropertyNames;\n\t  },\n\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t    if (cssText.length) {\n\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t    }\n\t  },\n\t  _prepareHost: function _prepareHost(host) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var typeExtension = void 0;\n\t    if (is !== host.localName) {\n\t      typeExtension = host.localName;\n\t    }\n\t    var placeholder = placeholderMap[is];\n\t    var template = templateMap[is];\n\t    var ast = void 0;\n\t    var ownStylePropertyNames = void 0;\n\t    var cssBuild = void 0;\n\t    if (template) {\n\t      ast = template._styleAst;\n\t      ownStylePropertyNames = template._ownPropertyNames;\n\t      cssBuild = template._cssBuild;\n\t    }\n\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t  },\n\t  applyStyle: function applyStyle(host, overrideProps) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    if (window.CustomStyle) {\n\t      var CS = window.CustomStyle;\n\t      if (CS._documentDirty) {\n\t        CS.findStyles();\n\t        if (!this.nativeCss) {\n\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t        } else if (!this.nativeCssApply) {\n\t          CS._revalidateApplyShim();\n\t        }\n\t        CS.applyStyles();\n\t        CS._documentDirty = false;\n\t      }\n\t    }\n\t    var styleInfo = StyleInfo.get(host);\n\t    if (!styleInfo) {\n\t      styleInfo = this._prepareHost(host);\n\t    }\n\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t    if (this.nativeCss) {\n\t      var template = templateMap[is];\n\t      if (template && template.__applyShimInvalid && template._style) {\n\t        // update template\n\t        applyShim.transformRules(template._styleAst, is);\n\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        // update instance if native shadowdom\n\t        if (this.nativeShadow) {\n\t          var style = host.shadowRoot.querySelector('style');\n\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        }\n\t        styleInfo.styleRules = template._styleAst;\n\t      }\n\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t    } else {\n\t      this._updateProperties(host, styleInfo);\n\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t        // TODO: use caching\n\t        this._applyStyleProperties(host, styleInfo);\n\t      }\n\t    }\n\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t    // note: some elements may not have a root!\n\t    if (root) {\n\t      this._applyToDescendants(root);\n\t    }\n\t  },\n\t  _applyToDescendants: function _applyToDescendants(root) {\n\t    var c$ = root.children;\n\t    for (var i = 0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (c.shadowRoot) {\n\t        this.applyStyle(c);\n\t      }\n\t      this._applyToDescendants(c);\n\t    }\n\t  },\n\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t    var root = node.getRootNode();\n\t    var host = root.host;\n\t    if (host) {\n\t      if (StyleInfo.get(host)) {\n\t        return host;\n\t      } else {\n\t        return this._styleOwnerForNode(host);\n\t      }\n\t    }\n\t    return this._documentOwner;\n\t  },\n\t  _isRootOwner: function _isRootOwner(node) {\n\t    return node === this._documentOwner;\n\t  },\n\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t    // only generate new scope if cached style is not found\n\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t    if (!this.nativeShadow) {\n\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t    }\n\t    if (!cacheEntry) {\n\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t    }\n\t    return style;\n\t  },\n\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t    var owner = this._styleOwnerForNode(host);\n\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t    var props = Object.create(ownerProperties || null);\n\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t    var propertiesMatchingHost = propertyData.properties;\n\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t    StyleProperties.reify(props);\n\t    styleInfo.styleProperties = props;\n\t  },\n\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t    for (var p in overrides) {\n\t      var v = overrides[p];\n\t      // skip override props if they are not truthy or 0\n\t      // in order to fall back to inherited values\n\t      if (v || v === 0) {\n\t        props[p] = v;\n\t      }\n\t    }\n\t  },\n\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t    // remove previous properties\n\t    for (var p in properties) {\n\t      // NOTE: for bc with shim, don't apply null values.\n\t      if (p === null) {\n\t        element.style.removeProperty(p);\n\t      } else {\n\t        element.style.setProperty(p, properties[p]);\n\t      }\n\t    }\n\t  },\n\t  updateStyles: function updateStyles(properties) {\n\t    if (window.CustomStyle) {\n\t      window.CustomStyle._documentDirty = true;\n\t    }\n\t    this.applyStyle(this._documentOwner, properties);\n\t  },\n\t\n\t  /* Custom Style operations */\n\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t    var _this = this;\n\t\n\t    var ast = rulesForStyle(style);\n\t    forEachRule(ast, function (rule) {\n\t      if (nativeShadow) {\n\t        StyleTransformer.normalizeRootSelector(rule);\n\t      } else {\n\t        StyleTransformer.documentRule(rule);\n\t      }\n\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t        applyShim.transformRule(rule);\n\t      }\n\t    });\n\t    if (this.nativeCss) {\n\t      style.textContent = toCssText(ast);\n\t    } else {\n\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t    }\n\t  },\n\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      var ast = rulesForStyle(style);\n\t      applyShim.transformRules(ast);\n\t      style.textContent = toCssText(ast);\n\t    }\n\t  },\n\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t    if (!this.nativeCss) {\n\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t    }\n\t  },\n\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t    var value = void 0;\n\t    if (!this.nativeCss) {\n\t      // element is either a style host, or an ancestor of a style host\n\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t      value = styleInfo.styleProperties[property];\n\t    }\n\t    // fall back to the property value from the computed styling\n\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t    // trim whitespace that can come after the `:` in css\n\t    // example: padding: 2px -> \" 2px\"\n\t    return value.trim();\n\t  },\n\t\n\t  // given an element and a classString, replaces\n\t  // the element's class with the provided classString and adds\n\t  // any necessary ShadyCSS static and property based scoping selectors\n\t  // NOTE: this method is suitable to be called in an environment in which\n\t  // setAttribute('class', ...) and className setter have been overridden so\n\t  // it cannot rely on those methods.\n\t  setElementClass: function setElementClass(element, classString) {\n\t    var _element$classList;\n\t\n\t    // use classList to clear existing classes\n\t    while (element.classList.length) {\n\t      element.classList.remove(element.classList[0]);\n\t    }\n\t    // add user classString\n\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t    // add static scoping: scope by shadyRoot\n\t    var root = element.getRootNode();\n\t    if (root.host) {\n\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t    }\n\t    // add property scoping: scope by special selector\n\t    if (!this.nativeCss) {\n\t      var styleInfo = StyleInfo.get(element);\n\t      if (styleInfo && styleInfo.scopeSelector) {\n\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t      }\n\t    }\n\t  },\n\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t    return StyleInfo.get(node);\n\t  }\n\t};\n\t\n\twindow['ShadyCSS'] = ShadyCSS;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\n\tExample:\n\t<shady-style>\n\t  <style>\n\t  ...\n\t  </style>\n\t</shady-style>\n\t*/\n\t\n\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\n\tvar enqueued = false;\n\t\n\tvar customStyles = [];\n\t\n\tvar hookFn = null;\n\t\n\t/*\n\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\tas all the instances will boot asynchronously after page load.\n\t\n\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t*/\n\tfunction enqueueDocumentValidation() {\n\t  if (enqueued) {\n\t    return;\n\t  }\n\t  enqueued = true;\n\t  if (window.HTMLImports) {\n\t    window.HTMLImports.whenReady(validateDocument);\n\t  } else if (document.readyState === 'complete') {\n\t    requestAnimationFrame(validateDocument);\n\t  } else {\n\t    document.addEventListener('readystatechange', function () {\n\t      if (document.readyState === 'complete') {\n\t        validateDocument();\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t// helps ensure that the first run of validateDocument will actually\n\t// have access to all the custom-style's created via loading imports.\n\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t// then the enqueue immediately calls validateDocument and work that could be\n\t// batched is not.\n\tenqueueDocumentValidation();\n\t\n\tfunction validateDocument() {\n\t  if (enqueued) {\n\t    ShadyCSS$1.updateStyles();\n\t    enqueued = false;\n\t  }\n\t}\n\t\n\tfunction CustomStyle() {\n\t  /*\n\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t  CustomElement polyfill replacement that can be `.call`ed\n\t  */\n\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t  customStyles.push(self);\n\t  enqueueDocumentValidation();\n\t  return self;\n\t}\n\t\n\tObject.defineProperties(CustomStyle, {\n\t  /*\n\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t   The function must take a <style> element as input, and return nothing.\n\t  */\n\t  processHook: {\n\t    get: function get() {\n\t      return hookFn;\n\t    },\n\t    set: function set(fn) {\n\t      hookFn = fn;\n\t      return fn;\n\t    }\n\t  },\n\t  _customStyles: {\n\t    get: function get() {\n\t      return customStyles;\n\t    }\n\t  },\n\t  _documentDirty: {\n\t    get: function get() {\n\t      return enqueued;\n\t    },\n\t    set: function set(value) {\n\t      enqueued = value;\n\t      return value;\n\t    }\n\t  }\n\t});\n\t\n\tCustomStyle.findStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._findStyle();\n\t  }\n\t};\n\t\n\tCustomStyle._revalidateApplyShim = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    var s = customStyles[i];\n\t    if (s._style) {\n\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t    }\n\t  }\n\t};\n\t\n\tCustomStyle.applyStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._applyStyle();\n\t  }\n\t};\n\t\n\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t  'constructor': {\n\t    value: CustomStyle,\n\t    configurable: true,\n\t    writable: true\n\t  }\n\t});\n\t\n\tCustomStyle.prototype._findStyle = function () {\n\t  if (!this._style) {\n\t    var style = this.querySelector('style');\n\t    if (!style) {\n\t      return;\n\t    }\n\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t    // which is referenced with __appliedElement.\n\t    // Also, we must copy over the attributes.\n\t    if (style.__appliedElement) {\n\t      for (var i = 0; i < style.attributes.length; i++) {\n\t        var attr = style.attributes[i];\n\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t      }\n\t    }\n\t    this._style = style.__appliedElement || style;\n\t    if (hookFn) {\n\t      hookFn(this._style);\n\t    }\n\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t  }\n\t};\n\t\n\tCustomStyle.prototype._applyStyle = function () {\n\t  if (this._style) {\n\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t  }\n\t};\n\t\n\twindow.customElements.define('custom-style', CustomStyle);\n\twindow['CustomStyle'] = CustomStyle;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/*\n\tSmall module to load ShadyCSS and CustomStyle together\n\t*/\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadycss.min.js.map\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-web-components/dist/index.js\n// module id = 1\n// module chunks = 0","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('incremental-dom'), require('window-or-global')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n}(this, (function (exports,incrementalDom,root) {\n\nroot = 'default' in root ? root['default'] : root;\n\nfunction keys() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref$enumOnly = _ref.enumOnly;\n  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\n  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n}\n\n// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\nvar assign = (function (obj) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(function (arg) {\n    return keys(arg).forEach(function (name) {\n      return obj[name] = arg[name];\n    });\n  }); // eslint-disable-line no-return-assign\n  return obj;\n});\n\nvar empty = function (val) {\n  return typeof val === 'undefined' || val === null;\n};\n\n/**\n * Attributes value can only be null or string;\n */\nvar toNullOrString = function toNullOrString(val) {\n  return empty(val) ? null : String(val);\n};\n\nfunction create(def) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.unshift({}, def);\n    return assign.apply(undefined, args);\n  };\n}\n\nvar array = create({\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : empty(val) ? null : [val];\n  },\n  default: function _default() {\n    return [];\n  },\n  deserialize: function deserialize(val) {\n    return empty(val) ? null : JSON.parse(val);\n  },\n  serialize: JSON.stringify\n});\n\nvar boolean = create({\n  coerce: function coerce(val) {\n    return !!val;\n  },\n  default: false,\n  // todo: 'false' string must deserialize to false for angular 1.x to work\n  // This breaks one existing test.\n  // deserialize: val => !(val === null || val === 'false'),\n  deserialize: function deserialize(val) {\n    return !(val === null);\n  },\n  serialize: function serialize(val) {\n    return val ? '' : null;\n  }\n});\n\n// defaults empty to 0 and allows NaN\nvar zeroIfEmptyOrNumberIncludesNaN = function zeroIfEmptyOrNumberIncludesNaN(val) {\n  return empty(val) ? 0 : Number(val);\n};\n\nvar number = create({\n  default: 0,\n  coerce: zeroIfEmptyOrNumberIncludesNaN,\n  deserialize: zeroIfEmptyOrNumberIncludesNaN,\n  serialize: toNullOrString\n});\n\nvar string = create({\n  default: '',\n  coerce: toNullOrString,\n  deserialize: toNullOrString,\n  serialize: toNullOrString\n});\n\nvar prop = Object.freeze({\n\tcreate: create,\n\tarray: array,\n\tboolean: boolean,\n\tnumber: number,\n\tstring: string\n});\n\nvar connected = '____skate_connected';\nvar created = '____skate_created';\n\n// DEPRECATED\n//\n// This is the only \"symbol\" that must stay a string. This is because it is\n// relied upon across several versions. We should remove it, but ensure that\n// it's considered a breaking change that whatever version removes it cannot\n// be passed to vdom functions as tag names.\nvar name = '____skate_name';\n\n// Used on the Constructor\nvar ctorCreateInitProps = '____skate_ctor_createInitProps';\nvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\nvar ctorProps = '____skate_ctor_props';\nvar ctorPropsMap = '____skate_ctor_propsMap';\n\n// Used on the Element\nvar props = '____skate_props';\nvar ref$1 = '____skate_ref';\nvar renderer$1 = '____skate_renderer';\nvar rendering = '____skate_rendering';\nvar rendererDebounced = '____skate_rendererDebounced';\nvar updated$1 = '____skate_updated';\n\n// DEPRECTAED\n//\n// We should not be relying on internals for symbols as this creates version\n// coupling. We will move forward with platform agnostic ways of doing this.\n\n\nvar symbols$1 = Object.freeze({\n\tname: name\n});\n\nfunction enter(object, props) {\n  var saved = {};\n  Object.keys(props).forEach(function (key) {\n    saved[key] = object[key];\n    object[key] = props[key];\n  });\n  return saved;\n}\n\nfunction exit(object, saved) {\n  assign(object, saved);\n}\n\n// Decorates a function with a side effect that changes the properties of an\n// object during its execution, and restores them after. There is no error\n// handling here, if the wrapped function throws an error, properties are not\n// restored and all bets are off.\nvar propContext = function (object, props) {\n  return function (func) {\n    return function () {\n      var saved = enter(object, props);\n      var result = func.apply(undefined, arguments);\n      exit(object, saved);\n      return result;\n    };\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/* eslint no-plusplus: 0 */\n\nvar customElements = root.customElements;\nvar HTMLElement = root.HTMLElement;\n\nvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\n// A stack of children that corresponds to the current function helper being\n// executed.\nvar stackChren = [];\n\nvar $skip = '__skip';\nvar $currentEventHandlers = '__events';\nvar $stackCurrentHelperProps = '__props';\n\n// The current function helper in the stack.\nvar stackCurrentHelper = void 0;\n\n// This is used for the Incremental DOM overrides to keep track of what args\n// to pass the main elementOpen() function.\nvar overrideArgs = void 0;\n\n// The number of levels deep after skipping a tree.\nvar skips = 0;\n\nvar noop = function noop() {};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent(elem, ename, newFunc) {\n  var events = elem[$currentEventHandlers];\n\n  if (!events) {\n    events = elem[$currentEventHandlers] = {};\n  }\n\n  // Undefined indicates that there is no listener yet.\n  if (typeof events[ename] === 'undefined') {\n    // We only add a single listener once. Originally this was a workaround for\n    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n    // also a simpler model for binding / unbinding events because you only\n    // have a single handler you need to worry about and a single place where\n    // you only store one event handler\n    elem.addEventListener(ename, function (e) {\n      if (events[ename]) {\n        events[ename].call(this, e);\n      }\n    });\n  }\n\n  // Not undefined indicates that we have set a listener, so default to null.\n  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n}\n\nvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n  // Attributes that shouldn't be applied to the DOM.\n  key: noop,\n  statics: noop,\n\n  // Attributes that *must* be set via a property on all elements.\n  checked: incrementalDom.applyProp,\n  className: incrementalDom.applyProp,\n  disabled: incrementalDom.applyProp,\n  value: incrementalDom.applyProp,\n\n  // Ref handler.\n  ref: function ref(elem, name$$1, value) {\n    elem[ref$1] = value;\n  },\n\n\n  // Skip handler.\n  skip: function skip(elem, name$$1, value) {\n    if (value) {\n      elem[$skip] = true;\n    } else {\n      delete elem[$skip];\n    }\n  }\n}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n  var _ref = customElements.get(elem.localName) || {\n    props: {},\n    prototype: {}\n  };\n\n  var props$$1 = _ref.props;\n  var prototype = _ref.prototype;\n\n  // TODO when refactoring properties to not have to workaround the old\n  // WebKit bug we can remove the \"name in props\" check below.\n  //\n  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n  // elements that set a property that isn't explicitly specified in \"props\"\n  // or \"prototype\" unless it is added to the element explicitly as a\n  // property prior to passing the prop to the vdom function. For example, if\n  // it were added in a lifecycle callback because it wouldn't have been\n  // upgraded yet.\n  //\n  // We prefer setting props, so we do this if there's a property matching\n  // name that was passed. However, certain props on SVG elements are\n  // readonly and error when you try to set them.\n\n  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n    incrementalDom.applyProp(elem, name$$1, value);\n    return;\n  }\n\n  // Explicit false removes the attribute.\n  if (value === false) {\n    applyDefault(elem, name$$1);\n    return;\n  }\n\n  // Handle built-in and custom events.\n  if (name$$1.indexOf('on') === 0) {\n    var firstChar = name$$1[2];\n    var eventName = void 0;\n\n    if (firstChar === '-') {\n      eventName = name$$1.substring(3);\n    } else if (firstChar === firstChar.toUpperCase()) {\n      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n    }\n\n    if (eventName) {\n      applyEvent(elem, eventName, value);\n      return;\n    }\n  }\n\n  applyDefault(elem, name$$1, value);\n}));\n\nfunction resolveTagName(name$$1) {\n  // We return falsy values as some wrapped IDOM functions allow empty values.\n  if (!name$$1) {\n    return name$$1;\n  }\n\n  // We try and return the cached tag name, if one exists.\n  if (name$$1[name]) {\n    return name$$1[name];\n  }\n\n  // If it's a custom element, we get the tag name by constructing it and\n  // caching it.\n  if (name$$1.prototype instanceof HTMLElement) {\n    // eslint-disable-next-line\n    var elem = new name$$1();\n    return name$$1[name] = elem.localName;\n  }\n\n  // Pass all other values through so IDOM gets what it's expecting.\n  return name$$1;\n}\n\n// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n// so it's the only function we need to execute in the context of our attributes.\nvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\nfunction elementOpenStart(tag) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  overrideArgs = [tag, key, statics];\n}\n\nfunction elementOpenEnd() {\n  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n  overrideArgs = null;\n  return node;\n}\n\nfunction wrapIdomFunc(func) {\n  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n  return function wrap() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args[0] = resolveTagName(args[0]);\n    stackCurrentHelper = null;\n    if (typeof args[0] === 'function') {\n      // If we've encountered a function, handle it according to the type of\n      // function that is being wrapped.\n      stackCurrentHelper = args[0];\n      return tnameFuncHandler.apply(undefined, args);\n    } else if (stackChren.length) {\n      // We pass the wrap() function in here so that when it's called as\n      // children, it will queue up for the next stack, if there is one.\n      stackChren[stackChren.length - 1].push([wrap, args]);\n    } else {\n      if (func === elementOpen$1) {\n        if (skips) {\n          return ++skips;\n        }\n\n        var elem = func.apply(undefined, args);\n\n        if (elem[$skip]) {\n          ++skips;\n        }\n\n        return elem;\n      }\n\n      if (func === incrementalDom.elementClose) {\n        if (skips === 1) {\n          incrementalDom.skip();\n        }\n\n        // We only want to skip closing if it's not the last closing tag in the\n        // skipped tree because we keep the element that initiated the skpping.\n        if (skips && --skips) {\n          return;\n        }\n\n        var _elem = func.apply(undefined, args);\n        var ref$$1 = _elem[ref$1];\n\n        // We delete so that it isn't called again for the same element. If the\n        // ref changes, or the element changes, this will be defined again.\n        delete _elem[ref$1];\n\n        // Execute the saved ref after esuring we've cleand up after it.\n        if (typeof ref$$1 === 'function') {\n          ref$$1(_elem);\n        }\n\n        return _elem;\n      }\n\n      // We must call elementOpenStart and elementOpenEnd even if we are\n      // skipping because they queue up attributes and then call elementClose.\n      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n        return func.apply(undefined, args);\n      }\n    }\n  };\n}\n\nfunction newAttr() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (stackCurrentHelper) {\n    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n  } else if (stackChren.length) {\n    stackChren[stackChren.length - 1].push([newAttr, args]);\n  } else {\n    overrideArgs.push(args[0]);\n    overrideArgs.push(args[1]);\n  }\n}\n\nfunction stackOpen(tname, key, statics) {\n  var props$$1 = { key: key, statics: statics };\n\n  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n    attrs[_key3 - 3] = arguments[_key3];\n  }\n\n  for (var a = 0; a < attrs.length; a += 2) {\n    props$$1[attrs[a]] = attrs[a + 1];\n  }\n  tname[$stackCurrentHelperProps] = props$$1;\n  stackChren.push([]);\n}\n\nfunction stackClose(tname) {\n  var chren = stackChren.pop();\n  var props$$1 = tname[$stackCurrentHelperProps];\n  delete tname[$stackCurrentHelperProps];\n  var elemOrFn = tname(props$$1, function () {\n    return chren.forEach(function (args) {\n      return args[0].apply(args, toConsumableArray(args[1]));\n    });\n  });\n  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n}\n\n// Incremental DOM overrides\n// -------------------------\n\n// We must override internal functions that call internal Incremental DOM\n// functions because we can't override the internal references. This means\n// we must roughly re-implement their behaviour. Luckily, they're fairly\n// simple.\nvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\nvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\n// Standard open / closed overrides don't need to reproduce internal behaviour\n// because they are the ones referenced from *End and *Start.\nvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\nvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\n// Ensure we call our overridden functions instead of the internal ones.\nfunction newElementVoid(tag) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  newElementOpen.apply(undefined, [tag].concat(args));\n  return newElementClose(tag);\n}\n\n// Text override ensures their calls can queue if using function helpers.\nvar newText = wrapIdomFunc(incrementalDom.text);\n\n// Convenience function for declaring an Incremental DOM element using\n// hyperscript-style syntax.\nfunction element(tname, attrs) {\n  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\n  // If attributes are a function, then they should be treated as children.\n\n  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    chren[_key5 - 2] = arguments[_key5];\n  }\n\n  if (atype === 'function' || atype === 'string' || atype === 'number') {\n    chren.unshift(attrs);\n  }\n\n  // Ensure the attributes are an object. Null is considered an object so we\n  // have to test for this explicitly.\n  if (attrs === null || atype !== 'object') {\n    attrs = {};\n  }\n\n  // We open the element so we can set attrs after.\n  newElementOpenStart(tname, attrs.key, attrs.statics);\n\n  // Delete so special attrs don't actually get set.\n  delete attrs.key;\n  delete attrs.statics;\n\n  // Set attributes.\n  Object.keys(attrs).forEach(function (name$$1) {\n    return newAttr(name$$1, attrs[name$$1]);\n  });\n\n  // Close before we render the descendant tree.\n  newElementOpenEnd(tname);\n\n  chren.forEach(function (ch) {\n    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n    if (ctype === 'function') {\n      ch();\n    } else if (ctype === 'string' || ctype === 'number') {\n      newText(ch);\n    } else if (Array.isArray(ch)) {\n      ch.forEach(function (sch) {\n        return sch();\n      });\n    }\n  });\n\n  return newElementClose(tname);\n}\n\n// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n// transpiles for JSX (React.createElement() / h).\nfunction builder() {\n  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    tags[_key6] = arguments[_key6];\n  }\n\n  if (tags.length === 0) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return element.bind.apply(element, [null].concat(args));\n    };\n  }\n  return tags.map(function (tag) {\n    return function () {\n      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return element.bind.apply(element, [null, tag].concat(args));\n    };\n  });\n}\n\n\n\nvar vdom = Object.freeze({\n\telement: element,\n\tbuilder: builder,\n\tattr: newAttr,\n\telementClose: newElementClose,\n\telementOpen: newElementOpen,\n\telementOpenEnd: newElementOpenEnd,\n\telementOpenStart: newElementOpenStart,\n\telementVoid: newElementVoid,\n\ttext: newText\n});\n\nfunction createSymbol(description) {\n  return typeof Symbol === 'function' ? Symbol(description) : description;\n}\n\nvar data = function (element) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n};\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\nvar native = (function (fn) {\n  return nativeHints.map(function (hint) {\n    return (fn || '').toString().indexOf([hint]) > -1;\n  }).reduce(function (a, b) {\n    return a || b;\n  });\n});\n\nvar MutationObserver = root.MutationObserver;\n\n\nfunction microtaskDebounce(cbFunc) {\n  var scheduled = false;\n  var i = 0;\n  var cbArgs = [];\n  var elem = document.createElement('span');\n  var observer = new MutationObserver(function () {\n    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n    scheduled = false;\n    cbArgs = null;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = '' + i;\n      i += 1;\n    }\n  };\n}\n\n// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n// polyfill requires that the element be in the document to trigger Mutation\n// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n//\n// The soonest we can set the timeout for in IE is 1 as they have issues when\n// setting to 0.\nfunction taskDebounce(cbFunc) {\n  var scheduled = false;\n  var cbArgs = [];\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n      }, 1);\n    }\n  };\n}\nvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\nvar isFunction = function isFunction(val) {\n  return typeof val === 'function';\n};\nvar isUndefined = function isUndefined(val) {\n  return typeof val === 'undefined';\n};\n\n/**\n * @internal\n * Attributes Manager\n *\n * Postpones attributes updates until when connected.\n */\n\nvar AttributesManager = function () {\n  function AttributesManager(elem) {\n    classCallCheck(this, AttributesManager);\n\n    this.elem = elem;\n    this.connected = false;\n    this.pendingValues = {};\n    this.lastSetValues = {};\n  }\n\n  /**\n   * Called from disconnectedCallback\n   */\n\n\n  createClass(AttributesManager, [{\n    key: 'suspendAttributesUpdates',\n    value: function suspendAttributesUpdates() {\n      this.connected = false;\n    }\n\n    /**\n     * Called from connectedCallback\n     */\n\n  }, {\n    key: 'resumeAttributesUpdates',\n    value: function resumeAttributesUpdates() {\n      var _this = this;\n\n      this.connected = true;\n      var names = Object.keys(this.pendingValues);\n      names.forEach(function (name) {\n        var value = _this.pendingValues[name];\n        // Skip if already cleared\n        if (!isUndefined(value)) {\n          delete _this.pendingValues[name];\n          _this._syncAttrValue(name, value);\n        }\n      });\n    }\n\n    /**\n     * Returns true if the value is different from the one set internally\n     * using setAttrValue()\n     */\n\n  }, {\n    key: 'onAttributeChanged',\n    value: function onAttributeChanged(name, value) {\n      value = toNullOrString(value);\n\n      // A new attribute value voids the pending one\n      this._clearPendingValue(name);\n\n      var changed = this.lastSetValues[name] !== value;\n      this.lastSetValues[name] = value;\n      return changed;\n    }\n\n    /**\n     * Updates or removes the attribute if value === null.\n     *\n     * When the component is not connected the value is saved and\n     * the attribute is only updated when the component is re-connected.\n     */\n\n  }, {\n    key: 'setAttrValue',\n    value: function setAttrValue(name, value) {\n      value = toNullOrString(value);\n\n      this.lastSetValues[name] = value;\n\n      if (this.connected) {\n        this._clearPendingValue(name);\n        this._syncAttrValue(name, value);\n      } else {\n        this.pendingValues[name] = value;\n      }\n    }\n  }, {\n    key: '_syncAttrValue',\n    value: function _syncAttrValue(name, value) {\n      var currAttrValue = toNullOrString(this.elem.getAttribute(name));\n      if (value !== currAttrValue) {\n        if (value === null) {\n          this.elem.removeAttribute(name);\n        } else {\n          this.elem.setAttribute(name, value);\n        }\n      }\n    }\n  }, {\n    key: '_clearPendingValue',\n    value: function _clearPendingValue(name) {\n      if (name in this.pendingValues) {\n        delete this.pendingValues[name];\n      }\n    }\n  }]);\n  return AttributesManager;\n}();\n\n// Only used by getAttrMgr\n\n\nvar $attributesMgr = '____skate_attributesMgr';\n\n/**\n * @internal\n * Returns attribute manager instance for the given Component\n */\nfunction getAttrMgr(elem) {\n  var mgr = elem[$attributesMgr];\n  if (!mgr) {\n    mgr = new AttributesManager(elem);\n    elem[$attributesMgr] = mgr;\n  }\n  return mgr;\n}\n\nvar getOwnPropertyDescriptors = function () {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return keys(obj).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n};\n\nvar dashCase = function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return '' + one + dash + two.toLowerCase();\n  });\n};\n\nfunction error$1(message) {\n  var DEBUG = root.DEBUG;\n\n  if (!isUndefined(DEBUG) && DEBUG) {\n    console.error(message);\n  } else {\n    throw new Error(message);\n  }\n}\n\n/**\n * @internal\n * Property Definition\n *\n * Internal meta data and strategies for a property.\n * Created from the options of a PropOptions config object.\n *\n * Once created a PropDefinition should be treated as immutable and final.\n * 'getPropsMap' function memoizes PropDefinitions by Component's Class.\n *\n * The 'attribute' option is normalized into the 'attrName' property.\n */\n\nvar PropDefinition = function () {\n  function PropDefinition(nameOrSymbol, propOptions) {\n    var _this = this;\n\n    classCallCheck(this, PropDefinition);\n\n    this._name = nameOrSymbol;\n\n    propOptions = propOptions || {};\n\n    // default 'attrName': no linked attribute\n    this.attrName = null;\n\n    // default 'coerce': identity function\n    this.coerce = function (value) {\n      return value;\n    };\n\n    // default 'default': set prop to 'null'\n    this.default = null;\n\n    // default 'deserialize': return attribute's value (string or null)\n    this.deserialize = function (value) {\n      return value;\n    };\n\n    // default 'get': no function\n    this.get = null;\n\n    // 'initial' default: unspecified\n    // 'initial' option is truly optional and it cannot be initialized.\n    // Its presence is tested using: ('initial' in propDef)\n\n    // 'serialize' default: return string value or null\n    this.serialize = function (value) {\n      return empty(value) ? null : String(value);\n    };\n\n    // default 'set': no function\n    this.set = null;\n\n    // Note: option key is always a string (no symbols here)\n    Object.keys(propOptions).forEach(function (option) {\n      var optVal = propOptions[option];\n\n      // Only accept documented options and perform minimal input validation.\n      switch (option) {\n        case 'attribute':\n          _this.attrName = resolveAttrName(optVal, nameOrSymbol);\n          break;\n        case 'coerce':\n        case 'deserialize':\n        case 'get':\n        case 'serialize':\n        case 'set':\n          if (isFunction(optVal)) {\n            _this[option] = optVal;\n          } else {\n            error$1(option + ' must be a function.');\n          }\n          break;\n        case 'default':\n        case 'initial':\n          _this[option] = optVal;\n          break;\n        default:\n          error$1(option + ' is not a valid option. Options are: attribute, initial, default, coerce, deserialize, serialize.');\n          break;\n      }\n    });\n  }\n\n  createClass(PropDefinition, [{\n    key: 'name',\n    get: function get() {\n      return this._name;\n    }\n  }]);\n  return PropDefinition;\n}();\n\nfunction resolveAttrName(attrOption, nameOrSymbol) {\n  if ((typeof nameOrSymbol === 'undefined' ? 'undefined' : _typeof(nameOrSymbol)) === 'symbol') {\n    error$1(nameOrSymbol.toString() + ' symbol property cannot have an attribute.');\n  } else {\n    if (attrOption === true) {\n      return dashCase(String(nameOrSymbol));\n    }\n    if (typeof attrOption === 'string') {\n      return attrOption;\n    }\n  }\n  return null;\n}\n\n/**\n * This is needed to avoid IE11 \"stack size errors\" when creating\n * a new property on the constructor of an HTMLElement\n */\nfunction setCtorNativeProperty(Ctor, propName, value) {\n  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n}\n\n/**\n * Memoizes a map of PropDefinition for the given component class.\n * Keys in the map are the properties name which can a string or a symbol.\n *\n * The map is created from the result of: static get props\n */\nfunction getPropsMap(Ctor) {\n  // Must be defined on constructor and not from a superclass\n  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n    (function () {\n      var props$$1 = Ctor.props || {};\n\n      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n        result[propNameOrSymbol] = new PropDefinition(propNameOrSymbol, props$$1[propNameOrSymbol]);\n        return result;\n      }, {});\n      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n    })();\n  }\n\n  return Ctor[ctorPropsMap];\n}\n\nfunction get$2(elem) {\n  var props$$1 = {};\n\n  keys(getPropsMap(elem.constructor)).forEach(function (propNameOrSymbol) {\n    props$$1[propNameOrSymbol] = elem[propNameOrSymbol];\n  });\n\n  return props$$1;\n}\n\nfunction set$2(elem, newProps) {\n  assign(elem, newProps);\n  if (elem[renderer$1]) {\n    elem[renderer$1]();\n  }\n}\n\nvar props$1 = function (elem, newProps) {\n  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n};\n\nfunction getDefaultValue(elem, propDef) {\n  return typeof propDef.default === 'function' ? propDef.default(elem, { name: propDef.name }) : propDef.default;\n}\n\nfunction getInitialValue(elem, propDef) {\n  return typeof propDef.initial === 'function' ? propDef.initial(elem, { name: propDef.name }) : propDef.initial;\n}\n\nfunction getPropData(elem, name) {\n  var elemData = data(elem, 'props');\n  return elemData[name] || (elemData[name] = {});\n}\n\nfunction createNativePropertyDescriptor(propDef) {\n  var nameOrSymbol = propDef.name;\n\n  var prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.beforeDefineProperty = function (elem) {\n    var propData = getPropData(elem, nameOrSymbol);\n    var attrName = propDef.attrName;\n\n    // Store attribute to property link.\n    if (attrName) {\n      data(elem, 'attributeLinks')[attrName] = nameOrSymbol;\n    }\n\n    // prop value before upgrading\n    var initialValue = elem[nameOrSymbol];\n\n    // Set up initial value if it wasn't specified.\n    var valueFromAttribute = false;\n    if (empty(initialValue)) {\n      if (attrName && elem.hasAttribute(attrName)) {\n        valueFromAttribute = true;\n        initialValue = propDef.deserialize(elem.getAttribute(attrName));\n      } else if ('initial' in propDef) {\n        initialValue = getInitialValue(elem, propDef);\n      } else {\n        initialValue = getDefaultValue(elem, propDef);\n      }\n    }\n\n    initialValue = propDef.coerce(initialValue);\n\n    propData.internalValue = initialValue;\n\n    // Reflect to attribute unless valueFromAttribute\n    if (!valueFromAttribute && attrName && !empty(initialValue)) {\n      var serializedValue = propDef.serialize(initialValue);\n      getAttrMgr(elem).setAttrValue(propDef.attrName, serializedValue);\n    }\n  };\n\n  prop.get = function get() {\n    var propData = getPropData(this, nameOrSymbol);\n    var internalValue = propData.internalValue;\n\n    return propDef.get ? propDef.get(this, { name: nameOrSymbol, internalValue: internalValue }) : internalValue;\n  };\n\n  prop.set = function set(newValue) {\n    var propData = getPropData(this, nameOrSymbol);\n\n    var useDefaultValue = empty(newValue);\n    if (useDefaultValue) {\n      newValue = getDefaultValue(this, propDef);\n    }\n\n    newValue = propDef.coerce(newValue);\n\n    if (propDef.set) {\n      var oldValue = propData.oldValue;\n\n\n      if (empty(oldValue)) {\n        oldValue = null;\n      }\n      var changeData = { name: nameOrSymbol, newValue: newValue, oldValue: oldValue };\n      propDef.set(this, changeData);\n    }\n\n    // Queue a re-render.\n    this[rendererDebounced](this);\n\n    // Update prop data so we can use it next time.\n    propData.internalValue = propData.oldValue = newValue;\n\n    // Link up the attribute.\n    if (propDef.attrName && !propData.settingProp) {\n      // Note: setting the prop to empty implies the default value\n      // and therefore no attribute should be present!\n      var serializedValue = useDefaultValue ? null : propDef.serialize(newValue);\n      getAttrMgr(this).setAttrValue(propDef.attrName, serializedValue);\n    }\n  };\n\n  return prop;\n}\n\nvar objectIs = (function (x, y) {\n  if (Object.is) {\n    return Object.is(x, y);\n  }\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n});\n\nvar HTMLElement$1 = root.HTMLElement || function () {\n  function _class() {\n    classCallCheck(this, _class);\n  }\n\n  return _class;\n}();\nvar _prevName = createSymbol('prevName');\nvar _prevOldValue = createSymbol('prevOldValue');\nvar _prevNewValue = createSymbol('prevNewValue');\n\nfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n}\n\n// TODO remove when not catering to Safari < 10.\nfunction createNativePropertyDescriptors(Ctor) {\n  var propDefs = getPropsMap(Ctor);\n  return keys(propDefs).reduce(function (propDescriptors, propName) {\n    propDescriptors[propName] = createNativePropertyDescriptor(propDefs[propName]);\n    return propDescriptors;\n  }, {});\n}\n\n// TODO refactor when not catering to Safari < 10.\n//\n// We should be able to simplify this where all we do is Object.defineProperty().\nfunction createInitProps(Ctor) {\n  var propDescriptors = createNativePropertyDescriptors(Ctor);\n\n  return function (elem) {\n    keys(propDescriptors).forEach(function (name$$1) {\n      var propDescriptor = propDescriptors[name$$1];\n      propDescriptor.beforeDefineProperty(elem);\n\n      // We check here before defining to see if the prop was specified prior\n      // to upgrading.\n      var hasPropBeforeUpgrading = name$$1 in elem;\n\n      // This is saved prior to defining so that we can set it after it it was\n      // defined prior to upgrading. We don't want to invoke the getter if we\n      // don't need to, so we only get the value if we need to re-sync.\n      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name$$1, propDescriptor);\n\n      // DEPRECATED\n      //\n      // We'll be removing get / set callbacks on properties. Use the\n      // updatedCallback() instead.\n      //\n      // We re-set the prop if it was specified prior to upgrading because we\n      // need to ensure set() is triggered both in polyfilled environments and\n      // in native where the definition may be registerd after elements it\n      // represents have already been created.\n      if (hasPropBeforeUpgrading) {\n        elem[name$$1] = valueBeforeUpgrading;\n      }\n    });\n  };\n}\n\nvar _class2 = function (_HTMLElement) {\n  inherits(_class2, _HTMLElement);\n  createClass(_class2, null, [{\n    key: 'observedAttributes',\n\n    /**\n     * Returns unique attribute names configured with props and\n     * those set on the Component constructor if any\n     */\n    get: function get() {\n      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n      var propDefs = getPropsMap(this);\n\n      // Use Object.keys to skips symbol props since they have no linked attributes\n      var attrsFromLinkedProps = Object.keys(propDefs).map(function (propName) {\n        return propDefs[propName].attrName;\n      }).filter(Boolean);\n\n      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n      return all.filter(function (item, index) {\n        return all.indexOf(item) === index;\n      });\n    },\n    set: function set(value) {\n      value = Array.isArray(value) ? value : [];\n      setCtorNativeProperty(this, 'observedAttributes', value);\n    }\n\n    // Returns superclass props overwritten with this Component props\n\n  }, {\n    key: 'props',\n    get: function get() {\n      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n    },\n    set: function set(value) {\n      setCtorNativeProperty(this, ctorProps, value);\n    }\n\n    // Passing args is designed to work with document-register-element. It's not\n    // necessary for the webcomponents/custom-element polyfill.\n\n  }]);\n\n  function _class2() {\n    var _ref;\n\n    classCallCheck(this, _class2);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\n\n    var constructor = _this.constructor;\n\n    // Used for the ready() function so it knows when it can call its callback.\n\n    _this[created] = true;\n\n    // TODO refactor to not cater to Safari < 10. This means we can depend on\n    // built-in property descriptors.\n    // Must be defined on constructor and not from a superclass\n    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n    }\n\n    // Set up a renderer that is debounced for property sets to call directly.\n    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\n    // Set up property lifecycle.\n    var propDefsCount = keys(getPropsMap(constructor)).length;\n    if (propDefsCount && constructor[ctorCreateInitProps]) {\n      constructor[ctorCreateInitProps](_this);\n    }\n\n    // DEPRECATED\n    //\n    // static render()\n    // Note that renderCallback is an optional method!\n    if (!_this.renderCallback && constructor.render) {\n      _this.renderCallback = constructor.render.bind(constructor, _this);\n    }\n\n    // DEPRECATED\n    //\n    // static created()\n    //\n    // Props should be set up before calling this.\n    var created$$1 = constructor.created;\n\n    if (isFunction(created$$1)) {\n      created$$1(_this);\n    }\n\n    // DEPRECATED\n    //\n    // Feature has rarely been used.\n    //\n    // Created should be set before invoking the ready listeners.\n    var elemData = data(_this);\n    var readyCallbacks = elemData.readyCallbacks;\n    if (readyCallbacks) {\n      readyCallbacks.forEach(function (cb) {\n        return cb(_this);\n      });\n      delete elemData.readyCallbacks;\n    }\n    return _this;\n  }\n\n  // Custom Elements v1\n\n\n  createClass(_class2, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      // Reflect attributes pending values\n      getAttrMgr(this).resumeAttributesUpdates();\n\n      // Used to check whether or not the component can render.\n      this[connected] = true;\n\n      // Render!\n      this[rendererDebounced]();\n\n      // DEPRECATED\n      //\n      // static attached()\n      var attached = this.constructor.attached;\n\n      if (isFunction(attached)) {\n        attached(this);\n      }\n\n      // DEPRECATED\n      //\n      // We can remove this once all browsers support :defined.\n      this.setAttribute('defined', '');\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      // Suspend updating attributes until re-connected\n      getAttrMgr(this).suspendAttributesUpdates();\n\n      // Ensures the component can't be rendered while disconnected.\n      this[connected] = false;\n\n      // DEPRECATED\n      //\n      // static detached()\n      var detached = this.constructor.detached;\n\n      if (isFunction(detached)) {\n        detached(this);\n      }\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n      // Polyfill calls this twice.\n      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n        return;\n      }\n\n      // Set data so we can prevent double calling if the polyfill.\n      this[_prevName] = name$$1;\n      this[_prevOldValue] = oldValue;\n      this[_prevNewValue] = newValue;\n\n      var propNameOrSymbol = data(this, 'attributeLinks')[name$$1];\n      if (propNameOrSymbol) {\n        var changedExternally = getAttrMgr(this).onAttributeChanged(name$$1, newValue);\n        if (changedExternally) {\n          // Sync up the property.\n          var propDef = getPropsMap(this.constructor)[propNameOrSymbol];\n          var newPropVal = newValue !== null && propDef.deserialize ? propDef.deserialize(newValue) : newValue;\n\n          var propData = data(this, 'props')[propNameOrSymbol];\n          propData.settingProp = true;\n          this[propNameOrSymbol] = newPropVal;\n          propData.settingProp = false;\n        }\n      }\n\n      // DEPRECATED\n      //\n      // static attributeChanged()\n      var attributeChanged = this.constructor.attributeChanged;\n\n      if (isFunction(attributeChanged)) {\n        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n      }\n    }\n\n    // Skate\n\n  }, {\n    key: 'updatedCallback',\n    value: function updatedCallback(prevProps) {\n      return this.constructor.updated(this, prevProps);\n    }\n\n    // Skate\n\n  }, {\n    key: 'renderedCallback',\n    value: function renderedCallback() {\n      return this.constructor.rendered(this);\n    }\n\n    // Skate\n    //\n    // Maps to the static renderer() callback. That logic should be moved here\n    // when that is finally removed.\n    // todo: finalize how to support different rendering strategies.\n\n  }, {\n    key: 'rendererCallback',\n    value: function rendererCallback() {\n      // todo: cannot move code here because tests expects renderer function to still exist on constructor!\n      return this.constructor.renderer(this);\n    }\n\n    // Skate\n    // @internal\n    // Invokes the complete render lifecycle.\n\n  }, {\n    key: renderer$1,\n    value: function value() {\n      if (this[rendering] || !this[connected]) {\n        return;\n      }\n\n      // Flag as rendering. This prevents anything from trying to render - or\n      // queueing a render - while there is a pending render.\n      this[rendering] = true;\n      if (this[updated$1]() && isFunction(this.renderCallback)) {\n        this.rendererCallback();\n        this.renderedCallback();\n      }\n\n      this[rendering] = false;\n    }\n\n    // Skate\n    // @internal\n    // Calls the updatedCallback() with previous props.\n\n  }, {\n    key: updated$1,\n    value: function value() {\n      var prevProps = this[props];\n      this[props] = props$1(this);\n      return this.updatedCallback(prevProps);\n    }\n\n    // Skate\n\n  }], [{\n    key: 'extend',\n    value: function extend() {\n      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n      // Create class for the user.\n      var Ctor = function (_Base) {\n        inherits(Ctor, _Base);\n\n        function Ctor() {\n          classCallCheck(this, Ctor);\n          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n        }\n\n        return Ctor;\n      }(Base);\n\n      // For inheriting from the object literal.\n\n\n      var opts = getOwnPropertyDescriptors(definition);\n      var prot = getOwnPropertyDescriptors(definition.prototype);\n\n      // Prototype is non configurable (but is writable).\n      delete opts.prototype;\n\n      // Pass on static and instance members from the definition.\n      Object.defineProperties(Ctor, opts);\n      Object.defineProperties(Ctor.prototype, prot);\n\n      return Ctor;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Stubbed in case any subclasses are calling it.\n\n  }, {\n    key: 'rendered',\n    value: function rendered() {}\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'renderer',\n    value: function renderer(elem) {\n      if (!elem.shadowRoot) {\n        elem.attachShadow({ mode: 'open' });\n      }\n      incrementalDom.patchInner(elem.shadowRoot, function () {\n        var possibleFn = elem.renderCallback();\n        if (isFunction(possibleFn)) {\n          possibleFn();\n        } else if (Array.isArray(possibleFn)) {\n          possibleFn.forEach(function (fn) {\n            if (isFunction(fn)) {\n              fn();\n            }\n          });\n        }\n      });\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to updatedCallback() before removing.\n\n  }, {\n    key: 'updated',\n    value: function updated(elem, prevProps) {\n      // short-circuits if this is the first time\n      if (!prevProps) {\n        return true;\n      }\n\n      // Use getAllKeys to include all props names and Symbols\n      var allKeys = keys(prevProps);\n\n      // Use classic loop because 'for ... of' skips symbols\n      for (var i = 0; i < allKeys.length; i++) {\n        var nameOrSymbol = allKeys[i];\n\n        // Object.is (NaN is equal NaN)\n        if (!objectIs(prevProps[nameOrSymbol], elem[nameOrSymbol])) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }]);\n  return _class2;\n}(HTMLElement$1);\n\nfunction uniqueId(prefix) {\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    // eslint-disable-next-line no-mixed-operators\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return (prefix || 'x') + '-' + rand;\n}\n\nvar define = function () {\n  var customElements = root.customElements;\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var name$$1 = args[0];\n  var Ctor = args[1];\n\n\n  if (!customElements) {\n    throw new Error('Skate requires native custom element support or a polyfill.');\n  }\n\n  // Support passing an anonymous definition.\n  if (args.length === 1) {\n    // We are checking string for now, but once we remove the ability to pass\n    // an object literal, we can change this to check \"function\" and invert the\n    // blocks of logic.\n    if (typeof name$$1 === 'string') {\n      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n    } else {\n      Ctor = name$$1;\n      name$$1 = uniqueId();\n    }\n  }\n\n  // Ensure there's no conflicts.\n  if (customElements.get(name$$1)) {\n    name$$1 = uniqueId(name$$1);\n  }\n\n  // DEPRECATED\n  //\n  // Object literals.\n  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n    Ctor = _class2.extend(Ctor);\n  }\n\n  // This allows us to check this before instantiating the custom element to\n  // find its name from the constructor in the vdom module, thus improving\n  // performance but still falling back to a robust method.\n  Ctor[name] = name$$1;\n\n  // Sipmle define. Not supporting customised built-ins yet.\n  customElements.define(name$$1, Ctor);\n\n  // The spec doesn't return but this allows for a simpler, more concise API.\n  return Ctor;\n};\n\nvar Event = function (TheEvent) {\n  if (TheEvent) {\n    try {\n      new TheEvent('emit-init'); // eslint-disable-line no-new\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return TheEvent;\n}(root.Event);\n\nfunction createCustomEvent(name) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var detail = opts.detail;\n\n  delete opts.detail;\n\n  var e = void 0;\n  if (Event) {\n    e = new Event(name, opts);\n    Object.defineProperty(e, 'detail', { value: detail });\n  } else {\n    e = document.createEvent('CustomEvent');\n    Object.defineProperty(e, 'composed', { value: opts.composed });\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n  }\n  return e;\n}\n\nvar emit = function (elem, name) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opts.bubbles === undefined) {\n    opts.bubbles = true;\n  }\n  if (opts.cancelable === undefined) {\n    opts.cancelable = true;\n  }\n  if (opts.composed === undefined) {\n    opts.composed = true;\n  }\n  return elem.dispatchEvent(createCustomEvent(name, opts));\n};\n\nfunction getValue(elem) {\n  var type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nvar link = function (elem, target) {\n  return function (e) {\n    var value = getValue(e.target);\n    var localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      var parts = localTarget.split('.');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n    } else {\n      props$1(elem, defineProperty({}, localTarget, value));\n    }\n  };\n};\n\nvar ready = function (elem, done) {\n  var info = data(elem);\n  if (elem[created]) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n};\n\nvar h = builder();\n\nexports.Component = _class2;\nexports.define = define;\nexports.emit = emit;\nexports.h = h;\nexports.link = link;\nexports.prop = prop;\nexports.props = props$1;\nexports.ready = ready;\nexports.symbols = symbols$1;\nexports.vdom = vdom;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs/dist/index.js\n// module id = 2\n// module chunks = 0","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/incremental-dom/dist/incremental-dom-cjs.js\n// module id = 3\n// module chunks = 0","'use strict'\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n  (typeof global === 'object' && global.global === global && global) ||\n  this\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/window-or-global/lib/index.js\n// module id = 4\n// module chunks = 0","import cssBase from 'todomvc-common/base.css';\nimport cssApp from 'todomvc-app-css/index.css';\n\nconst { head } = document;\nconst cssBaseStyle = document.createElement('style');\nconst cssAppStyle = document.createElement('style');\n\ncssBaseStyle.textContent = cssBase.toString();\ncssAppStyle.textContent = cssApp.toString();\n\nhead.appendChild(cssBaseStyle);\nhead.appendChild(cssAppStyle);\n\nexport default cssBase.toString() + cssApp.toString();\nexport const classes = { ...cssBase.locals, ...cssApp.locals };\n\n\n\n// WEBPACK FOOTER //\n// ./src/style.js","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"hr {\\n\\tmargin: 20px 0;\\n\\tborder: 0;\\n\\tborder-top: 1px dashed #c5c5c5;\\n\\tborder-bottom: 1px dashed #f7f7f7;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd a {\\n\\tfont-weight: normal;\\n\\ttext-decoration: none;\\n\\tcolor: #b83f45;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd a:hover {\\n\\ttext-decoration: underline;\\n\\tcolor: #787e7e;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd h3,\\n.cPEPub0maVFxkzbgWUVOd h4,\\n.cPEPub0maVFxkzbgWUVOd h5 {\\n\\tmargin: 10px 0;\\n\\tfont-weight: 500;\\n\\tline-height: 1.2;\\n\\tcolor: #000;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd h3 {\\n\\tfont-size: 24px;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd h4 {\\n\\tfont-size: 18px;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd h5 {\\n\\tmargin-bottom: 0;\\n\\tfont-size: 14px;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd ul {\\n\\tpadding: 0;\\n\\tmargin: 0 0 30px 25px;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd li {\\n\\tline-height: 20px;\\n}\\n\\n.cPEPub0maVFxkzbgWUVOd p {\\n\\tfont-size: 15px;\\n\\tfont-weight: 300;\\n\\tline-height: 1.3;\\n\\tmargin-top: 0;\\n\\tmargin-bottom: 0;\\n}\\n\\n#_3-nj88w-cbLlFAkd9E0Nbc {\\n\\tdisplay: none;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF {\\n\\tborder: none;\\n\\tmargin: 20px 0 60px 0;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF p {\\n\\tfont-style: italic;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF p:before {\\n\\tcontent: '\\\\201C';\\n\\tfont-size: 50px;\\n\\topacity: .15;\\n\\tposition: absolute;\\n\\ttop: -20px;\\n\\tleft: 3px;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF p:after {\\n\\tcontent: '\\\\201D';\\n\\tfont-size: 50px;\\n\\topacity: .15;\\n\\tposition: absolute;\\n\\tbottom: -42px;\\n\\tright: 3px;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF footer {\\n\\tposition: absolute;\\n\\tbottom: -40px;\\n\\tright: 0;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF footer img {\\n\\tborder-radius: 3px;\\n}\\n\\n._2L69OI9oxKrr_A0PkWO2KF footer a {\\n\\tmargin-left: 5px;\\n\\tvertical-align: middle;\\n}\\n\\n._1nt1kCjSYEPZou23lObNdv {\\n\\tposition: relative;\\n\\tpadding: 10px;\\n\\tbackground: rgba(0, 0, 0, .04);\\n\\tborder-radius: 5px;\\n}\\n\\n._1nt1kCjSYEPZou23lObNdv:after {\\n\\tcontent: '';\\n\\tposition: absolute;\\n\\ttop: 100%;\\n\\tright: 30px;\\n\\tborder: 13px solid transparent;\\n\\tborder-top-color: rgba(0, 0, 0, .04);\\n}\\n\\n._2vLQrIvSjobb3988bLfSTa > .cPEPub0maVFxkzbgWUVOd {\\n\\tposition: absolute;\\n\\twidth: 272px;\\n\\ttop: 8px;\\n\\tleft: -300px;\\n\\tpadding: 10px;\\n\\tborder-radius: 5px;\\n\\tbackground-color: rgba(255, 255, 255, .6);\\n\\ttransition-property: left;\\n\\ttransition-duration: 500ms;\\n}\\n\\n@media (min-width: 899px) {\\n\\t._2vLQrIvSjobb3988bLfSTa {\\n\\t\\twidth: auto;\\n\\t\\tpadding-left: 300px;\\n\\t}\\n\\n\\t._2vLQrIvSjobb3988bLfSTa > .cPEPub0maVFxkzbgWUVOd {\\n\\t\\tleft: 8px;\\n\\t}\\n}\\n\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\"issue-count\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\"issueCount\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\"speech-bubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\"speechBubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\"learn-bar\": \"_2vLQrIvSjobb3988bLfSTa\",\n\t\"learnBar\": \"_2vLQrIvSjobb3988bLfSTa\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/todomvc-common/base.css\n// module id = 6\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 7\n// module chunks = 0","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"html,\\nbody {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n}\\n\\nbutton {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tborder: 0;\\n\\tbackground: none;\\n\\tfont-size: 100%;\\n\\tvertical-align: baseline;\\n\\tfont-family: inherit;\\n\\tfont-weight: inherit;\\n\\tcolor: inherit;\\n\\t-webkit-appearance: none;\\n\\tappearance: none;\\n\\t-webkit-font-smoothing: antialiased;\\n\\t-moz-osx-font-smoothing: grayscale;\\n}\\n\\nbody {\\n\\tfont: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;\\n\\tline-height: 1.4em;\\n\\tbackground: #f5f5f5;\\n\\tcolor: #4d4d4d;\\n\\tmin-width: 230px;\\n\\tmax-width: 550px;\\n\\tmargin: 0 auto;\\n\\t-webkit-font-smoothing: antialiased;\\n\\t-moz-osx-font-smoothing: grayscale;\\n\\tfont-weight: 300;\\n}\\n\\n:focus {\\n\\toutline: 0;\\n}\\n\\n.RBzyqGlIYFAdozfNAWX9T {\\n\\tdisplay: none;\\n}\\n\\n._2lTeO9Nfd9StmHCibrKyDn {\\n\\tbackground: #fff;\\n\\tmargin: 130px 0 40px 0;\\n\\tposition: relative;\\n\\tbox-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),\\n\\t            0 25px 50px 0 rgba(0, 0, 0, 0.1);\\n}\\n\\n._2lTeO9Nfd9StmHCibrKyDn input::-webkit-input-placeholder {\\n\\tfont-style: italic;\\n\\tfont-weight: 300;\\n\\tcolor: #e6e6e6;\\n}\\n\\n._2lTeO9Nfd9StmHCibrKyDn input::-moz-placeholder {\\n\\tfont-style: italic;\\n\\tfont-weight: 300;\\n\\tcolor: #e6e6e6;\\n}\\n\\n._2lTeO9Nfd9StmHCibrKyDn input::input-placeholder {\\n\\tfont-style: italic;\\n\\tfont-weight: 300;\\n\\tcolor: #e6e6e6;\\n}\\n\\n._2lTeO9Nfd9StmHCibrKyDn h1 {\\n\\tposition: absolute;\\n\\ttop: -155px;\\n\\twidth: 100%;\\n\\tfont-size: 100px;\\n\\tfont-weight: 100;\\n\\ttext-align: center;\\n\\tcolor: rgba(175, 47, 47, 0.15);\\n\\t-webkit-text-rendering: optimizeLegibility;\\n\\t-moz-text-rendering: optimizeLegibility;\\n\\ttext-rendering: optimizeLegibility;\\n}\\n\\n.vdff5WcLi7yBBYDjtZljm,\\n._3RmQY0IMcqwS7R81Tj0dlC {\\n\\tposition: relative;\\n\\tmargin: 0;\\n\\twidth: 100%;\\n\\tfont-size: 24px;\\n\\tfont-family: inherit;\\n\\tfont-weight: inherit;\\n\\tline-height: 1.4em;\\n\\tborder: 0;\\n\\tcolor: inherit;\\n\\tpadding: 6px;\\n\\tborder: 1px solid #999;\\n\\tbox-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);\\n\\tbox-sizing: border-box;\\n\\t-webkit-font-smoothing: antialiased;\\n\\t-moz-osx-font-smoothing: grayscale;\\n}\\n\\n.vdff5WcLi7yBBYDjtZljm {\\n\\tpadding: 16px 16px 16px 60px;\\n\\tborder: none;\\n\\tbackground: rgba(0, 0, 0, 0.003);\\n\\tbox-shadow: inset 0 -2px 1px rgba(0,0,0,0.03);\\n}\\n\\n._3dnsc4idur8-yk5Sjjq6VG {\\n\\tposition: relative;\\n\\tz-index: 2;\\n\\tborder-top: 1px solid #e6e6e6;\\n}\\n\\nlabel[for='toggle-all'] {\\n\\tdisplay: none;\\n}\\n\\n.DG0VaCEN4BXUysJd_tTIb {\\n\\tposition: absolute;\\n\\ttop: -55px;\\n\\tleft: -12px;\\n\\twidth: 60px;\\n\\theight: 34px;\\n\\ttext-align: center;\\n\\tborder: none; /* Mobile Safari */\\n}\\n\\n.DG0VaCEN4BXUysJd_tTIb:before {\\n\\tcontent: '\\\\276F';\\n\\tfont-size: 22px;\\n\\tcolor: #e6e6e6;\\n\\tpadding: 10px 27px 10px 27px;\\n}\\n\\n.DG0VaCEN4BXUysJd_tTIb:checked:before {\\n\\tcolor: #737373;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tlist-style: none;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li {\\n\\tposition: relative;\\n\\tfont-size: 24px;\\n\\tborder-bottom: 1px solid #ededed;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li:last-child {\\n\\tborder-bottom: none;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm {\\n\\tborder-bottom: none;\\n\\tpadding: 0;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm ._3RmQY0IMcqwS7R81Tj0dlC {\\n\\tdisplay: block;\\n\\twidth: 506px;\\n\\tpadding: 12px 16px;\\n\\tmargin: 0 0 0 43px;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm .oksgs4_M9fAGjexFoJHTE {\\n\\tdisplay: none;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5 {\\n\\ttext-align: center;\\n\\twidth: 40px;\\n\\t/* auto, since non-WebKit browsers doesn't support input styling */\\n\\theight: auto;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\tbottom: 0;\\n\\tmargin: auto 0;\\n\\tborder: none; /* Mobile Safari */\\n\\t-webkit-appearance: none;\\n\\tappearance: none;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:after {\\n\\tcontent: url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#ededed\\\" stroke-width=\\\"3\\\"/></svg>');\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:checked:after {\\n\\tcontent: url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#bddad5\\\" stroke-width=\\\"3\\\"/><path fill=\\\"#5dc2af\\\" d=\\\"M72 25L42 71 27 56l-4 4 20 20 34-52z\\\"/></svg>');\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li label {\\n\\tword-break: break-all;\\n\\tpadding: 15px 60px 15px 15px;\\n\\tmargin-left: 45px;\\n\\tdisplay: block;\\n\\tline-height: 1.2;\\n\\ttransition: color 0.4s;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li._29S5oJEhfUYjuw83RXIvg0 label {\\n\\tcolor: #d9d9d9;\\n\\ttext-decoration: line-through;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE {\\n\\tdisplay: none;\\n\\tposition: absolute;\\n\\ttop: 0;\\n\\tright: 10px;\\n\\tbottom: 0;\\n\\twidth: 40px;\\n\\theight: 40px;\\n\\tmargin: auto 0;\\n\\tfont-size: 30px;\\n\\tcolor: #cc9a9a;\\n\\tmargin-bottom: 11px;\\n\\ttransition: color 0.2s ease-out;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:hover {\\n\\tcolor: #af5b5e;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:after {\\n\\tcontent: '\\\\D7';\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li:hover ._3dDZq0iA7OOgE8KkLYlAeE {\\n\\tdisplay: block;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li ._3RmQY0IMcqwS7R81Tj0dlC {\\n\\tdisplay: none;\\n}\\n\\n._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm:last-child {\\n\\tmargin-bottom: -1px;\\n}\\n\\n.OfZp78rLkg_PWvZV9RYDG {\\n\\tcolor: #777;\\n\\tpadding: 10px 15px;\\n\\theight: 20px;\\n\\ttext-align: center;\\n\\tborder-top: 1px solid #e6e6e6;\\n}\\n\\n.OfZp78rLkg_PWvZV9RYDG:before {\\n\\tcontent: '';\\n\\tposition: absolute;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\theight: 50px;\\n\\toverflow: hidden;\\n\\tbox-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),\\n\\t            0 8px 0 -3px #f6f6f6,\\n\\t            0 9px 1px -3px rgba(0, 0, 0, 0.2),\\n\\t            0 16px 0 -6px #f6f6f6,\\n\\t            0 17px 2px -6px rgba(0, 0, 0, 0.2);\\n}\\n\\n._1r5RuM5EHD-zS8b-wG0XPc {\\n\\tfloat: left;\\n\\ttext-align: left;\\n}\\n\\n._1r5RuM5EHD-zS8b-wG0XPc strong {\\n\\tfont-weight: 300;\\n}\\n\\n._2tY47NKf597SqoScbkboy0 {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tlist-style: none;\\n\\tposition: absolute;\\n\\tright: 0;\\n\\tleft: 0;\\n}\\n\\n._2tY47NKf597SqoScbkboy0 li {\\n\\tdisplay: inline;\\n}\\n\\n._2tY47NKf597SqoScbkboy0 li a {\\n\\tcolor: inherit;\\n\\tmargin: 3px;\\n\\tpadding: 3px 7px;\\n\\ttext-decoration: none;\\n\\tborder: 1px solid transparent;\\n\\tborder-radius: 3px;\\n}\\n\\n._2tY47NKf597SqoScbkboy0 li a:hover {\\n\\tborder-color: rgba(175, 47, 47, 0.1);\\n}\\n\\n._2tY47NKf597SqoScbkboy0 li a.a8u8grJpMWz2FTlLtocrT {\\n\\tborder-color: rgba(175, 47, 47, 0.2);\\n}\\n\\n._1uOFz1y8zCB-ylF3BS8V7J,\\nhtml ._1uOFz1y8zCB-ylF3BS8V7J:active {\\n\\tfloat: right;\\n\\tposition: relative;\\n\\tline-height: 20px;\\n\\ttext-decoration: none;\\n\\tcursor: pointer;\\n}\\n\\n._1uOFz1y8zCB-ylF3BS8V7J:hover {\\n\\ttext-decoration: underline;\\n}\\n\\n._3qrb6fjG3vwl0RExKf3l_q {\\n\\tmargin: 65px auto 0;\\n\\tcolor: #bfbfbf;\\n\\tfont-size: 10px;\\n\\ttext-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);\\n\\ttext-align: center;\\n}\\n\\n._3qrb6fjG3vwl0RExKf3l_q p {\\n\\tline-height: 1;\\n}\\n\\n._3qrb6fjG3vwl0RExKf3l_q a {\\n\\tcolor: inherit;\\n\\ttext-decoration: none;\\n\\tfont-weight: 400;\\n}\\n\\n._3qrb6fjG3vwl0RExKf3l_q a:hover {\\n\\ttext-decoration: underline;\\n}\\n\\n/*\\n\\tHack to remove background from Mobile Safari.\\n\\tCan't use it globally since it destroys checkboxes in Firefox\\n*/\\n@media screen and (-webkit-min-device-pixel-ratio:0) {\\n\\t.DG0VaCEN4BXUysJd_tTIb,\\n\\t._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5 {\\n\\t\\tbackground: none;\\n\\t}\\n\\n\\t._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5 {\\n\\t\\theight: 40px;\\n\\t}\\n\\n\\t.DG0VaCEN4BXUysJd_tTIb {\\n\\t\\t-webkit-transform: rotate(90deg);\\n\\t\\ttransform: rotate(90deg);\\n\\t\\t-webkit-appearance: none;\\n\\t\\tappearance: none;\\n\\t}\\n}\\n\\n@media (max-width: 430px) {\\n\\t.OfZp78rLkg_PWvZV9RYDG {\\n\\t\\theight: 50px;\\n\\t}\\n\\n\\t._2tY47NKf597SqoScbkboy0 {\\n\\t\\tbottom: 10px;\\n\\t}\\n}\\n\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\"new-todo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\"newTodo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\"toggle-all\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\"toggleAll\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\"todo-list\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\"todoList\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\"todo-count\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\"todoCount\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\"clear-completed\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\"clearCompleted\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\",\n\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/todomvc-app-css/index.css\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}