{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/index.js","webpack:///webpack/bootstrap a8da79e1ae2cd244c1a4","webpack:///./src/index.js","webpack:///./~/skatejs-web-components/dist/index.js","webpack:///./~/skatejs/dist/index.js","webpack:///./~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///./~/window-or-global/lib/index.js","webpack:///./src/style.js","webpack:///./~/todomvc-common/base.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/todomvc-app-css/index.css"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","getCompleted","todos","filter","todo","isCompleted","getPlural","count","getTodoMode","isEditing","_style","classes","editing","completed","_createClass","defineProperties","target","props","length","descriptor","defineProperty","key","protoProps","staticProps","_skatejs","_style2","_window","window","customElements","TodoApp","_Component","_ref","_temp","_this","_ret","_len","arguments","args","Array","_key","getPrototypeOf","apply","concat","handleChange","e","_this2","checked","todoIndex","parseFloat","getAttribute","map","currentTodoIndex","handleClear","handleRemove","preventDefault","handleSubmit","description","currentValue","handleToggle","_ref2","todosLength","_getCompleted","todosCompletedLength","incompleteTodosLength","h","class","todoapp","header","onSubmit","autofocus","newTodo","name","onKeyup","link","placeholder","main","toggleAll","type","onChange","for","todoList","view","toggle","data-todo-index","destroy","onClick","edit","footer","todoCount","clearCompleted","info","href","Component","prop","string","array","fixSafari","newAttachShadow","opts","sr","oldAttachShadow","mo","observe","moOpts","HTMLElement","attachShadow","childList","subtree","MutationObserver","muts","forEach","mut","tagName","nextSibling","parentNode","removeChild","insertBefore","navigator","userAgent","safari","indexOf","safariVersion","match","safariVersions","v","patch","eval","Map","j","o","Set","C","D","bind","f","F","enableFlush","s","g","k","test","q","Error","l","b","d","get","toLowerCase","u","n","__$CE_upgraded","localName","A","document","forcePolyfill","split","L","has","set","w","observedAttributes","K","resolve","delete","M","Promise","reject","N","takeRecords","childNodes","HTMLImports","whenReady","I","__$CE_observer","add","J","disconnect","removedNodes","addedNodes","H","nodeType","Node","ELEMENT_NODE","createTreeWalker","NodeFilter","SHOW_ELEMENT","G","currentNode","nextNode","__$CE_attached","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","host","shadowRoot","rel","B","import","removeEventListener","addEventListener","console","assert","attributes","attributeOldValue","attributeFilter","hasAttribute","attributeName","oldValue","attributeNamespace","CustomElementRegistry","whenDefined","flush","polyfilled","_observeRoot","_addImport","r","createElement","t","createElementNS","Element","importNode","setAttribute","removeAttribute","CustomElements","isShadyRoot","Boolean","__localName","matchesSelector","element","selector","matches","copyOwnProperty","source","pd","getOwnPropertyDescriptor","extend","n$","getOwnPropertyNames","extendAll","sources","len","mixin","patchPrototype","proto","hasOwnProperty","patchProto","__sourceProto","__patchProto","newSplice","index","removed","addedCount","getNativeProperty","property","descriptors","enqueue","callback","scheduled","promish","then","flush$1","flushList","push","flushCount","shift","isFlushedMaxed","flushMax","escapeReplace","escapeAttr","replace","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","getOuterHTML","node","composed","attr","attrs","voidElements","getInnerHTML","TEXT_NODE","data","plaintextParents","COMMENT_NODE","error","content","child","c$","filterMutations","mutations","targetRootNode","getRootNode","mutation","mutationInScope","nodes","from","patchNode","settings","inUse","isNodePatched","patchImpl","canPatchNode","tree","saveChildNodes","unpatchNode","unpatch","__patched","pathComposer","startNode","composedPath","current","startRoot","assignedSlot","retarget","refNode","path","ancestor","lastRoot","rootIdx","refNodePath","p$","mixinComposedFlag","Base","klazz","options","event","__composed","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","retargetNonBubblingEvent","__propagationStopped","Event","AT_TARGET","lastFiredRoot","i$1","optionsOrCapture","this$1","capture","once","passive","__eventWrappers","wrapperFn","__target","__relatedTarget","relatedTarget","EventMixin","eventPhase","BUBBLING_PHASE","stopImmediatePropagation","nonBubblingEventsToRetarget","bubble","origAddEventListener","undefined","splice","origRemoveEventListener","idx","activateFocusEventOverrides","ev","ShadyDOM","hasNativeShadowDOM","force","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","common","cb","twiddle","createTextNode","observer","characterData","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","j$1","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","splices","oldIndex","searchLength","index1","index2","calculateSplices","previous","previousValue","nativeInsertBefore","nativeAppendChild","appendChild","nativeRemoveChild","arrayCopyChildNodes","parent","copy","firstChild","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","Logical","Composed","hasParentNode","saveComposedData","__dom","hasChildNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getParentNode","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","recordInsertBefore","container","ref_node","_linkNode","recordRemoveChild","$parentNode","$childNodes","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","NormalizedEvent","inType","params","createEvent","initEvent","bubbles","cancelable","Distributor","anonymous","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","p$1","_assignedSlot","parent$1","insertionPoint","prevAssignedNodes","_assignedNodes","clearAssignedSlots","needsSlotChange","anyDistributed","matchesInsertionPoint","__prevAssignedSlot","distributeNodeInto","node$1","children","setDistributedNodesOnInsertionPoint","_fireSlotChange","slot","savePrevious","slotName","trim","_distributedNodes","d$","dispatchEvent","isFinalDestination","ShadyRoot","frag","createDocumentFragment","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","update","distributionRoot","_findDistributionRoot","render","_elementNeedsDistribution","_skipUpdateInsertionPoints","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","c$1","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","s$1","next","n$1","getInsertionPointTag","DocumentFragment","list","mixinImpl","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","ipAdded","_maybeAddInsertionPoint","handled","_maybeDistribute","removeNode","distributed","logicalParent","maybeDistributeParent","_removeDistributedChildren","_removeOwnerShadyRoot","_scheduleObserver","addedNode","removedNode","schedule","removeNodeFromParent","_hasCachedOwnerRoot","__ownerShadyRoot","documentElement","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","ip$","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","isShadyRoot$$1","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","nativeSetAttribute","nativeRemoveAttribute","ShadyCSS","setElementClass","NodeMixin","parentElement","FragmentMixin","replaceChild","deep","nc","externalNode","doc","ownerDocument","isArray","textContent","tc","cn","join","text","innerHTML","ElementMixin","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","Fragment","AsyncObserver","_scheduled","callbacks","observeChildren","_callback","_observer","_node","unobserveChildren","handle","size","patchedCount","log","head","hasPrototypeDescriptors","warn","mixinForObject","mixinForNode","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","isTrusted","__composedPath","currentTarget","__relatedTargetComposedPath","stopPropagation","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","isPatched","createRootAndEnsurePatched","parse","clean","parseCss","lex","cssText","RX","comments","port","start","end","OPEN_BRACE","rules","CLOSE_BRACE","substring","parsedCssText","ss","_expandUnicodeEscapes","multipleSpaces","lastIndexOf","parsedSelector","atRule","AT_START","MEDIA_START","types","MEDIA_RULE","keyframesRule","KEYFRAMES_RULE","keyframesName","pop","VAR_START","MIXIN_RULE","STYLE_RULE","r$","code","repeat","stringify","preserveProperties","_hasMixinRules","removeCustomProps","removeCustomPropAssignment","removeCustomPropApply","customProp","mixinProp","mixinApply","varApply","parseSettings","nativeCssVariables","shimcssproperties","nativeShadow","shimshadow","toCssText","forEachRule","rulesForStyle","style","__cssRules","isKeyframesSelector","rule","styleRuleCallback","keyframesRuleCallback","onlyActiveRules","skipRules","matchMedia","rx","MEDIA_MATCH","applyCss","moniker","contextNode","createScopeStyle","applyStyle$1","after","lastHeadApplyNode","applyStylePlaceHolder","placeHolder","createComment","scope","findMatchingParen","level","processVariableAndFallback","str","inner","prefix","suffix","comma","fallback","addToBitMask","bits","parseInt","enqueueDocumentValidation","enqueued","validateDocument","readyState","requestAnimationFrame","ShadyCSS$1","updateStyles","CustomStyle","Reflect","construct","customStyles","CSS","supports","nativeCssApply","WebComponents","flags","VAR_ASSIGN","MIXIN_MATCH","VAR_CONSUMED","ANIMATION_MATCH","IS_VAR","BRACKETED","HOST_PREFIX","HOST_SUFFIX","SCOPE_NAME","StyleTransformer","dom","shouldRemoveScope","__styleScoped","_transformDom","classList","_content","_element","remove","CLASS","elementStyles","styleRules","cssBuildType","__cssBuild","css","is","extends","ext","hostScope","_calcHostScope","_calcElementScope","isScoped","CSS_CLASS_PREFIX","_rule","_transformRule","_transformComplexSelector","transformer","transformedSelector","_transformRuleCss","COMPLEX_SELECTOR_SEP","stop","NTH","SLOTTED_START","HOST","SIMPLE_SELECTOR_SEP","_transformCompoundSelector","combinator","slottedIndex","SLOTTED","_transformHostSelector","_transformSimpleSelector","slotted","SLOTTED_PAREN","paren","DIR_PAREN","before","dir","PSEUDO_PREFIX","HOST_PAREN","SIMPLE_SELECTOR_PREFIX","typeSelector","SELECTOR_NO_MATCH","documentRule","normalizeRootSelector","_transformDocumentSelector","ROOT","SCOPE_DOC_SELECTOR","RegExp","classCallCheck","createClass","toConsumableArray","arr2","StyleInfo","ast","ownStylePropertyNames","elementName","typeExtension","cssBuild","overrideStyleProperties","styleProperties","scopeSelector","customStyle","__styleInfo","styleInfo","IS_IE","StyleProperties","decorateStyles","keyframes","ruleIndex","decorateRule","collectPropertiesInCssText","propertyInfo","_keyframes","names","properties","hasProperties","collectProperties","collectCssText","rx$$1","any","exec","assign","collectConsumingCssText","reify","valueForProperty","valueForProperties","propertyValue","_p","parts","lastIndex","colon","pp","slice","applyProperties","output","applyKeyframeTransforms","keyframeTransforms","hasAnimations","transform","keyframeNamesToTransform","keyframe","propertyDataFromStyles","selectorToMatch","whenHostOrRootRule","isRoot","isHost","hostAndRootPropertiesForScope","hostProps","rootProps","transformStyles","hostSelector","rxHostSelector","hostRx","_elementKeyframeTransforms","_scopeSelector","keyframesRules","_scopeKeyframes","_keyframesRuleTransformer","keyframesNameRx","transformedKeyframesName","scopeId","_p2","applyElementScopeSelector","XSCOPE_NAME","applyElementStyle","_useCount","applyCustomStyle","templateMap","placeholderMap","ce","origDefine","clazz","StyleCache","typeMax","cache","cacheEntry","ownPropertyNames","pn","tagname","styleElement","entry","_validate","APPLY_NAME_CLEAN","INITIAL_INHERIT","MIXIN_VAR_SEP","MixinMap","_map","dependants","ApplyShim","_currentTemplate","_measureElement","_separator","_boundProduceCssProperties","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","transformRules","transformRule","__applyShimInvalid","transformCssText","_consumeCssProperties","all","getComputedStyle","getPropertyValue","mixinName","applyPos","afterApplyPos","textBeforeApply","textAfterApply","defaults$$1","_cssTextToMap","replacement","_atApplyToCssProperties","fallbacks","vars","mixinEntry","_getInitialValueForProperty","sp","out","_replaceInitialOrInherit","_this3","mixinAsProperties","mixinValues","combinedProps","oldProps","needToInvalidate","_invalidateMixinEntry","applyShim","handler","mxns","x","mxn","_i","_n","classIdx","_scope","startState","body","styleCache","scopeCounter","nativeCss","_documentOwner","_documentOwnerStyleInfo","_generateScopeSelector","getStyleAst","styleAstToString","_gatherStyles","template","styles","_getCssBuild","prepareTemplate","_prepared","_styleAst","_generateStaticStyle","_ownPropertyNames","shadowroot","_prepareHost","_cssBuild","applyStyle","overrideProps","CS","_documentDirty","findStyles","_revalidateApplyShim","_updateProperties","applyStyles","_updateNativeProperties","_applyStyleProperties","_isRootOwner","_applyToDescendants","_styleOwnerForNode","fetch","cachedScopeSelector","cachedStyle","oldScopeSelector","store","owner","ownerStyleInfo","ownerProperties","hostAndRootProps","propertyData","propertiesMatchingHost","_mixinOverrideStyles","overrides","removeProperty","setProperty","_transformCustomStyleForDocument","_applyCustomStyleToDocument","getComputedStyleValue","classString","_element$classList","_styleInfoForNode","hookFn","processHook","_customStyles","_findStyle","_applyStyle","__appliedElement","global","incrementalDom","keys","_ref$enumOnly","enumOnly","listOfKeys","getOwnPropertySymbols","def","unshift","enter","object","saved","exit","applyEvent","elem","ename","newFunc","events","$currentEventHandlers","resolveTagName","name$$1","elementOpenStart","tag","statics","overrideArgs","elementOpenEnd","newElementOpen","wrapIdomFunc","func","tnameFuncHandler","noop","wrap","stackCurrentHelper","stackChren","elementOpen$1","skips","$skip","elementClose","skip","_elem","ref$$1","ref$1","newAttr","_len2","_key2","$stackCurrentHelperProps","stackOpen","tname","props$$1","_len3","_key3","stackClose","chren","elemOrFn","newElementVoid","_len4","_key4","newElementClose","atype","_typeof","_len5","_key5","newElementOpenStart","newElementOpenEnd","ch","ctype","newText","sch","builder","_len6","tags","_key6","_len7","_key7","_len8","_key8","createSymbol","Symbol","microtaskDebounce","cbFunc","cbArgs","taskDebounce","setTimeout","getAttrMgr","mgr","$attributesMgr","AttributesManager","error$1","message","DEBUG","isUndefined","resolveAttrName","attrOption","nameOrSymbol","toString","dashCase","String","setCtorNativeProperty","Ctor","propName","getPropsMap","ctorPropsMap","propsMap","reduce","propNameOrSymbol","PropDefinition","get$2","set$2","newProps","renderer$1","getDefaultValue","propDef","getInitialValue","initial","getPropData","elemData","createNativePropertyDescriptor","beforeDefineProperty","propData","attrName","initialValue","valueFromAttribute","empty","deserialize","coerce","internalValue","serializedValue","serialize","setAttrValue","newValue","useDefaultValue","changeData","rendererDebounced","settingProp","preventDoubleCalling","_prevName","_prevOldValue","_prevNewValue","createNativePropertyDescriptors","propDefs","propDescriptors","createInitProps","propDescriptor","hasPropBeforeUpgrading","valueBeforeUpgrading","uniqueId","rand","random","createCustomEvent","detail","initCustomEvent","getValue","arg","val","toNullOrString","JSON","boolean","zeroIfEmptyOrNumberIncludesNaN","Number","number","freeze","connected","created","ctorCreateInitProps","ctorObservedAttributes","ctorProps","rendering","updated$1","symbols$1","propContext","iterator","AwaitValue","AsyncGenerator","gen","send","request","back","front","resume","settle","done","err","_invoke","return","asyncIterator","throw","await","get$1","receiver","Function","desc","getter","inherits","possibleConstructorReturn","applyDefault","symbols","attributesContext","applyProp","className","disabled","ref","firstChar","eventName","toUpperCase","elementOpen","vdom","elementVoid","namespace","__SKATE_DATA","nativeHints","native","hint","debounce","isFunction","pendingValues","lastSetValues","_syncAttrValue","_clearPendingValue","changed","currAttrValue","getOwnPropertyDescriptors","prev","curr","one","two","dash","propOptions","_name","option","optVal","props$1","objectIs","y","HTMLElement$1","_class","_class2","_HTMLElement","propDefsCount","renderCallback","created$$1","readyCallbacks","attrsOnCtor","attrsFromLinkedProps","item","resumeAttributesUpdates","attached","suspendAttributesUpdates","detached","changedExternally","onAttributeChanged","newPropVal","attributeChanged","prevProps","updated","rendered","renderer","rendererCallback","renderedCallback","updatedCallback","definition","_Base","prot","mode","patchInner","possibleFn","allKeys","TheEvent","emit","localTarget","firstPart","ready","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","Context","notifications","nodesCreated","deleted","nodesDeleted","initData","getData","getNamespace","applyAttr","el","attrNS","setAttributeNS","elStyle","applyAttributeTyped","updateAttribute","mutator","getNamespaceForTag","namespaceURI","createText","createKeyMap","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","context","patchFactory","run","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","enterNode","exitNode","patchOuter","alignWithDOM","clearUnvisitedDOM","coreElementOpen","coreElementClose","coreText","currentElement","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","_attr","elementPlaceholder","formatted","_extends","_base","_base2","_index","_index2","_document","cssBaseStyle","cssAppStyle","locals","learn","issue-count","issueCount","quote","speech-bubble","speechBubble","learn-bar","learnBar","mediaQuery","alreadyImportedModules","hidden","new-todo","toggle-all","todo-list","todo-count","filters","selected","clear-completed"],"mappings":"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","file":"dist/index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(1);\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _style = __webpack_require__(5);\n\t\n\tvar _style2 = _interopRequireDefault(_style);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx h */\n\t\n\tvar _window = window,\n\t    customElements = _window.customElements;\n\t\n\t\n\tfunction getCompleted(todos) {\n\t  return todos.filter(function (todo) {\n\t    return todo.isCompleted;\n\t  });\n\t}\n\t\n\tfunction getPlural(count) {\n\t  return count === 1 ? '' : 's';\n\t}\n\t\n\tfunction getTodoMode(todo) {\n\t  if (todo.isEditing) {\n\t    return _style.classes.editing;\n\t  }\n\t\n\t  if (todo.isCompleted) {\n\t    return _style.classes.completed;\n\t  }\n\t\n\t  return '';\n\t}\n\t\n\tvar TodoApp = function (_Component) {\n\t  _inherits(TodoApp, _Component);\n\t\n\t  function TodoApp() {\n\t    var _ref;\n\t\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, TodoApp);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TodoApp.__proto__ || Object.getPrototypeOf(TodoApp)).call.apply(_ref, [this].concat(args))), _this), _this.handleChange = function (e) {\n\t      var _this2 = _this,\n\t          todos = _this2.todos;\n\t      var target = e.target,\n\t          checked = e.target.checked;\n\t\n\t      var todoIndex = parseFloat(target.getAttribute('data-todo-index'));\n\t      _this.todos = todos.map(function (todo, currentTodoIndex) {\n\t        if (currentTodoIndex === todoIndex) {\n\t          todo.isCompleted = checked;\n\t        }\n\t        return todo;\n\t      });\n\t    }, _this.handleClear = function () {\n\t      _this.todos = _this.todos.filter(function (todo) {\n\t        return !todo.isCompleted;\n\t      });\n\t    }, _this.handleRemove = function (e) {\n\t      var todoIndex = parseFloat(e.target.getAttribute('data-todo-index'));\n\t      e.preventDefault();\n\t      _this.todos = _this.todos.filter(function (todo, currentTodoIndex) {\n\t        return currentTodoIndex !== todoIndex;\n\t      });\n\t    }, _this.handleSubmit = function (e) {\n\t      e.preventDefault();\n\t      _this.todos = _this.todos.concat({\n\t        isCompleted: false,\n\t        isEditing: false,\n\t        description: _this.currentValue\n\t      });\n\t      _this.currentValue = '';\n\t    }, _this.handleToggle = function (e) {\n\t      var checked = e.target.checked;\n\t\n\t      _this.todos = _this.todos.map(function (todo) {\n\t        todo.isCompleted = checked;\n\t        return todo;\n\t      });\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  _createClass(TodoApp, [{\n\t    key: 'renderCallback',\n\t    value: function renderCallback(_ref2) {\n\t      var currentValue = _ref2.currentValue,\n\t          handleChange = _ref2.handleChange,\n\t          handleClear = _ref2.handleClear,\n\t          handleRemove = _ref2.handleRemove,\n\t          handleToggle = _ref2.handleToggle,\n\t          handleSubmit = _ref2.handleSubmit,\n\t          todos = _ref2.todos;\n\t      var todosLength = todos.length;\n\t\n\t      var _getCompleted = getCompleted(todos),\n\t          todosCompletedLength = _getCompleted.length;\n\t\n\t      var incompleteTodosLength = todosLength - todosCompletedLength;\n\t\n\t      return [(0, _skatejs.h)(\n\t        'style',\n\t        null,\n\t        _style2.default\n\t      ), (0, _skatejs.h)(\n\t        'section',\n\t        { 'class': _style.classes.todoapp },\n\t        (0, _skatejs.h)(\n\t          'header',\n\t          { 'class': _style.classes.header },\n\t          (0, _skatejs.h)(\n\t            'h1',\n\t            null,\n\t            'todos'\n\t          ),\n\t          (0, _skatejs.h)(\n\t            'form',\n\t            { onSubmit: handleSubmit },\n\t            (0, _skatejs.h)('input', {\n\t              autofocus: true,\n\t              'class': _style.classes.newTodo,\n\t              name: 'currentValue',\n\t              onKeyup: (0, _skatejs.link)(this),\n\t              placeholder: 'What needs to be done?',\n\t              value: currentValue\n\t            })\n\t          )\n\t        ),\n\t        todosLength ? (0, _skatejs.h)(\n\t          'section',\n\t          { 'class': _style.classes.main },\n\t          (0, _skatejs.h)('input', {\n\t            'class': _style.classes.toggleAll, type: 'checkbox',\n\t            onChange: handleToggle\n\t          }),\n\t          (0, _skatejs.h)(\n\t            'label',\n\t            { 'for': 'toggle-all' },\n\t            'Mark all as complete'\n\t          ),\n\t          (0, _skatejs.h)(\n\t            'ul',\n\t            { 'class': _style.classes.todoList },\n\t            todos.map(function (todo, todoIndex) {\n\t              return (0, _skatejs.h)(\n\t                'li',\n\t                { 'class': getTodoMode(todo) },\n\t                (0, _skatejs.h)(\n\t                  'div',\n\t                  { 'class': _style.classes.view },\n\t                  (0, _skatejs.h)('input', {\n\t                    'class': _style.classes.toggle,\n\t                    checked: todo.isCompleted,\n\t                    'data-todo-index': todoIndex,\n\t                    onChange: handleChange,\n\t                    type: 'checkbox'\n\t                  }),\n\t                  (0, _skatejs.h)(\n\t                    'label',\n\t                    null,\n\t                    todo.description\n\t                  ),\n\t                  (0, _skatejs.h)('button', {\n\t                    'class': _style.classes.destroy,\n\t                    'data-todo-index': todoIndex,\n\t                    onClick: handleRemove\n\t                  })\n\t                ),\n\t                (0, _skatejs.h)('input', { 'class': _style.classes.edit, value: 'Create a TodoMVC template' })\n\t              );\n\t            })\n\t          )\n\t        ) : '',\n\t        todosLength ? (0, _skatejs.h)(\n\t          'footer',\n\t          { 'class': _style.classes.footer },\n\t          (0, _skatejs.h)(\n\t            'span',\n\t            { 'class': _style.classes.todoCount },\n\t            (0, _skatejs.h)(\n\t              'strong',\n\t              null,\n\t              incompleteTodosLength\n\t            ),\n\t            ' item' + getPlural(incompleteTodosLength) + ' left'\n\t          ),\n\t          todosCompletedLength ? (0, _skatejs.h)(\n\t            'button',\n\t            {\n\t              'class': _style.classes.clearCompleted,\n\t              onClick: handleClear\n\t            },\n\t            'Clear completed'\n\t          ) : ''\n\t        ) : ''\n\t      ), (0, _skatejs.h)(\n\t        'footer',\n\t        { 'class': _style.classes.info },\n\t        (0, _skatejs.h)(\n\t          'p',\n\t          null,\n\t          'Double-click to edit a todo'\n\t        ),\n\t        (0, _skatejs.h)(\n\t          'p',\n\t          null,\n\t          'Created by the ',\n\t          (0, _skatejs.h)(\n\t            'a',\n\t            { href: 'https://github.com/skatejs/skatejs' },\n\t            'SkateJS Team'\n\t          )\n\t        ),\n\t        (0, _skatejs.h)(\n\t          'p',\n\t          null,\n\t          'Part of ',\n\t          (0, _skatejs.h)(\n\t            'a',\n\t            { href: 'http://todomvc.com' },\n\t            'TodoMVC'\n\t          )\n\t        )\n\t      )];\n\t    }\n\t  }]);\n\t\n\t  return TodoApp;\n\t}(_skatejs.Component);\n\t\n\tTodoApp.props = {\n\t  currentValue: _skatejs.prop.string(),\n\t  todos: _skatejs.prop.array()\n\t};\n\t\n\t\n\tcustomElements.define('todo-app', TodoApp);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"skatejsWebComponents\"] = factory();\n\t\telse\n\t\t\troot[\"skatejsWebComponents\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\t// We load the Safari fix first because the custom element polyfill overrides\n\t\t// attachShadow() to observe the shadow root.\n\t\t__webpack_require__(1);\n\t\t\n\t\t// We have to include this first so that it can patch native.\n\t\t__webpack_require__(2);\n\t\t\n\t\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t\t// ShadyDOM polyfill be loaded first.\n\t\t__webpack_require__(3);\n\t\t__webpack_require__(4);\n\t\t__webpack_require__(5);\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t  value: true\n\t\t});\n\t\tvar _window = window,\n\t\t    HTMLElement = _window.HTMLElement,\n\t\t    MutationObserver = _window.MutationObserver,\n\t\t    navigator = _window.navigator;\n\t\tvar userAgent = navigator.userAgent;\n\t\t\n\t\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\t\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\t\tvar safariVersions = [0, 1].map(function (v) {\n\t\t  return '10.0.' + v;\n\t\t}).concat(['10.0']);\n\t\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\t\n\t\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\t\tfunction fixSafari() {\n\t\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\t\n\t\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t\t  // element as this is the only scenario where styles aren't recalculated.\n\t\t  var moOpts = { childList: true, subtree: true };\n\t\t  var mo = new MutationObserver(function (muts) {\n\t\t    muts.forEach(function (mut) {\n\t\t      var target = mut.target;\n\t\t\n\t\t      if (target.tagName === 'STYLE') {\n\t\t        var nextSibling = target.nextSibling,\n\t\t            parentNode = target.parentNode;\n\t\t\n\t\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t\t        // as it seems that doesn't trigger a recalc.\n\t\t\n\t\t        parentNode.removeChild(target);\n\t\t        parentNode.insertBefore(target, nextSibling);\n\t\t      }\n\t\t    });\n\t\t  });\n\t\t\n\t\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t\t  function newAttachShadow(opts) {\n\t\t    var sr = oldAttachShadow.call(this, opts);\n\t\t    mo.observe(sr, moOpts);\n\t\t    return sr;\n\t\t  }\n\t\t\n\t\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t\t    // Ensure polyfills can override it (hoping they call it back).\n\t\t    configurable: true,\n\t\t    enumerable: true,\n\t\t    value: newAttachShadow,\n\t\t    writable: true\n\t\t  });\n\t\t}\n\t\t\n\t\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t\t// fixes the bug.\n\t\tif (patch) {\n\t\t  fixSafari();\n\t\t}\n\t\t\n\t\texports.default = patch;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t\n\t\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\t/*\n\t\t\n\t\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\t Code distributed by Google as part of the polymer project is also\n\t\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\t\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\t\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\t\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\t\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\t\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\t\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\t\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\t\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\t\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\t\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\t\n\t\t//# sourceMappingURL=custom-elements.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar settings = window.ShadyDOM || {};\n\t\t\n\t\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\t\n\t\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\t\n\t\tfunction isShadyRoot(obj) {\n\t\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t\t}\n\t\t\n\t\tvar p = Element.prototype;\n\t\tvar matches = p.matches || p.matchesSelector ||\n\t\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tfunction matchesSelector(element, selector) {\n\t\t  return matches.call(element, selector);\n\t\t}\n\t\t\n\t\tfunction copyOwnProperty(name, source, target) {\n\t\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t\t  if (pd) {\n\t\t    Object.defineProperty(target, name, pd);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction extend(target, source) {\n\t\t  if (target && source) {\n\t\t    var n$ = Object.getOwnPropertyNames(source);\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t\t      copyOwnProperty(n, source, target);\n\t\t    }\n\t\t  }\n\t\t  return target || source;\n\t\t}\n\t\t\n\t\tfunction extendAll(target) {\n\t\t  var sources = [], len = arguments.length - 1;\n\t\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\t\n\t\t  for (var i=0; i < sources.length; i++) {\n\t\t    extend(target, sources[i]);\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tfunction mixin(target, source) {\n\t\t  for (var i in source) {\n\t\t    target[i] = source[i];\n\t\t  }\n\t\t  return target;\n\t\t}\n\t\t\n\t\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t\t  obj.__proto__ = proto;\n\t\t  return obj;\n\t\t}\n\t\t\n\t\tfunction patchPrototype(obj, mixin) {\n\t\t  var proto = Object.getPrototypeOf(obj);\n\t\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t\t    var patchProto = Object.create(proto);\n\t\t    patchProto.__sourceProto = proto;\n\t\t    extend(patchProto, mixin);\n\t\t    proto.__patchProto = patchProto;\n\t\t  }\n\t\t  setPrototypeOf(obj, proto.__patchProto);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvar common = {};\n\t\t\n\t\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\t\tvar promish;\n\t\tif (window.Promise) {\n\t\t  promish = Promise.resolve();\n\t\t} else {\n\t\t  promish = {\n\t\t    then: function(cb) {\n\t\t      var twiddle = document.createTextNode('');\n\t\t      var observer = new MutationObserver(function() {\n\t\t        observer.disconnect();\n\t\t        cb();\n\t\t      });\n\t\t      observer.observe(twiddle, {characterData: true});\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction newSplice(index, removed, addedCount) {\n\t\t  return {\n\t\t    index: index,\n\t\t    removed: removed,\n\t\t    addedCount: addedCount\n\t\t  };\n\t\t}\n\t\t\n\t\tvar EDIT_LEAVE = 0;\n\t\tvar EDIT_UPDATE = 1;\n\t\tvar EDIT_ADD = 2;\n\t\tvar EDIT_DELETE = 3;\n\t\t\n\t\tvar ArraySplice = {\n\t\t\n\t\t  // Note: This function is *based* on the computation of the Levenshtein\n\t\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t\t  // edits - not one. With Array splices, an update is really a delete\n\t\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t\t  // maximum array items in the original array. For example:\n\t\t  //\n\t\t  //   'xxxx123' -> '123yyyy'\n\t\t  //\n\t\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t\t  // leaves the substring '123' intact.\n\t\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t\t                              old, oldStart, oldEnd) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // \"Deletion\" columns\n\t\t    var rowCount = oldEnd - oldStart + 1;\n\t\t    var columnCount = currentEnd - currentStart + 1;\n\t\t    var distances = new Array(rowCount);\n\t\t\n\t\t    // \"Addition\" rows. Initialize null column.\n\t\t    for (var i = 0; i < rowCount; i++) {\n\t\t      distances[i] = new Array(columnCount);\n\t\t      distances[i][0] = i;\n\t\t    }\n\t\t\n\t\t    // Initialize null row\n\t\t    for (var j = 0; j < columnCount; j++)\n\t\t      distances[0][j] = j;\n\t\t\n\t\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t\t        else {\n\t\t          var north = distances[i$1 - 1][j$1] + 1;\n\t\t          var west = distances[i$1][j$1 - 1] + 1;\n\t\t          distances[i$1][j$1] = north < west ? north : west;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t\n\t\t    return distances;\n\t\t  },\n\t\t\n\t\t  // This starts at the final weight, and walks \"backward\" by finding\n\t\t  // the minimum previous weight recursively until the origin of the weight\n\t\t  // matrix.\n\t\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t\t    var i = distances.length - 1;\n\t\t    var j = distances[0].length - 1;\n\t\t    var current = distances[i][j];\n\t\t    var edits = [];\n\t\t    while (i > 0 || j > 0) {\n\t\t      if (i == 0) {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        continue;\n\t\t      }\n\t\t      if (j == 0) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        continue;\n\t\t      }\n\t\t      var northWest = distances[i - 1][j - 1];\n\t\t      var west = distances[i - 1][j];\n\t\t      var north = distances[i][j - 1];\n\t\t\n\t\t      var min;\n\t\t      if (west < north)\n\t\t        min = west < northWest ? west : northWest;\n\t\t      else\n\t\t        min = north < northWest ? north : northWest;\n\t\t\n\t\t      if (min == northWest) {\n\t\t        if (northWest == current) {\n\t\t          edits.push(EDIT_LEAVE);\n\t\t        } else {\n\t\t          edits.push(EDIT_UPDATE);\n\t\t          current = northWest;\n\t\t        }\n\t\t        i--;\n\t\t        j--;\n\t\t      } else if (min == west) {\n\t\t        edits.push(EDIT_DELETE);\n\t\t        i--;\n\t\t        current = west;\n\t\t      } else {\n\t\t        edits.push(EDIT_ADD);\n\t\t        j--;\n\t\t        current = north;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    edits.reverse();\n\t\t    return edits;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t   * Splice Projection functions:\n\t\t   *\n\t\t   * A splice map is a representation of how a previous array of items\n\t\t   * was transformed into a new array of items. Conceptually it is a list of\n\t\t   * tuples of\n\t\t   *\n\t\t   *   <index, removed, addedCount>\n\t\t   *\n\t\t   * which are kept in ascending index order of. The tuple represents that at\n\t\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t\t   * from |index|, |addedCount| items were added.\n\t\t   */\n\t\t\n\t\t  /**\n\t\t   * Lacking individual splice mutation information, the minimal set of\n\t\t   * splices can be synthesized given the previous state and final state of an\n\t\t   * array. The basic approach is to calculate the edit distance matrix and\n\t\t   * choose the shortest path through it.\n\t\t   *\n\t\t   * Complexity: O(l * p)\n\t\t   *   l: The length of the current array\n\t\t   *   p: The length of the old array\n\t\t   */\n\t\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t\t                        old, oldStart, oldEnd) {\n\t\t    var prefixCount = 0;\n\t\t    var suffixCount = 0;\n\t\t    var splice;\n\t\t\n\t\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t\t    if (currentStart == 0 && oldStart == 0)\n\t\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\t\n\t\t    if (currentEnd == current.length && oldEnd == old.length)\n\t\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\t\n\t\t    currentStart += prefixCount;\n\t\t    oldStart += prefixCount;\n\t\t    currentEnd -= suffixCount;\n\t\t    oldEnd -= suffixCount;\n\t\t\n\t\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t\t      return [];\n\t\t\n\t\t    if (currentStart == currentEnd) {\n\t\t      splice = newSplice(currentStart, [], 0);\n\t\t      while (oldStart < oldEnd)\n\t\t        splice.removed.push(old[oldStart++]);\n\t\t\n\t\t      return [ splice ];\n\t\t    } else if (oldStart == oldEnd)\n\t\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\t\n\t\t    var ops = this.spliceOperationsFromEditDistances(\n\t\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t\t                               old, oldStart, oldEnd));\n\t\t\n\t\t    splice = undefined;\n\t\t    var splices = [];\n\t\t    var index = currentStart;\n\t\t    var oldIndex = oldStart;\n\t\t    for (var i = 0; i < ops.length; i++) {\n\t\t      switch(ops[i]) {\n\t\t        case EDIT_LEAVE:\n\t\t          if (splice) {\n\t\t            splices.push(splice);\n\t\t            splice = undefined;\n\t\t          }\n\t\t\n\t\t          index++;\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_UPDATE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t        case EDIT_ADD:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.addedCount++;\n\t\t          index++;\n\t\t          break;\n\t\t        case EDIT_DELETE:\n\t\t          if (!splice)\n\t\t            splice = newSplice(index, [], 0);\n\t\t\n\t\t          splice.removed.push(old[oldIndex]);\n\t\t          oldIndex++;\n\t\t          break;\n\t\t      }\n\t\t    }\n\t\t\n\t\t    if (splice) {\n\t\t      splices.push(splice);\n\t\t    }\n\t\t    return splices;\n\t\t  },\n\t\t\n\t\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i = 0; i < searchLength; i++)\n\t\t      if (!this$1.equals(current[i], old[i]))\n\t\t        return i;\n\t\t    return searchLength;\n\t\t  },\n\t\t\n\t\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t\t    var index1 = current.length;\n\t\t    var index2 = old.length;\n\t\t    var count = 0;\n\t\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t\t      count++;\n\t\t\n\t\t    return count;\n\t\t  },\n\t\t\n\t\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t\t                            previous.length);\n\t\t  },\n\t\t\n\t\t  equals: function equals(currentValue, previousValue) {\n\t\t    return currentValue === previousValue;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t\t// for now this is stuck on `utils`\n\t\t//import {patchNode} from './patch'\n\t\t// native add/remove\n\t\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\t\tvar nativeAppendChild = Element.prototype.appendChild;\n\t\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\t\n\t\t/**\n\t\t * `tree` is a dom manipulation library used by ShadyDom to\n\t\t * manipulate composed and logical trees.\n\t\t */\n\t\tvar tree = {\n\t\t\n\t\t  // sad but faster than slice...\n\t\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t\t    var copy=[], i=0;\n\t\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t\t      copy[i++] = n;\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  arrayCopy: function arrayCopy(a$) {\n\t\t    var l = a$.length;\n\t\t    var copy = new Array(l);\n\t\t    for (var i=0; i < l; i++) {\n\t\t      copy[i] = a$[i];\n\t\t    }\n\t\t    return copy;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes(node) {\n\t\t    tree.Logical.saveChildNodes(node);\n\t\t    if (!tree.Composed.hasParentNode(node)) {\n\t\t      tree.Composed.saveComposedData(node);\n\t\t      //tree.Composed.saveParentNode(node);\n\t\t    }\n\t\t    tree.Composed.saveChildNodes(node);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\ttree.Logical = {\n\t\t\n\t\t  hasParentNode: function hasParentNode(node) {\n\t\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes(node) {\n\t\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes(node) {\n\t\t    // note: we're distinguishing here between undefined and false-y:\n\t\t    // hasChildNodes uses undefined check to see if this element has logical\n\t\t    // children; the false-y check indicates whether or not we should rebuild\n\t\t    // the cached childNodes array.\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      tree.Composed.getChildNodes(node);\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes(node) {\n\t\t    if (!node.__dom.childNodes) {\n\t\t      node.__dom.childNodes = [];\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        node.__dom.childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.childNodes;\n\t\t  },\n\t\t\n\t\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t\t  // element will store firstChild/lastChild, and in case (2), the element\n\t\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t\t  // the mere existence of __dom is not enough to know if the requested\n\t\t  // logical data is available and instead we do an explicit undefined check.\n\t\t  getParentNode: function getParentNode(node) {\n\t\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild(node) {\n\t\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t\t      this._getFirstElementChild(node) :\n\t\t      tree.Composed.getFirstElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t\t    var n = node.__dom.firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild(node) {\n\t\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t\t      this._getLastElementChild(node) :\n\t\t      tree.Composed.getLastElementChild(node);\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild(node) {\n\t\t    var n = node.__dom.lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling(node) {\n\t\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t\t      this._getNextElementSibling(node) :\n\t\t      tree.Composed.getNextElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t\t      this._getPreviousElementSibling(node) :\n\t\t      tree.Composed.getPreviousElementSibling(node);\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  // Capture the list of light children. It's important to do this before we\n\t\t  // start transforming the DOM into \"rendered\" state.\n\t\t  // Children may be added to this list dynamically. It will be treated as the\n\t\t  // source of truth for the light children of the element. This element's\n\t\t  // actual children will be treated as the rendered state once this function\n\t\t  // has been called.\n\t\t  saveChildNodes: function saveChildNodes$1(node) {\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.firstChild;\n\t\t      node.__dom.lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        n.__dom = n.__dom || {};\n\t\t        n.__dom.parentNode = node;\n\t\t        n.__dom.nextSibling = c$[i+1] || null;\n\t\t        n.__dom.previousSibling = c$[i-1] || null;\n\t\t        common.patchNode(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t\t  // already been distributed.\n\t\t  // NOTE: ensure `node` is patched...\n\t\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var c$ = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1._linkNode(c$[i], container, ref_node);\n\t\t      }\n\t\t      // cleanup logical dom in doc fragment.\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t\t      node.__dom.childNodes = null;\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t\t    common.patchNode(node);\n\t\t    ref_node = ref_node || null;\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t\t      container.__dom.lastChild;\n\t\t    if (node.__dom.previousSibling) {\n\t\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.nextSibling = ref_node;\n\t\t    if (node.__dom.nextSibling) {\n\t\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.lastChild = node;\n\t\t      if (!container.__dom.firstChild) {\n\t\t        container.__dom.firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.firstChild) {\n\t\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.lastChild) {\n\t\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.previousSibling;\n\t\t    var n = node.__dom.nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.previousSibling = p;\n\t\t    }\n\t\t    // When an element is removed, logical data is no longer tracked.\n\t\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t\t    // from `null` which is set if info is null.\n\t\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t\t      node.__dom.nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.childNodes = null;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t// TODO(sorvell): composed tree manipulation is made available\n\t\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t\t// to the tree for optional patching pluggability.\n\t\ttree.Composed = {\n\t\t\n\t\t  hasParentNode: function hasParentNode$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t\t  },\n\t\t\n\t\t  hasChildNodes: function hasChildNodes$1(node) {\n\t\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t\t  },\n\t\t\n\t\t  getChildNodes: function getChildNodes$1(node) {\n\t\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t\t  },\n\t\t\n\t\t  _getChildNodes: function _getChildNodes$1(node) {\n\t\t    if (!node.__dom.$childNodes) {\n\t\t      node.__dom.$childNodes = [];\n\t\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t\t        node.__dom.$childNodes.push(n);\n\t\t      }\n\t\t    }\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t\t    return node.__dom.$childNodes;\n\t\t  },\n\t\t\n\t\t  getParentNode: function getParentNode$1(node) {\n\t\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t\t      (!node.__patched && node.parentNode);\n\t\t  },\n\t\t\n\t\t  getFirstChild: function getFirstChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t\t  },\n\t\t\n\t\t  getLastChild: function getLastChild$1(node) {\n\t\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t\t  },\n\t\t\n\t\t  getNextSibling: function getNextSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t\t  },\n\t\t\n\t\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t\t  },\n\t\t\n\t\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t\t    return node.__patched ? this._getFirstElementChild(node) :\n\t\t      node.firstElementChild;\n\t\t  },\n\t\t\n\t\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t\t    var n = node.__dom.$firstChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$nextSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getLastElementChild: function getLastElementChild$1(node) {\n\t\t    return node.__patched ? this._getLastElementChild(node) :\n\t\t      node.lastElementChild;\n\t\t  },\n\t\t\n\t\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t\t    var n = node.__dom.$lastChild;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = n.__dom.$previousSibling;\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t\t    return node.__patched ? this._getNextElementSibling(node) :\n\t\t      node.nextElementSibling;\n\t\t  },\n\t\t\n\t\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getNextSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t\t      node.previousElementSibling;\n\t\t  },\n\t\t\n\t\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n = node.__dom.$previousSibling;\n\t\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t\t      n = this$1.getPreviousSibling(n);\n\t\t    }\n\t\t    return n;\n\t\t  },\n\t\t\n\t\t  saveChildNodes: function saveChildNodes$2(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    if (!this.hasChildNodes(node)) {\n\t\t      node.__dom = node.__dom || {};\n\t\t      node.__dom.$firstChild = node.firstChild;\n\t\t      node.__dom.$lastChild = node.lastChild;\n\t\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        this$1.saveComposedData(n);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveComposedData: function saveComposedData(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    if (node.__dom.$parentNode === undefined) {\n\t\t      node.__dom.$parentNode = node.parentNode;\n\t\t    }\n\t\t    if (node.__dom.$nextSibling === undefined) {\n\t\t      node.__dom.$nextSibling = node.nextSibling;\n\t\t    }\n\t\t    if (node.__dom.$previousSibling === undefined) {\n\t\t      node.__dom.$previousSibling = node.previousSibling;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    container.__dom.$childNodes = null;\n\t\t    // handle document fragments\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      // TODO(sorvell): remember this for patching:\n\t\t      // the act of setting this info can affect patched nodes\n\t\t      // getters; therefore capture childNodes before patching.\n\t\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t\t        this$1._linkNode(n, container, ref_node);\n\t\t      }\n\t\t    } else {\n\t\t      this._linkNode(node, container, ref_node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (ref_node) {\n\t\t      ref_node.__dom = ref_node.__dom || {};\n\t\t    }\n\t\t    // update ref_node.previousSibling <-> node\n\t\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t\t      container.__dom.$lastChild;\n\t\t    if (node.__dom.$previousSibling) {\n\t\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t\t    }\n\t\t    // update node <-> ref_node\n\t\t    node.__dom.$nextSibling = ref_node;\n\t\t    if (node.__dom.$nextSibling) {\n\t\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t\t    }\n\t\t    // update node <-> container\n\t\t    node.__dom.$parentNode = container;\n\t\t    if (ref_node) {\n\t\t      if (ref_node === container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    } else {\n\t\t      container.__dom.$lastChild = node;\n\t\t      if (!container.__dom.$firstChild) {\n\t\t        container.__dom.$firstChild = node;\n\t\t      }\n\t\t    }\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    container.__dom = container.__dom || {};\n\t\t    if (node === container.__dom.$firstChild) {\n\t\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t\t    }\n\t\t    if (node === container.__dom.$lastChild) {\n\t\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t\t    }\n\t\t    var p = node.__dom.$previousSibling;\n\t\t    var n = node.__dom.$nextSibling;\n\t\t    if (p) {\n\t\t      p.__dom = p.__dom || {};\n\t\t      p.__dom.$nextSibling = n;\n\t\t    }\n\t\t    if (n) {\n\t\t      n.__dom = n.__dom || {};\n\t\t      n.__dom.$previousSibling = p;\n\t\t    }\n\t\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t\t      node.__dom.$nextSibling = null;\n\t\t    // remove caching of childNodes\n\t\t    container.__dom.$childNodes = null;\n\t\t  },\n\t\t\n\t\t  clearChildNodes: function clearChildNodes(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = this.getChildNodes(node);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      this$1.recordRemoveChild(c, node);\n\t\t      nativeRemoveChild.call(node, c)\n\t\t    }\n\t\t  },\n\t\t\n\t\t  saveParentNode: function saveParentNode(node) {\n\t\t    node.__dom = node.__dom || {};\n\t\t    node.__dom.$parentNode = node.parentNode;\n\t\t  },\n\t\t\n\t\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    // remove from current location.\n\t\t    this._addChild(parentNode, newChild, refChild);\n\t\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t\t  },\n\t\t\n\t\t  appendChild: function appendChild(parentNode, newChild) {\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._addChild(parentNode, newChild);\n\t\t    return nativeAppendChild.call(parentNode, newChild);\n\t\t  },\n\t\t\n\t\t  removeChild: function removeChild(parentNode, node) {\n\t\t    var currentParent = this.getParentNode(node);\n\t\t    this.saveChildNodes(parentNode);\n\t\t    this._removeChild(parentNode, node);\n\t\t    if (currentParent === parentNode) {\n\t\t      return nativeRemoveChild.call(parentNode, node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var oldParent = this.getParentNode(newChild);\n\t\t    if (oldParent) {\n\t\t      this._removeChild(oldParent, newChild);\n\t\t    }\n\t\t    if (isFrag) {\n\t\t      var c$ = this.getChildNodes(newChild);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        var c = c$[i];\n\t\t        // unlink document fragment children\n\t\t        this$1._removeChild(newChild, c);\n\t\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t\t      }\n\t\t    } else {\n\t\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeChild: function _removeChild(parentNode, node) {\n\t\t    this.recordRemoveChild(node, parentNode);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\t// for testing...\n\t\tvar descriptors = {};\n\t\tfunction getNativeProperty(element, property) {\n\t\t  if (!descriptors[property]) {\n\t\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t\t      HTMLElement.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Element.prototype, property) ||\n\t\t    Object.getOwnPropertyDescriptor(\n\t\t      Node.prototype, property);\n\t\t  }\n\t\t  return descriptors[property].get.call(element);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// NOTE: normalize event contruction where necessary (IE11)\n\t\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t\t  function(inType, params) {\n\t\t    params = params || {};\n\t\t    var e = document.createEvent('Event');\n\t\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t\t    return e;\n\t\t  };\n\t\t\n\t\tvar Distributor = (function () {\n\t\t  function anonymous(root) {\n\t\t    this.root = root;\n\t\t    this.insertionPointTag = 'slot';\n\t\t  }\n\t\t\n\t\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t\t    return Boolean(this.root._insertionPoints &&\n\t\t      this.root._insertionPoints.length);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t\t    return node.localName && node.localName == this.insertionPointTag;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distribute = function distribute () {\n\t\t    if (this.hasInsertionPoint()) {\n\t\t      return this.distributePool(this.root, this.collectPool());\n\t\t    }\n\t\t    return [];\n\t\t  };\n\t\t\n\t\t  // Gather the pool of nodes that should be distributed. We will combine\n\t\t  // these with the \"content root\" to arrive at the composed tree.\n\t\t  anonymous.prototype.collectPool = function collectPool () {\n\t\t    return tree.arrayCopy(\n\t\t      tree.Logical.getChildNodes(this.root.host));\n\t\t  };\n\t\t\n\t\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t\t  // instead elements are distributed into storage\n\t\t  // array where applicable.\n\t\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var dirtyRoots = [];\n\t\t    var p$ = this.root._insertionPoints;\n\t\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t\t      this$1.distributeInsertionPoint(p, pool);\n\t\t      // provoke redistribution on insertion point parents\n\t\t      // must do this on all candidate hosts since distribution in this\n\t\t      // scope invalidates their distribution.\n\t\t      // only get logical parent.\n\t\t      var parent = tree.Logical.getParentNode(p);\n\t\t      if (parent && parent.shadyRoot &&\n\t\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t\t        dirtyRoots.push(parent.shadyRoot);\n\t\t      }\n\t\t    }\n\t\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t\t      var p$1 = pool[i$1];\n\t\t      if (p$1) {\n\t\t        p$1._assignedSlot = undefined;\n\t\t        // remove undistributed elements from physical dom.\n\t\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t\t        if (parent$1) {\n\t\t          tree.Composed.removeChild(parent$1, p$1);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return dirtyRoots;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t\t    if (prevAssignedNodes) {\n\t\t      this.clearAssignedSlots(insertionPoint, true);\n\t\t    }\n\t\t    insertionPoint._assignedNodes = [];\n\t\t    var needsSlotChange = false;\n\t\t    // distribute nodes from the pool that this selector matches\n\t\t    var anyDistributed = false;\n\t\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t\t      node=pool[i];\n\t\t      // skip nodes that were already used\n\t\t      if (!node) {\n\t\t        continue;\n\t\t      }\n\t\t      // distribute this node if it matches\n\t\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node, insertionPoint)\n\t\t        // remove this node from the pool\n\t\t        pool[i] = undefined;\n\t\t        // since at least one node matched, we won't need fallback content\n\t\t        anyDistributed = true;\n\t\t      }\n\t\t    }\n\t\t    // Fallback content if nothing was distributed here\n\t\t    if (!anyDistributed) {\n\t\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t\t      for (var j = 0, node$1; j < children.length; j++) {\n\t\t        node$1 = children[j];\n\t\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t\t          needsSlotChange = true;\n\t\t        }\n\t\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t\t      }\n\t\t    }\n\t\t    // we're already dirty if a node was newly added to the slot\n\t\t    // and we're also dirty if the assigned count decreased.\n\t\t    if (prevAssignedNodes) {\n\t\t      // TODO(sorvell): the tracking of previously assigned slots\n\t\t      // could instead by done with a Set and then we could\n\t\t      // avoid needing to iterate here to clear the info.\n\t\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t\t      }\n\t\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t\t        needsSlotChange = true;\n\t\t      }\n\t\t    }\n\t\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t\t    if (needsSlotChange) {\n\t\t      this._fireSlotChange(insertionPoint);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t\t    var n$ = slot._assignedNodes;\n\t\t    if (n$) {\n\t\t      for (var i=0; i < n$.length; i++) {\n\t\t        var n = n$[i];\n\t\t        if (savePrevious) {\n\t\t          n.__prevAssignedSlot = n._assignedSlot;\n\t\t        }\n\t\t        // only clear if it was previously set to this slot;\n\t\t        // this helps ensure that if the node has otherwise been distributed\n\t\t        // ignore it.\n\t\t        if (n._assignedSlot === slot) {\n\t\t          n._assignedSlot = null;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t\t    var slotName = insertionPoint.getAttribute('name');\n\t\t    slotName = slotName ? slotName.trim() : '';\n\t\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t\t    slot = slot ? slot.trim() : '';\n\t\t    return (slot == slotName);\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t\t    insertionPoint._assignedNodes.push(child);\n\t\t    child._assignedSlot = insertionPoint;\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var n$ = insertionPoint._assignedNodes;\n\t\t    insertionPoint._distributedNodes = [];\n\t\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t\t      if (this$1.isInsertionPoint(n)) {\n\t\t        var d$ = n._distributedNodes;\n\t\t        if (d$) {\n\t\t          for (var j=0; j < d$.length; j++) {\n\t\t            insertionPoint._distributedNodes.push(d$[j]);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        insertionPoint._distributedNodes.push(n$[i]);\n\t\t      }\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t\t    // Safari tech preview does not bubble but chrome does\n\t\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t\t    if (insertionPoint._assignedSlot) {\n\t\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t\t    }\n\t\t  };\n\t\t\n\t\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t\t    return !(insertionPoint._assignedSlot);\n\t\t  };\n\t\t\n\t\t  return anonymous;\n\t\t}())\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t\t  polyfill across browsers.\n\t\t*/\n\t\tvar ShadyRoot = function ShadyRoot(host) {\n\t\t  if (!host) {\n\t\t    throw 'Must provide a host';\n\t\t  }\n\t\t  // NOTE: this strange construction is necessary because\n\t\t  // DocumentFragment cannot be subclassed on older browsers.\n\t\t  var frag = document.createDocumentFragment();\n\t\t  frag.__proto__ = ShadyFragmentMixin;\n\t\t  frag._init(host);\n\t\t  return frag;\n\t\t};\n\t\t\n\t\tvar ShadyMixin = {\n\t\t\n\t\t  _init: function _init(host) {\n\t\t    // NOTE: set a fake local name so this element can be\n\t\t    // distinguished from a DocumentFragment when patching.\n\t\t    // FF doesn't allow this to be `localName`\n\t\t    this.__localName = 'ShadyRoot';\n\t\t    // root <=> host\n\t\t    host.shadyRoot = this;\n\t\t    this.host = host;\n\t\t    // logical dom setup\n\t\t    tree.Logical.saveChildNodes(host);\n\t\t    tree.Logical.saveChildNodes(this);\n\t\t    // state flags\n\t\t    this._clean = true;\n\t\t    this._hasRendered = false;\n\t\t    this._distributor = new Distributor(this);\n\t\t    this.update();\n\t\t  },\n\t\t\n\t\t  // async render the \"top\" distributor (this is all that is needed to\n\t\t  // distribute this host).\n\t\t  update: function update() {\n\t\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t\t    if (distributionRoot._clean) {\n\t\t      distributionRoot._clean = false;\n\t\t      enqueue(function() {\n\t\t        distributionRoot.render();\n\t\t      });\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t\t  // this should only return a shadowRoot.\n\t\t  // returns the host that's the top of this host's distribution tree\n\t\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t\t    var root = element.shadyRoot;\n\t\t    while (element && this._elementNeedsDistribution(element)) {\n\t\t      root = element.getRootNode();\n\t\t      element = root && root.host;\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  // Return true if a host's children includes\n\t\t  // an insertion point that selects selectively\n\t\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var c$ = tree.Logical.getChildNodes(element);\n\t\t    for (var i=0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t\t        return element.getRootNode();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  render: function render() {\n\t\t    if (!this._clean) {\n\t\t      this._clean = true;\n\t\t      if (!this._skipUpdateInsertionPoints) {\n\t\t        this.updateInsertionPoints();\n\t\t      } else if (!this._hasRendered) {\n\t\t        this._insertionPoints = [];\n\t\t      }\n\t\t      this._skipUpdateInsertionPoints = false;\n\t\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t\t      // that would avoid distribution for initial render if\n\t\t      // no insertion points exist. We cannot currently do this because\n\t\t      // it relies on elements being in the physical shadowRoot element\n\t\t      // so that native methods will be used. The current append code\n\t\t      // simply provokes distribution in this case and does not put the\n\t\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t\t      // consider if the special processing is worth the perf gain.\n\t\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t\t      //   tree.Composed.clearChildNodes(this.host);\n\t\t      //   tree.Composed.appendChild(this.host, this);\n\t\t      // } else {\n\t\t      // logical\n\t\t      this.distribute();\n\t\t      // physical\n\t\t      this.compose();\n\t\t      this._hasRendered = true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  forceRender: function forceRender() {\n\t\t    this._clean = false;\n\t\t    this.render();\n\t\t  },\n\t\t\n\t\t  distribute: function distribute() {\n\t\t    var dirtyRoots = this._distributor.distribute();\n\t\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t\t      dirtyRoots[i].forceRender();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  updateInsertionPoints: function updateInsertionPoints() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var i$ = this.__insertionPoints;\n\t\t    // if any insertion points have been removed, clear their distribution info\n\t\t    if (i$) {\n\t\t      for (var i=0, c; i < i$.length; i++) {\n\t\t        c = i$[i];\n\t\t        if (c.getRootNode() !== this$1) {\n\t\t          this$1._distributor.clearAssignedSlots(c);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t\t    // ensure insertionPoints's and their parents have logical dom info.\n\t\t    // save logical tree info\n\t\t    // a. for shadyRoot\n\t\t    // b. for insertion points (fallback)\n\t\t    // c. for parents of insertion points\n\t\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t\t      c$1 = i$[i$1];\n\t\t      tree.Logical.saveChildNodes(c$1);\n\t\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  get _insertionPoints() {\n\t\t    if (!this.__insertionPoints) {\n\t\t      this.updateInsertionPoints();\n\t\t    }\n\t\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t\t  },\n\t\t\n\t\t  set _insertionPoints(insertionPoints) {\n\t\t    this.__insertionPoints = insertionPoints;\n\t\t  },\n\t\t\n\t\t  hasInsertionPoint: function hasInsertionPoint() {\n\t\t    return this._distributor.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  compose: function compose() {\n\t\t    // compose self\n\t\t    // note: it's important to mark this clean before distribution\n\t\t    // so that attachment that provokes additional distribution (e.g.\n\t\t    // adding something to your parentNode) works\n\t\t    this._composeTree();\n\t\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t\t    // (these seem unnecessary)\n\t\t  },\n\t\t\n\t\t  // Reify dom such that it is at its correct rendering position\n\t\t  // based on logical distribution.\n\t\t  _composeTree: function _composeTree() {\n\t\t    var this$1 = this;\n\t\t\n\t\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t\t    var p$ = this._insertionPoints || [];\n\t\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t\t      parent = tree.Logical.getParentNode(p);\n\t\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // Returns the list of nodes which should be rendered inside `node`.\n\t\t  _composeNode: function _composeNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var children = [];\n\t\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t\t    for (var i = 0; i < c$.length; i++) {\n\t\t      var child = c$[i];\n\t\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t\t        var distributedNodes = child._distributedNodes ||\n\t\t          (child._distributedNodes = []);\n\t\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t\t          var distributedNode = distributedNodes[j];\n\t\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t\t            children.push(distributedNode);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        children.push(child);\n\t\t      }\n\t\t    }\n\t\t    return children;\n\t\t  },\n\t\t\n\t\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t\t    return this._distributor.isFinalDestination(\n\t\t      insertionPoint, node);\n\t\t  },\n\t\t\n\t\t  // Ensures that the rendered node list inside `container` is `children`.\n\t\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t\t    var composed = tree.Composed.getChildNodes(container);\n\t\t    var splices = calculateSplices(children, composed);\n\t\t    // process removals\n\t\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t\t        // check if the node is still where we expect it is before trying\n\t\t        // to remove it; this can happen if we move a node and\n\t\t        // then schedule its previous host for distribution resulting in\n\t\t        // the node being removed here.\n\t\t        if (tree.Composed.getParentNode(n) === container) {\n\t\t          tree.Composed.removeChild(container, n);\n\t\t        }\n\t\t        composed.splice(s.index + d, 1);\n\t\t      }\n\t\t      d -= s.addedCount;\n\t\t    }\n\t\t    // process adds\n\t\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t\t      next = composed[s$1.index];\n\t\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t\t        n$1 = children[j$1];\n\t\t        tree.Composed.insertBefore(container, n$1, next);\n\t\t        // TODO(sorvell): is this splice strictly needed?\n\t\t        composed.splice(j$1, 0, n$1);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  getInsertionPointTag: function getInsertionPointTag() {\n\t\t    return this._distributor.insertionPointTag;\n\t\t  }\n\t\t\n\t\t}\n\t\t\n\t\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\t\textend(ShadyFragmentMixin, ShadyMixin);\n\t\t\n\t\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\t\n\t\t// function upgradeLogicalChildren(children) {\n\t\t//   if (needsUpgrade && children) {\n\t\t//     for (let i=0; i < children.length; i++) {\n\t\t//       CustomElements.upgrade(children[i]);\n\t\t//     }\n\t\t//   }\n\t\t// }\n\t\t\n\t\t// render enqueuer/flusher\n\t\tvar customElements = window.customElements;\n\t\tvar flushList = [];\n\t\tvar scheduled;\n\t\tvar flushCount = 0;\n\t\tvar flushMax = 100;\n\t\tfunction enqueue(callback) {\n\t\t  if (!scheduled) {\n\t\t    scheduled = true;\n\t\t    promish.then(flush$1);\n\t\t  }\n\t\t  flushList.push(callback);\n\t\t}\n\t\t\n\t\tfunction flush$1() {\n\t\t  scheduled = false;\n\t\t  flushCount++;\n\t\t  while (flushList.length) {\n\t\t    flushList.shift()();\n\t\t  }\n\t\t  if (customElements && customElements.flush) {\n\t\t    customElements.flush();\n\t\t  }\n\t\t  // continue flushing after elements are upgraded...\n\t\t  var isFlushedMaxed = (flushCount > flushMax);\n\t\t  if (flushList.length && !isFlushedMaxed) {\n\t\t      flush$1();\n\t\t  }\n\t\t  flushCount = 0;\n\t\t  if (isFlushedMaxed) {\n\t\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t\t  }\n\t\t}\n\t\t\n\t\tflush$1.list = flushList;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// Cribbed from ShadowDOM polyfill\n\t\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t\t/////////////////////////////////////////////////////////////////////////////\n\t\t// innerHTML and outerHTML\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\t\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\t\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\t\n\t\tfunction escapeReplace(c) {\n\t\t  switch (c) {\n\t\t    case '&':\n\t\t      return '&amp;';\n\t\t    case '<':\n\t\t      return '&lt;';\n\t\t    case '>':\n\t\t      return '&gt;';\n\t\t    case '\"':\n\t\t      return '&quot;';\n\t\t    case '\\u00A0':\n\t\t      return '&nbsp;';\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction escapeAttr(s) {\n\t\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction escapeData(s) {\n\t\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t\t}\n\t\t\n\t\tfunction makeSet(arr) {\n\t\t  var set = {};\n\t\t  for (var i = 0; i < arr.length; i++) {\n\t\t    set[arr[i]] = true;\n\t\t  }\n\t\t  return set;\n\t\t}\n\t\t\n\t\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\t\tvar voidElements = makeSet([\n\t\t  'area',\n\t\t  'base',\n\t\t  'br',\n\t\t  'col',\n\t\t  'command',\n\t\t  'embed',\n\t\t  'hr',\n\t\t  'img',\n\t\t  'input',\n\t\t  'keygen',\n\t\t  'link',\n\t\t  'meta',\n\t\t  'param',\n\t\t  'source',\n\t\t  'track',\n\t\t  'wbr'\n\t\t]);\n\t\t\n\t\tvar plaintextParents = makeSet([\n\t\t  'style',\n\t\t  'script',\n\t\t  'xmp',\n\t\t  'iframe',\n\t\t  'noembed',\n\t\t  'noframes',\n\t\t  'plaintext',\n\t\t  'noscript'\n\t\t]);\n\t\t\n\t\tfunction getOuterHTML(node, parentNode, composed) {\n\t\t  switch (node.nodeType) {\n\t\t    case Node.ELEMENT_NODE: {\n\t\t      var tagName = node.localName;\n\t\t      var s = '<' + tagName;\n\t\t      var attrs = node.attributes;\n\t\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t\t      }\n\t\t      s += '>';\n\t\t      if (voidElements[tagName]) {\n\t\t        return s;\n\t\t      }\n\t\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t\t    }\n\t\t    case Node.TEXT_NODE: {\n\t\t      var data = node.data;\n\t\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t\t        return data;\n\t\t      }\n\t\t      return escapeData(data);\n\t\t    }\n\t\t    case Node.COMMENT_NODE: {\n\t\t      return '<!--' + node.data + '-->';\n\t\t    }\n\t\t    default: {\n\t\t      window.console.error(node);\n\t\t      throw new Error('not implemented');\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction getInnerHTML(node, composed) {\n\t\t  if (node.localName === 'template') {\n\t\t    node = node.content;\n\t\t  }\n\t\t  var s = '';\n\t\t  var c$ = composed ? composed(node) : node.childNodes;\n\t\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t\t    s += getOuterHTML(child, node, composed);\n\t\t  }\n\t\t  return s;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar mixinImpl = {\n\t\t\n\t\t  // Try to add node. Record logical info, track insertion points, perform\n\t\t  // distribution iff needed. Return true if the add is handled.\n\t\t  addNode: function addNode(container, node, ref_node) {\n\t\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t\t    if (ownerRoot) {\n\t\t      // optimization: special insertion point tracking\n\t\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t\t      }\n\t\t      // note: we always need to see if an insertion point is added\n\t\t      // since this saves logical tree info; however, invalidation state\n\t\t      // needs\n\t\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t\t      // invalidate insertion points IFF not already invalid!\n\t\t      if (ipAdded) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t      }\n\t\t    }\n\t\t    if (tree.Logical.hasChildNodes(container)) {\n\t\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t\t    }\n\t\t    // if not distributing and not adding to host, do a fast path addition\n\t\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t\t      container.shadyRoot;\n\t\t    return handled;\n\t\t  },\n\t\t\n\t\t  // Try to remove node: update logical info and perform distribution iff\n\t\t  // needed. Return true if the removal has been handled.\n\t\t  // note that it's possible for both the node's host and its parent\n\t\t  // to require distribution... both cases are handled here.\n\t\t  removeNode: function removeNode(node) {\n\t\t    // important that we want to do this only if the node has a logical parent\n\t\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t\t      tree.Logical.getParentNode(node);\n\t\t    var distributed;\n\t\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t\t    if (logicalParent) {\n\t\t      // distribute node's parent iff needed\n\t\t      distributed = this.maybeDistributeParent(node);\n\t\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t\t      // remove node from root and distribute it iff needed\n\t\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    this._removeOwnerShadyRoot(node);\n\t\t    return distributed;\n\t\t  },\n\t\t\n\t\t\n\t\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t\t    var observer = node.__dom && node.__dom.observer;\n\t\t    if (observer) {\n\t\t      if (addedNode) {\n\t\t        observer.addedNodes.push(addedNode);\n\t\t      }\n\t\t      if (removedNode) {\n\t\t        observer.removedNodes.push(removedNode);\n\t\t      }\n\t\t      observer.schedule();\n\t\t    }\n\t\t  },\n\t\t\n\t\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t\t    if (parent) {\n\t\t      this._scheduleObserver(parent, null, node);\n\t\t      this.removeNode(node);\n\t\t    } else {\n\t\t      this._removeOwnerShadyRoot(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t\t  },\n\t\t\n\t\t  getRootNode: function getRootNode$1(node) {\n\t\t    if (!node || !node.nodeType) {\n\t\t      return;\n\t\t    }\n\t\t    var root = node.__ownerShadyRoot;\n\t\t    if (root === undefined) {\n\t\t      if (isShadyRoot(node)) {\n\t\t        root = node;\n\t\t      } else {\n\t\t        var parent = tree.Logical.getParentNode(node);\n\t\t        root = parent ? this.getRootNode(parent) : node;\n\t\t      }\n\t\t      // memo-ize result for performance but only memo-ize\n\t\t      // result if node is in the document. This avoids a problem where a root\n\t\t      // can be cached while an element is inside a fragment.\n\t\t      // If this happens and we cache the result, the value can become stale\n\t\t      // because for perf we avoid processing the subtree of added fragments.\n\t\t      if (document.documentElement.contains(node)) {\n\t\t        node.__ownerShadyRoot = root;\n\t\t      }\n\t\t    }\n\t\t    return root;\n\t\t  },\n\t\t\n\t\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t\t    var root = this.getRootNode(node);\n\t\t    if (isShadyRoot(root)) {\n\t\t      return root;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t\t    // <content> children but since this case is assumed to be exceedingly\n\t\t    // rare, we avoid the cost and will address with some specific api\n\t\t    // when the need arises.  For now, the user must call\n\t\t    // distributeContent(true), which updates insertion points manually\n\t\t    // and forces distribution.\n\t\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t\t      !node.__noInsertionPoint &&\n\t\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t\t    var wrappedContent = fragContent &&\n\t\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t\t    // There are 3 possible cases where a distribution may need to occur:\n\t\t    // 1. <content> being inserted (the host of the shady root where\n\t\t    //    content is inserted needs distribution)\n\t\t    // 2. children being inserted into parent with a shady root (parent\n\t\t    //    needs distribution)\n\t\t    // 3. container is an insertionPoint\n\t\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t\t      if (ownerRoot) {\n\t\t        // note, insertion point list update is handled after node\n\t\t        // mutations are complete\n\t\t        ownerRoot.update();\n\t\t      }\n\t\t    }\n\t\t    var needsDist = this._nodeNeedsDistribution(container);\n\t\t    if (needsDist) {\n\t\t      container.shadyRoot.update();\n\t\t    }\n\t\t    // Return true when distribution will fully handle the composition\n\t\t    // Note that if a content was being inserted that was wrapped by a node,\n\t\t    // and the parent does not need distribution, return false to allow\n\t\t    // the nodes to be added directly, after which children may be\n\t\t    // distributed and composed into the wrapping node(s)\n\t\t    return needsDist || (hasContent && !wrappedContent);\n\t\t  },\n\t\t\n\t\t  /* note: parent argument is required since node may have an out\n\t\t  of date parent at this point; returns true if a <content> is being added */\n\t\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var added;\n\t\t    var insertionPointTag = root.getInsertionPointTag();\n\t\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t\t      !node.__noInsertionPoint) {\n\t\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t\t        np = tree.Logical.getParentNode(n);\n\t\t        // don't allow node's parent to be fragment itself\n\t\t        if (np === node) {\n\t\t          np = parent;\n\t\t        }\n\t\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t\t        added = added || na;\n\t\t      }\n\t\t    } else if (node.localName === insertionPointTag) {\n\t\t      tree.Logical.saveChildNodes(parent);\n\t\t      tree.Logical.saveChildNodes(node);\n\t\t      added = true;\n\t\t    }\n\t\t    return added;\n\t\t  },\n\t\t\n\t\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t\t    return node && node.shadyRoot &&\n\t\t      node.shadyRoot.hasInsertionPoint();\n\t\t  },\n\t\t\n\t\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var hostNeedsDist;\n\t\t    var ip$ = root._insertionPoints;\n\t\t    for (var i=0; i<ip$.length; i++) {\n\t\t      var insertionPoint = ip$[i];\n\t\t      if (this$1._contains(container, insertionPoint)) {\n\t\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t\t        for (var j=0; j<dc$.length; j++) {\n\t\t          hostNeedsDist = true;\n\t\t          var node = dc$[j];\n\t\t          var parent = tree.Composed.getParentNode(node);\n\t\t          if (parent) {\n\t\t            tree.Composed.removeChild(parent, node);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return hostNeedsDist;\n\t\t  },\n\t\t\n\t\t  _contains: function _contains(container, node) {\n\t\t    while (node) {\n\t\t      if (node == container) {\n\t\t        return true;\n\t\t      }\n\t\t      node = tree.Logical.getParentNode(node);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    // optimization: only reset the tree if node is actually in a root\n\t\t    if (this._hasCachedOwnerRoot(node)) {\n\t\t      var c$ = tree.Logical.getChildNodes(node);\n\t\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t\t        this$1._removeOwnerShadyRoot(n);\n\t\t      }\n\t\t    }\n\t\t    node.__ownerShadyRoot = undefined;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): This will fail if distribution that affects this\n\t\t  // question is pending; this is expected to be exceedingly rare, but if\n\t\t  // the issue comes up, we can force a flush in this case.\n\t\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t\t    var root = this.getRootNode(insertionPoint);\n\t\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t\t      // means that we're composed to this spot.\n\t\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t\t        return n;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  clearNode: function clearNode(node) {\n\t\t    while (node.firstChild) {\n\t\t      node.removeChild(node.firstChild);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t\t    var parent = tree.Logical.getParentNode(node);\n\t\t    if (this._nodeNeedsDistribution(parent)) {\n\t\t      parent.shadyRoot.update();\n\t\t      return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t\t    if (name === 'slot') {\n\t\t      this.maybeDistributeParent(node);\n\t\t    } else if (node.localName === 'slot' && name === 'name') {\n\t\t      var root = this.ownerShadyRootForNode(node);\n\t\t      if (root) {\n\t\t        root.update();\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t\t  // but it's also generally useful to recurse through the element tree\n\t\t  // and is used by Polymer's styling system.\n\t\t  query: function query(node, matcher, halter) {\n\t\t    var list = [];\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t    return list;\n\t\t  },\n\t\t\n\t\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t\t          this$1._queryElement(c, matcher, halter, list)) {\n\t\t        return true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t\t    var result = matcher(node);\n\t\t    if (result) {\n\t\t      list.push(node);\n\t\t    }\n\t\t    if (halter && halter(result)) {\n\t\t      return result;\n\t\t    }\n\t\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t\t      halter, list);\n\t\t  },\n\t\t\n\t\t  activeElementForNode: function activeElementForNode(node) {\n\t\t    var this$1 = this;\n\t\t\n\t\t    var active = document.activeElement;\n\t\t    if (!active) {\n\t\t      return null;\n\t\t    }\n\t\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t\t    if (node !== document) {\n\t\t      // If this node isn't a document or shady root, then it doesn't have\n\t\t      // an active element.\n\t\t      if (!isShadyRoot$$1) {\n\t\t        return null;\n\t\t      }\n\t\t      // If this shady root's host is the active element or the active\n\t\t      // element is not a descendant of the host (in the composed tree),\n\t\t      // then it doesn't have an active element.\n\t\t      if (node.host === active ||\n\t\t          !node.host.contains(active)) {\n\t\t        return null;\n\t\t      }\n\t\t    }\n\t\t    // This node is either the document or a shady root of which the active\n\t\t    // element is a (composed) descendant of its host; iterate upwards to\n\t\t    // find the active element's most shallow host within it.\n\t\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t\t    while (activeRoot && activeRoot !== node) {\n\t\t      active = activeRoot.host;\n\t\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t\t    }\n\t\t    if (node === document) {\n\t\t      // This node is the document, so activeRoot should be null.\n\t\t      return activeRoot ? null : active;\n\t\t    } else {\n\t\t      // This node is a non-document shady root, and it should be\n\t\t      // activeRoot.\n\t\t      return activeRoot === node ? active : null;\n\t\t    }\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tvar nativeCloneNode = Element.prototype.cloneNode;\n\t\tvar nativeImportNode = Document.prototype.importNode;\n\t\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\t\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\t\n\t\tvar setAttribute = function(attr, value) {\n\t\t  if (window.ShadyCSS && attr === 'class') {\n\t\t    window.ShadyCSS.setElementClass(this, value);\n\t\t  } else {\n\t\t    nativeSetAttribute.call(this, attr, value);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar NodeMixin = {};\n\t\t\n\t\tObject.defineProperties(NodeMixin, {\n\t\t\n\t\t  parentElement: {\n\t\t    get: function get() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  parentNode: {\n\t\t    get: function get$1() {\n\t\t      return tree.Logical.getParentNode(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextSibling: {\n\t\t    get: function get$2() {\n\t\t      return tree.Logical.getNextSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousSibling: {\n\t\t    get: function get$3() {\n\t\t      return tree.Logical.getPreviousSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  nextElementSibling: {\n\t\t    get: function get$4() {\n\t\t      return tree.Logical.getNextElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  previousElementSibling: {\n\t\t    get: function get$5() {\n\t\t      return tree.Logical.getPreviousElementSibling(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  assignedSlot: {\n\t\t    get: function get$6() {\n\t\t      return this._assignedSlot;\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tvar FragmentMixin = {\n\t\t\n\t\t  appendChild: function appendChild(node) {\n\t\t    return this.insertBefore(node);\n\t\t  },\n\t\t\n\t\t  // cases in which we may not be able to just do standard native call\n\t\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t\t  // has an insertion point)\n\t\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t\t  // container to container.host.\n\t\t  // 3. node is <content> (host of container needs distribution)\n\t\t  insertBefore: function insertBefore(node, ref_node) {\n\t\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t\t        'of this node');\n\t\t    }\n\t\t    // remove node from its current position iff it's in a tree.\n\t\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t      var parent = tree.Logical.getParentNode(node);\n\t\t      mixinImpl.removeNodeFromParent(node, parent);\n\t\t    }\n\t\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t\t      if (ref_node) {\n\t\t        // if ref_node is an insertion point replace with first distributed node\n\t\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t\t        if (root) {\n\t\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t\t        }\n\t\t      }\n\t\t      // if adding to a shadyRoot, add to host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host : this;\n\t\t      if (ref_node) {\n\t\t        tree.Composed.insertBefore(container, node, ref_node);\n\t\t      } else {\n\t\t        tree.Composed.appendChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  /**\n\t\t    Removes the given `node` from the element's `lightChildren`.\n\t\t    This method also performs dom composition.\n\t\t  */\n\t\t  removeChild: function removeChild(node) {\n\t\t    if (tree.Logical.getParentNode(node) !== this) {\n\t\t      throw Error('The node to be removed is not a child of this node: ' +\n\t\t        node);\n\t\t    }\n\t\t    if (!mixinImpl.removeNode(node)) {\n\t\t      // if removing from a shadyRoot, remove form host instead\n\t\t      var container = isShadyRoot(this) ?\n\t\t        this.host :\n\t\t        this;\n\t\t      // not guaranteed to physically be in container; e.g.\n\t\t      // undistributed nodes.\n\t\t      var parent = tree.Composed.getParentNode(node);\n\t\t      if (container === parent) {\n\t\t        tree.Composed.removeChild(container, node);\n\t\t      }\n\t\t    }\n\t\t    mixinImpl._scheduleObserver(this, null, node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  replaceChild: function replaceChild(node, ref_node) {\n\t\t    this.insertBefore(node, ref_node);\n\t\t    this.removeChild(ref_node);\n\t\t    return node;\n\t\t  },\n\t\t\n\t\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t\t  querySelector: function querySelector(selector) {\n\t\t    // match selector and halt on first result.\n\t\t    var result = mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    }, function(n) {\n\t\t      return Boolean(n);\n\t\t    })[0];\n\t\t    return result || null;\n\t\t  },\n\t\t\n\t\t  querySelectorAll: function querySelectorAll(selector) {\n\t\t    return mixinImpl.query(this, function(n) {\n\t\t      return matchesSelector(n, selector);\n\t\t    });\n\t\t  },\n\t\t\n\t\t  cloneNode: function cloneNode(deep) {\n\t\t    if (this.localName == 'template') {\n\t\t      return nativeCloneNode.call(this, deep);\n\t\t    } else {\n\t\t      var n = nativeCloneNode.call(this, false);\n\t\t      if (deep) {\n\t\t        var c$ = this.childNodes;\n\t\t        for (var i=0, nc; i < c$.length; i++) {\n\t\t          nc = c$[i].cloneNode(true);\n\t\t          n.appendChild(nc);\n\t\t        }\n\t\t      }\n\t\t      return n;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  importNode: function importNode(externalNode, deep) {\n\t\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t\t    var doc = this instanceof Document ? this :\n\t\t      this.ownerDocument;\n\t\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t\t    if (deep) {\n\t\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t\t      common.patchNode(n);\n\t\t      for (var i=0, nc; i < c$.length; i++) {\n\t\t        nc = doc.importNode(c$[i], true);\n\t\t        n.appendChild(nc);\n\t\t      }\n\t\t    }\n\t\t    return n;\n\t\t  }\n\t\t};\n\t\t\n\t\tObject.defineProperties(FragmentMixin, {\n\t\t\n\t\t  childNodes: {\n\t\t    get: function get$7() {\n\t\t      var c$ = tree.Logical.getChildNodes(this);\n\t\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  children: {\n\t\t    get: function get$8() {\n\t\t      if (tree.Logical.hasChildNodes(this)) {\n\t\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t\t        });\n\t\t      } else {\n\t\t        return tree.arrayCopyChildren(this);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstChild: {\n\t\t    get: function get$9() {\n\t\t      return tree.Logical.getFirstChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastChild: {\n\t\t    get: function get$10() {\n\t\t      return tree.Logical.getLastChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  firstElementChild: {\n\t\t    get: function get$11() {\n\t\t      return tree.Logical.getFirstElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  lastElementChild: {\n\t\t    get: function get$12() {\n\t\t      return tree.Logical.getLastElementChild(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t\t  // textContent / innerHTML\n\t\t  textContent: {\n\t\t    get: function get$13() {\n\t\t      if (this.childNodes) {\n\t\t        var tc = [];\n\t\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t\t            tc.push(c.textContent);\n\t\t          }\n\t\t        }\n\t\t        return tc.join('');\n\t\t      }\n\t\t      return '';\n\t\t    },\n\t\t    set: function set(text) {\n\t\t      mixinImpl.clearNode(this);\n\t\t      if (text) {\n\t\t        this.appendChild(document.createTextNode(text));\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  },\n\t\t\n\t\t  innerHTML: {\n\t\t    get: function get$14() {\n\t\t      return getInnerHTML(this);\n\t\t    },\n\t\t    set: function set$1(text) {\n\t\t      var this$1 = this;\n\t\t\n\t\t      mixinImpl.clearNode(this);\n\t\t      var d = document.createElement('div');\n\t\t      d.innerHTML = text;\n\t\t      // here, appendChild may move nodes async so we cannot rely\n\t\t      // on node position when copying\n\t\t      var c$ = tree.arrayCopyChildNodes(d);\n\t\t      for (var i=0; i < c$.length; i++) {\n\t\t        this$1.appendChild(c$[i]);\n\t\t      }\n\t\t    },\n\t\t    configurable: true\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar ElementMixin = {\n\t\t\n\t\t  // TODO(sorvell): should only exist on <slot>\n\t\t  assignedNodes: function assignedNodes(options) {\n\t\t    return (options && options.flatten ? this._distributedNodes :\n\t\t      this._assignedNodes) || [];\n\t\t  },\n\t\t\n\t\t\n\t\t  setAttribute: function setAttribute$1(name, value) {\n\t\t    setAttribute.call(this, name, value);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  },\n\t\t\n\t\t  removeAttribute: function removeAttribute(name) {\n\t\t    nativeRemoveAttribute.call(this, name);\n\t\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tObject.defineProperties(ElementMixin, {\n\t\t\n\t\t  shadowRoot: {\n\t\t    get: function get$15() {\n\t\t      return this.shadyRoot;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  slot: {\n\t\t    get: function get$16() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set$2(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t});\n\t\t\n\t\tvar activeElementDescriptor = {\n\t\t  get: function get$17() {\n\t\t    return mixinImpl.activeElementForNode(this);\n\t\t  }\n\t\t}\n\t\t\n\t\tvar ActiveElementMixin = {};\n\t\tObject.defineProperties(ActiveElementMixin, {\n\t\t  activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar UnderActiveElementMixin = {};\n\t\tObject.defineProperties(UnderActiveElementMixin, {\n\t\t  _activeElement: activeElementDescriptor\n\t\t});\n\t\t\n\t\tvar Mixins = {\n\t\t\n\t\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\t\n\t\t  Fragment: extendAll({__patched: 'Fragment'},\n\t\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\t\n\t\t  Element: extendAll({__patched: 'Element'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\t\n\t\t  // Note: activeElement cannot be patched on document!\n\t\t  Document: extendAll({__patched: 'Document'},\n\t\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\t\n\t\t};\n\t\t\n\t\tvar getRootNode = function(node) {\n\t\t  return mixinImpl.getRootNode(node);\n\t\t}\n\t\t\n\t\tfunction filterMutations(mutations, target) {\n\t\t  var targetRootNode = getRootNode(target);\n\t\t  return mutations.filter(function(mutation) {\n\t\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t\t    if (mutationInScope && mutation.addedNodes) {\n\t\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t\t        return (targetRootNode === getRootNode(n));\n\t\t      });\n\t\t      Object.defineProperty(mutation, 'addedNodes', {\n\t\t        value: nodes,\n\t\t        configurable: true\n\t\t      });\n\t\t    }\n\t\t    return mutationInScope &&\n\t\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t\t  });\n\t\t}\n\t\t\n\t\t// const promise = Promise.resolve();\n\t\t\n\t\tvar AsyncObserver = function AsyncObserver() {\n\t\t  this._scheduled = false;\n\t\t  this.addedNodes = [];\n\t\t  this.removedNodes = [];\n\t\t  this.callbacks = new Set();\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.schedule = function schedule () {\n\t\t    var this$1 = this;\n\t\t\n\t\t  if (!this._scheduled) {\n\t\t    this._scheduled = true;\n\t\t    promish.then(function () {\n\t\t      this$1.flush();\n\t\t    });\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.flush = function flush () {\n\t\t  if (this._scheduled) {\n\t\t    this._scheduled = false;\n\t\t    var mutations = this.takeRecords();\n\t\t    if (mutations.length) {\n\t\t      this.callbacks.forEach(function(cb) {\n\t\t        cb(mutations);\n\t\t      });\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t\t    var mutations = [{\n\t\t      addedNodes: this.addedNodes,\n\t\t      removedNodes: this.removedNodes\n\t\t    }];\n\t\t    this.addedNodes = [];\n\t\t    this.removedNodes = [];\n\t\t    return mutations;\n\t\t  }\n\t\t  return [];\n\t\t};\n\t\t\n\t\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t\t// directly so that users do not have to fork their code.\n\t\t// Supporting the entire api may be challenging: e.g. filtering out\n\t\t// removed nodes in the wrong scope and seeing non-distributing\n\t\t// subtree child mutations.\n\t\tvar observeChildren = function(node, callback) {\n\t\t  common.patchNode(node);\n\t\t  if (!node.__dom.observer) {\n\t\t    node.__dom.observer = new AsyncObserver();\n\t\t  }\n\t\t  node.__dom.observer.callbacks.add(callback);\n\t\t  var observer = node.__dom.observer;\n\t\t  return {\n\t\t    _callback: callback,\n\t\t    _observer: observer,\n\t\t    _node: node,\n\t\t    takeRecords: function takeRecords() {\n\t\t      return observer.takeRecords()\n\t\t    }\n\t\t  };\n\t\t}\n\t\t\n\t\tvar unobserveChildren = function(handle) {\n\t\t  var observer = handle && handle._observer;\n\t\t  if (observer) {\n\t\t    observer.callbacks.delete(handle._callback);\n\t\t    if (!observer.callbacks.size) {\n\t\t      handle._node.__dom.observer = null;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tvar patchedCount = 0;\n\t\t\n\t\tvar log = false;\n\t\t\n\t\tvar patchImpl = {\n\t\t\n\t\t  canPatchNode: function(node) {\n\t\t    switch (node) {\n\t\t      case document.head:\n\t\t      case document.documentElement:\n\t\t        return false;\n\t\t      default:\n\t\t        return true;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t\t    window.Node.prototype, 'textContent')),\n\t\t\n\t\t  patch: function(node) {\n\t\t    patchedCount++;\n\t\t    log && window.console.warn('patch node', node);\n\t\t    if (this.hasPrototypeDescriptors) {\n\t\t      patchPrototype(node, this.mixinForObject(node));\n\t\t    } else {\n\t\t      window.console.warn('Patching instance rather than prototype', node);\n\t\t      extend(node, this.mixinForNode(node));\n\t\t    }\n\t\t  },\n\t\t\n\t\t  mixinForObject: function(obj) {\n\t\t    switch (obj.nodeType) {\n\t\t      case Node.ELEMENT_NODE:\n\t\t        return Mixins.Element;\n\t\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t\t        return Mixins.Fragment;\n\t\t      case Node.DOCUMENT_NODE:\n\t\t        return Mixins.Document;\n\t\t      case Node.TEXT_NODE:\n\t\t      case Node.COMMENT_NODE:\n\t\t        return Mixins.Node;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  unpatch: function(obj) {\n\t\t    if (obj.__sourceProto) {\n\t\t      obj.__proto__ = obj.__sourceProto;\n\t\t\n\t\t    }\n\t\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction patchNode(node) {\n\t\t  if (!settings.inUse) {\n\t\t    return;\n\t\t  }\n\t\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t\t    tree.saveChildNodes(node);\n\t\t    patchImpl.patch(node);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction unpatchNode(node) {\n\t\t  patchImpl.unpatch(node);\n\t\t}\n\t\t\n\t\tfunction isNodePatched(node) {\n\t\t  return Boolean(node.__patched);\n\t\t}\n\t\t\n\t\t// TODO(sorvell): fake export\n\t\tcommon.patchNode = patchNode;\n\t\tcommon.isNodePatched = isNodePatched;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar origAddEventListener = Element.prototype.addEventListener;\n\t\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\t\n\t\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\t\tvar alwaysComposed = {\n\t\t  blur: true,\n\t\t  focus: true,\n\t\t  focusin: true,\n\t\t  focusout: true,\n\t\t  click: true,\n\t\t  dblclick: true,\n\t\t  mousedown: true,\n\t\t  mouseenter: true,\n\t\t  mouseleave: true,\n\t\t  mousemove: true,\n\t\t  mouseout: true,\n\t\t  mouseover: true,\n\t\t  mouseup: true,\n\t\t  wheel: true,\n\t\t  beforeinput: true,\n\t\t  input: true,\n\t\t  keydown: true,\n\t\t  keyup: true,\n\t\t  compositionstart: true,\n\t\t  compositionupdate: true,\n\t\t  compositionend: true,\n\t\t  touchstart: true,\n\t\t  touchend: true,\n\t\t  touchmove: true,\n\t\t  touchcancel: true,\n\t\t  pointerover: true,\n\t\t  pointerenter: true,\n\t\t  pointerdown: true,\n\t\t  pointermove: true,\n\t\t  pointerup: true,\n\t\t  pointercancel: true,\n\t\t  pointerout: true,\n\t\t  pointerleave: true,\n\t\t  gotpointercapture: true,\n\t\t  lostpointercapture: true,\n\t\t  dragstart: true,\n\t\t  drag: true,\n\t\t  dragenter: true,\n\t\t  dragleave: true,\n\t\t  dragover: true,\n\t\t  drop: true,\n\t\t  dragend: true,\n\t\t  DOMActivate: true,\n\t\t  DOMFocusIn: true,\n\t\t  DOMFocusOut: true,\n\t\t  keypress: true\n\t\t};\n\t\t\n\t\tfunction pathComposer(startNode, composed) {\n\t\t  var composedPath = [];\n\t\t  var current = startNode;\n\t\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t\t  while (current) {\n\t\t    composedPath.push(current);\n\t\t    if (current.assignedSlot) {\n\t\t      current = current.assignedSlot;\n\t\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t\t      current = current.host;\n\t\t    } else {\n\t\t      current = current.parentNode;\n\t\t    }\n\t\t  }\n\t\t  // event composedPath includes window when startNode's ownerRoot is document\n\t\t  if (composedPath[composedPath.length - 1] === document) {\n\t\t    composedPath.push(window);\n\t\t  }\n\t\t  return composedPath;\n\t\t}\n\t\t\n\t\tfunction retarget(refNode, path) {\n\t\t  if (!isShadyRoot) {\n\t\t    return refNode;\n\t\t  }\n\t\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t\t  var refNodePath = pathComposer(refNode, true);\n\t\t  var p$ = path;\n\t\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t\t    ancestor = p$[i];\n\t\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t\t    if (root !== lastRoot) {\n\t\t      rootIdx = refNodePath.indexOf(root);\n\t\t      lastRoot = root;\n\t\t    }\n\t\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t\t      return ancestor;\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tvar EventMixin = {\n\t\t\n\t\t  __patched: 'Event',\n\t\t\n\t\t  get composed() {\n\t\t    if (this.isTrusted && this.__composed === undefined) {\n\t\t      this.__composed = alwaysComposed[this.type];\n\t\t    }\n\t\t    return this.__composed || false;\n\t\t  },\n\t\t\n\t\t  composedPath: function composedPath() {\n\t\t    if (!this.__composedPath) {\n\t\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t\t    }\n\t\t    return this.__composedPath;\n\t\t  },\n\t\t\n\t\t  get target() {\n\t\t    return retarget(this.currentTarget, this.composedPath());\n\t\t  },\n\t\t\n\t\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t\t  get relatedTarget() {\n\t\t    if (!this.__relatedTarget) {\n\t\t      return null;\n\t\t    }\n\t\t    if (!this.__relatedTargetComposedPath) {\n\t\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t\t    }\n\t\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t\t  },\n\t\t  stopPropagation: function stopPropagation() {\n\t\t    Event.prototype.stopPropagation.call(this);\n\t\t    this.__propagationStopped = true;\n\t\t  },\n\t\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t\t    Event.prototype.stopImmediatePropagation.call(this);\n\t\t    this.__immediatePropagationStopped = true;\n\t\t    this.__propagationStopped = true;\n\t\t  }\n\t\t\n\t\t};\n\t\t\n\t\tfunction mixinComposedFlag(Base) {\n\t\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t\t  // try to do `Base.call` with a dom construtor.\n\t\t  var klazz = function(type, options) {\n\t\t    var event = new Base(type, options);\n\t\t    event.__composed = options && Boolean(options.composed);\n\t\t    return event;\n\t\t  }\n\t\t  // put constructor properties on subclass\n\t\t  mixin(klazz, Base);\n\t\t  klazz.prototype = Base.prototype;\n\t\t  return klazz;\n\t\t}\n\t\t\n\t\tvar nonBubblingEventsToRetarget = {\n\t\t  focus: true,\n\t\t  blur: true\n\t\t};\n\t\t\n\t\tfunction fireHandlers(event, node, phase) {\n\t\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t\t    node.__handlers[event.type][phase];\n\t\t  if (hs) {\n\t\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t\t      fn.call(node, event);\n\t\t      if (event.__immediatePropagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction retargetNonBubblingEvent(e) {\n\t\t  var path = e.composedPath();\n\t\t  var node;\n\t\t  // override `currentTarget` to let patched `target` calculate correctly\n\t\t  Object.defineProperty(e, 'currentTarget', {\n\t\t    get: function() {\n\t\t      return node;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t  for (var i = path.length - 1; i >= 0; i--) {\n\t\t    node = path[i];\n\t\t    // capture phase fires all capture handlers\n\t\t    fireHandlers(e, node, 'capture');\n\t\t    if (e.__propagationStopped) {\n\t\t      return;\n\t\t    }\n\t\t  }\n\t\t\n\t\t  // set the event phase to `AT_TARGET` as in spec\n\t\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\t\n\t\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t\t  // keep track of the last seen owner root\n\t\t  var lastFiredRoot;\n\t\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t\t    node = path[i$1];\n\t\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t\t      fireHandlers(e, node, 'bubble');\n\t\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t\t      if (node !== window) {\n\t\t        lastFiredRoot = node.getRootNode();\n\t\t      }\n\t\t      if (e.__propagationStopped) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t\t  // It's more efficient to store the node/type/options information as Array in\n\t\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  if (fn.__eventWrappers) {\n\t\t    // Stop if the wrapper function has already been created.\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        return;\n\t\t      }\n\t\t    }\n\t\t  } else {\n\t\t    fn.__eventWrappers = [];\n\t\t  }\n\t\t\n\t\t  var wrapperFn = function(e) {\n\t\t    // Support `once` option.\n\t\t    if (once) {\n\t\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t\t    }\n\t\t    if (!e.__target) {\n\t\t      e.__target = e.target;\n\t\t      e.__relatedTarget = e.relatedTarget;\n\t\t      patchPrototype(e, EventMixin);\n\t\t    }\n\t\t    // There are two critera that should stop events from firing on this node\n\t\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t\t        if (e.target === e.relatedTarget) {\n\t\t          e.stopImmediatePropagation();\n\t\t          return;\n\t\t        }\n\t\t      }\n\t\t      return fn(e);\n\t\t    }\n\t\t  };\n\t\t  // Store the wrapper information.\n\t\t  fn.__eventWrappers.push({\n\t\t    node: this,\n\t\t    type: type,\n\t\t    capture: capture,\n\t\t    once: once,\n\t\t    passive: passive,\n\t\t    wrapperFn: wrapperFn\n\t\t  });\n\t\t\n\t\t  if (nonBubblingEventsToRetarget[type]) {\n\t\t    this.__handlers = this.__handlers || {};\n\t\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t\t  } else {\n\t\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t\t  var this$1 = this;\n\t\t\n\t\t  if (!fn) {\n\t\t    return;\n\t\t  }\n\t\t\n\t\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t\t  var capture, once, passive;\n\t\t  if (typeof optionsOrCapture === 'object') {\n\t\t    capture = Boolean(optionsOrCapture.capture);\n\t\t    once = Boolean(optionsOrCapture.once);\n\t\t    passive = Boolean(optionsOrCapture.passive);\n\t\t  } else {\n\t\t    capture = Boolean(optionsOrCapture);\n\t\t    once = false;\n\t\t    passive = false;\n\t\t  }\n\t\t  // Search the wrapped function.\n\t\t  var wrapperFn = undefined;\n\t\t  if (fn.__eventWrappers) {\n\t\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t\t          fn.__eventWrappers[i].type === type &&\n\t\t          fn.__eventWrappers[i].capture === capture &&\n\t\t          fn.__eventWrappers[i].once === once &&\n\t\t          fn.__eventWrappers[i].passive === passive) {\n\t\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t\t        // Cleanup.\n\t\t        if (!fn.__eventWrappers.length) {\n\t\t          fn.__eventWrappers = undefined;\n\t\t        }\n\t\t        break;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t\n\t\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t\t      this.__handlers && this.__handlers[type]) {\n\t\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t\t    var idx = arr.indexOf(wrapperFn);\n\t\t    if (idx > -1) {\n\t\t      arr.splice(idx, 1);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction activateFocusEventOverrides() {\n\t\t  for (var ev in nonBubblingEventsToRetarget) {\n\t\t    window.addEventListener(ev, function(e) {\n\t\t      if (!e.__target) {\n\t\t        e.__target = e.target;\n\t\t        e.__relatedTarget = e.relatedTarget;\n\t\t        patchPrototype(e, EventMixin);\n\t\t        retargetNonBubblingEvent(e);\n\t\t        e.stopImmediatePropagation();\n\t\t      }\n\t\t    }, true);\n\t\t  }\n\t\t}\n\t\t\n\t\t\n\t\tvar PatchedEvent = mixinComposedFlag(Event);\n\t\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\t\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/**\n\t\t * Patches elements that interacts with ShadyDOM\n\t\t * such that tree traversal and mutation apis act like they would under\n\t\t * ShadowDOM.\n\t\t *\n\t\t * This import enables seemless interaction with ShadyDOM powered\n\t\t * custom elements, enabling better interoperation with 3rd party code,\n\t\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t\t */\n\t\t\n\t\tif (settings.inUse) {\n\t\t\n\t\t  window.ShadyDOM = {\n\t\t    tree: tree,\n\t\t    getNativeProperty: getNativeProperty,\n\t\t    patch: patchNode,\n\t\t    isPatched: isNodePatched,\n\t\t    unpatch: unpatchNode,\n\t\t    isShadyRoot: isShadyRoot,\n\t\t    enqueue: enqueue,\n\t\t    flush: flush$1,\n\t\t    inUse: settings.inUse,\n\t\t    filterMutations: filterMutations,\n\t\t    observeChildren: observeChildren,\n\t\t    unobserveChildren: unobserveChildren\n\t\t  };\n\t\t\n\t\t  var createRootAndEnsurePatched = function(node) {\n\t\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t\t    // a timing problem with gathering composed children.\n\t\t    // (1) currently the child list is crawled and patched when patching occurs\n\t\t    // (this needs to change)\n\t\t    // (2) we can only patch when an element has received its parsed children\n\t\t    // because we cannot detect them when inserted by parser.\n\t\t    // let ancestor = node;\n\t\t    // while (ancestor) {\n\t\t    //   patchNode(ancestor);\n\t\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t\t    // }\n\t\t    patchNode(node);\n\t\t    var root = new ShadyRoot(node);\n\t\t    patchNode(root);\n\t\t    return root;\n\t\t  }\n\t\t\n\t\t  Element.prototype.attachShadow = function() {\n\t\t    return createRootAndEnsurePatched(this);\n\t\t  }\n\t\t\n\t\t  Node.prototype.addEventListener = addEventListener;\n\t\t  Node.prototype.removeEventListener = removeEventListener;\n\t\t  Event = PatchedEvent;\n\t\t  CustomEvent = PatchedCustomEvent;\n\t\t  MouseEvent = PatchedMouseEvent;\n\t\t  activateFocusEventOverrides();\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t\t    get: function get() {\n\t\t      return document.documentElement.contains(this);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Node.prototype.getRootNode = function(options) {\n\t\t    return getRootNode(this, options);\n\t\t  }\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'slot', {\n\t\t    get: function get$1() {\n\t\t      return this.getAttribute('slot');\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      this.setAttribute('slot', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t\t    get: function get$2() {\n\t\t      return this._assignedSlot || null;\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  Element.prototype.setAttribute = setAttribute;\n\t\t\n\t\t  Object.defineProperty(Element.prototype, 'className', {\n\t\t    get: function get$3() {\n\t\t      return this.getAttribute('class');\n\t\t    },\n\t\t    set: function set$1(value) {\n\t\t      this.setAttribute('class', value);\n\t\t    },\n\t\t    configurable: true\n\t\t  });\n\t\t\n\t\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t\t  // via appendChild. This either needs to be expanded or contracted.\n\t\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t\t  //   patchNode(this);\n\t\t  //   return this.appendChild(node);\n\t\t  // }\n\t\t\n\t\t}\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadydom.min.js.map\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t(function () {\n\t\t'use strict';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tExtremely simple css parser. Intended to be not more than what we need\n\t\tand definitely not necessarily correct =).\n\t\t*/\n\t\t\n\t\t// given a string of css, return a simple rule tree\n\t\t\n\t\tfunction parse(text) {\n\t\t  text = clean(text);\n\t\t  return parseCss(lex(text), text);\n\t\t}\n\t\t\n\t\t// remove stuff we don't care about that may hinder parsing\n\t\tfunction clean(cssText) {\n\t\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t\t}\n\t\t\n\t\t// super simple {...} lexer that returns a node tree\n\t\tfunction lex(text) {\n\t\t  var root = {\n\t\t    start: 0,\n\t\t    end: text.length\n\t\t  };\n\t\t  var n = root;\n\t\t  for (var i = 0, l = text.length; i < l; i++) {\n\t\t    if (text[i] === OPEN_BRACE) {\n\t\t      if (!n.rules) {\n\t\t        n.rules = [];\n\t\t      }\n\t\t      var p = n;\n\t\t      var previous = p.rules[p.rules.length - 1];\n\t\t      n = {\n\t\t        start: i + 1,\n\t\t        parent: p,\n\t\t        previous: previous\n\t\t      };\n\t\t      p.rules.push(n);\n\t\t    } else if (text[i] === CLOSE_BRACE) {\n\t\t      n.end = i + 1;\n\t\t      n = n.parent || root;\n\t\t    }\n\t\t  }\n\t\t  return root;\n\t\t}\n\t\t\n\t\t// add selectors/cssText to node tree\n\t\tfunction parseCss(node, text) {\n\t\t  var t = text.substring(node.start, node.end - 1);\n\t\t  node.parsedCssText = node.cssText = t.trim();\n\t\t  if (node.parent) {\n\t\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t\t    t = text.substring(ss, node.start - 1);\n\t\t    t = _expandUnicodeEscapes(t);\n\t\t    t = t.replace(RX.multipleSpaces, ' ');\n\t\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t\t    // helps with mixin syntax\n\t\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t\t    var s = node.parsedSelector = node.selector = t.trim();\n\t\t    node.atRule = s.indexOf(AT_START) === 0;\n\t\t    // note, support a subset of rule types...\n\t\t    if (node.atRule) {\n\t\t      if (s.indexOf(MEDIA_START) === 0) {\n\t\t        node.type = types.MEDIA_RULE;\n\t\t      } else if (s.match(RX.keyframesRule)) {\n\t\t        node.type = types.KEYFRAMES_RULE;\n\t\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t\t      }\n\t\t    } else {\n\t\t      if (s.indexOf(VAR_START) === 0) {\n\t\t        node.type = types.MIXIN_RULE;\n\t\t      } else {\n\t\t        node.type = types.STYLE_RULE;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      parseCss(r, text);\n\t\t    }\n\t\t  }\n\t\t  return node;\n\t\t}\n\t\t\n\t\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t\t// expanded form that doesn't require trailing space `\\000033`\n\t\tfunction _expandUnicodeEscapes(s) {\n\t\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t\t    var code = arguments[1],\n\t\t        repeat = 6 - code.length;\n\t\t    while (repeat--) {\n\t\t      code = '0' + code;\n\t\t    }\n\t\t    return '\\\\' + code;\n\t\t  });\n\t\t}\n\t\t\n\t\t// stringify parsed css.\n\t\tfunction stringify(node, preserveProperties, text) {\n\t\t  text = text || '';\n\t\t  // calc rule cssText\n\t\t  var cssText = '';\n\t\t  if (node.cssText || node.rules) {\n\t\t    var r$ = node.rules;\n\t\t    if (r$ && !_hasMixinRules(r$)) {\n\t\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t        cssText = stringify(r, preserveProperties, cssText);\n\t\t      }\n\t\t    } else {\n\t\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t\t      cssText = cssText.trim();\n\t\t      if (cssText) {\n\t\t        cssText = '  ' + cssText + '\\n';\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  // emit rule if there is cssText\n\t\t  if (cssText) {\n\t\t    if (node.selector) {\n\t\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t\t    }\n\t\t    text += cssText;\n\t\t    if (node.selector) {\n\t\t      text += CLOSE_BRACE + '\\n\\n';\n\t\t    }\n\t\t  }\n\t\t  return text;\n\t\t}\n\t\t\n\t\tfunction _hasMixinRules(rules) {\n\t\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t\t}\n\t\t\n\t\tfunction removeCustomProps(cssText) {\n\t\t  cssText = removeCustomPropAssignment(cssText);\n\t\t  return removeCustomPropApply(cssText);\n\t\t}\n\t\t\n\t\tfunction removeCustomPropAssignment(cssText) {\n\t\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t\t}\n\t\t\n\t\tfunction removeCustomPropApply(cssText) {\n\t\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t\t}\n\t\t\n\t\tvar types = {\n\t\t  STYLE_RULE: 1,\n\t\t  KEYFRAMES_RULE: 7,\n\t\t  MEDIA_RULE: 4,\n\t\t  MIXIN_RULE: 1000\n\t\t};\n\t\t\n\t\tvar OPEN_BRACE = '{';\n\t\tvar CLOSE_BRACE = '}';\n\t\t\n\t\t// helper regexp's\n\t\tvar RX = {\n\t\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t\t  port: /@import[^;]*;/gim,\n\t\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t\t  multipleSpaces: /\\s+/g\n\t\t};\n\t\t\n\t\tvar VAR_START = '--';\n\t\tvar MEDIA_START = '@media';\n\t\tvar AT_START = '@';\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\t\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\t\n\t\t// experimental support for native @apply\n\t\tfunction detectNativeApply() {\n\t\t  var style = document.createElement('style');\n\t\t  style.textContent = '.foo { @apply --foo }';\n\t\t  document.head.appendChild(style);\n\t\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t\t  document.head.removeChild(style);\n\t\t  return nativeCssApply;\n\t\t}\n\t\t\n\t\tvar nativeCssApply = false && detectNativeApply();\n\t\t\n\t\tfunction parseSettings(settings) {\n\t\t  if (settings) {\n\t\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t\t  }\n\t\t}\n\t\t\n\t\tif (window.ShadyCSS) {\n\t\t  parseSettings(window.ShadyCSS);\n\t\t} else if (window.WebComponents) {\n\t\t  parseSettings(window.WebComponents.flags);\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tfunction toCssText(rules, callback) {\n\t\t  if (typeof rules === 'string') {\n\t\t    rules = parse(rules);\n\t\t  }\n\t\t  if (callback) {\n\t\t    forEachRule(rules, callback);\n\t\t  }\n\t\t  return stringify(rules, nativeCssVariables);\n\t\t}\n\t\t\n\t\tfunction rulesForStyle(style) {\n\t\t  if (!style.__cssRules && style.textContent) {\n\t\t    style.__cssRules = parse(style.textContent);\n\t\t  }\n\t\t  return style.__cssRules;\n\t\t}\n\t\t\n\t\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t\t// like a normal selector but is not (it has nothing to do with scoping\n\t\t// for example).\n\t\tfunction isKeyframesSelector(rule) {\n\t\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t\t}\n\t\t\n\t\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t\t  if (!node) {\n\t\t    return;\n\t\t  }\n\t\t  var skipRules = false;\n\t\t  if (onlyActiveRules) {\n\t\t    if (node.type === types.MEDIA_RULE) {\n\t\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t\t      if (matchMedia) {\n\t\t        // if rule is a non matching @media rule, skip subrules\n\t\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t\t          skipRules = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  if (node.type === types.STYLE_RULE) {\n\t\t    styleRuleCallback(node);\n\t\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t\t    keyframesRuleCallback(node);\n\t\t  } else if (node.type === types.MIXIN_RULE) {\n\t\t    skipRules = true;\n\t\t  }\n\t\t  var r$ = node.rules;\n\t\t  if (r$ && !skipRules) {\n\t\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t\t    }\n\t\t  }\n\t\t}\n\t\t\n\t\t// add a string of cssText to the document.\n\t\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t\t  var style = createScopeStyle(cssText, moniker);\n\t\t  return applyStyle$1(style, target, contextNode);\n\t\t}\n\t\t\n\t\tfunction applyStyle$1(style, target, contextNode) {\n\t\t  target = target || document.head;\n\t\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t\t  lastHeadApplyNode = style;\n\t\t  return target.insertBefore(style, after);\n\t\t}\n\t\t\n\t\tfunction createScopeStyle(cssText, moniker) {\n\t\t  var style = document.createElement('style');\n\t\t  if (moniker) {\n\t\t    style.setAttribute('scope', moniker);\n\t\t  }\n\t\t  style.textContent = cssText;\n\t\t  return style;\n\t\t}\n\t\t\n\t\tvar lastHeadApplyNode = null;\n\t\t\n\t\t// insert a comment node as a styling position placeholder.\n\t\tfunction applyStylePlaceHolder(moniker) {\n\t\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t\t  var scope = document.head;\n\t\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t\t  lastHeadApplyNode = placeHolder;\n\t\t  return placeHolder;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t// cssBuildTypeForModule: function (module) {\n\t\t//   let dm = Polymer.DomModule.import(module);\n\t\t//   if (dm) {\n\t\t//     return getCssBuildType(dm);\n\t\t//   }\n\t\t// },\n\t\t//\n\t\t\n\t\t\n\t\t// Walk from text[start] matching parens\n\t\t// returns position of the outer end paren\n\t\tfunction findMatchingParen(text, start) {\n\t\t  var level = 0;\n\t\t  for (var i = start, l = text.length; i < l; i++) {\n\t\t    if (text[i] === '(') {\n\t\t      level++;\n\t\t    } else if (text[i] === ')') {\n\t\t      if (--level === 0) {\n\t\t        return i;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t  return -1;\n\t\t}\n\t\t\n\t\tfunction processVariableAndFallback(str, callback) {\n\t\t  // find 'var('\n\t\t  var start = str.indexOf('var(');\n\t\t  if (start === -1) {\n\t\t    // no var?, everything is prefix\n\t\t    return callback(str, '', '', '');\n\t\t  }\n\t\t  //${prefix}var(${inner})${suffix}\n\t\t  var end = findMatchingParen(str, start + 3);\n\t\t  var inner = str.substring(start + 4, end);\n\t\t  var prefix = str.substring(0, start);\n\t\t  // suffix may have other variables\n\t\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t\t  var comma = inner.indexOf(',');\n\t\t  // value and fallback args should be trimmed to match in property lookup\n\t\t  if (comma === -1) {\n\t\t    // variable, no fallback\n\t\t    return callback(prefix, inner.trim(), '', suffix);\n\t\t  }\n\t\t  // var(${value},${fallback})\n\t\t  var value = inner.substring(0, comma).trim();\n\t\t  var fallback = inner.substring(comma + 1).trim();\n\t\t  return callback(prefix, value, fallback, suffix);\n\t\t}\n\t\t\n\t\tvar rx = {\n\t\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t\t  IS_VAR: /^--/,\n\t\t  BRACKETED: /\\{[^}]*\\}/g,\n\t\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\t\n\t\t* scoping:\n\t\t\n\t\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t\t  * selectors re-written as follows:\n\t\t\n\t\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\t\n\t\t* :host -> scopeName\n\t\t\n\t\t* :host(...) -> scopeName...\n\t\t\n\t\t* ::slotted(...) -> scopeName > ...\n\t\t\n\t\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\t\n\t\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\t\n\t\t*/\n\t\tvar SCOPE_NAME = 'style-scope';\n\t\t\n\t\tvar StyleTransformer = {\n\t\t\n\t\t  // Given a node and scope name, add a scoping class to each node\n\t\t  // in the tree. This facilitates transforming css into scoped rules.\n\t\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t\t    // one time optimization to skip scoping...\n\t\t    if (node.__styleScoped) {\n\t\t      node.__styleScoped = null;\n\t\t    } else {\n\t\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t\t    if (node.classList) {\n\t\t      this.element(node, selector, shouldRemoveScope);\n\t\t    }\n\t\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t\t    if (c$) {\n\t\t      for (var i = 0; i < c$.length; i++) {\n\t\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  element: function element(_element, scope, shouldRemoveScope) {\n\t\t    // note: if using classes, we add both the general 'style-scope' class\n\t\t    // as well as the specific scope. This enables easy filtering of all\n\t\t    // `style-scope` elements\n\t\t    if (scope) {\n\t\t      // note: svg on IE does not have classList so fallback to class\n\t\t      if (_element.classList) {\n\t\t        if (shouldRemoveScope) {\n\t\t          _element.classList.remove(SCOPE_NAME);\n\t\t          _element.classList.remove(scope);\n\t\t        } else {\n\t\t          _element.classList.add(SCOPE_NAME);\n\t\t          _element.classList.add(scope);\n\t\t        }\n\t\t      } else if (_element.getAttribute) {\n\t\t        var c = _element.getAttribute(CLASS);\n\t\t        if (shouldRemoveScope) {\n\t\t          if (c) {\n\t\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t\t          }\n\t\t        } else {\n\t\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t\t    var cssBuildType = element.__cssBuild;\n\t\t    // no need to shim selectors if settings.useNativeShadow, also\n\t\t    // a shady css build will already have transformed selectors\n\t\t    // NOTE: This method may be called as part of static or property shimming.\n\t\t    // When there is a targeted build it will not be called for static shimming,\n\t\t    // but when the property shim is used it is called and should opt out of\n\t\t    // static shimming work when a proper build exists.\n\t\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t\t    return cssText.trim();\n\t\t  },\n\t\t\n\t\t  // Given a string of cssText and a scoping string (scope), returns\n\t\t  // a string of scoped css where each selector is transformed to include\n\t\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t\t  // (e.g. :host) to use the scoping selector.\n\t\t  css: function css(rules, scope, ext, callback) {\n\t\t    var hostScope = this._calcHostScope(scope, ext);\n\t\t    scope = this._calcElementScope(scope);\n\t\t    var self = this;\n\t\t    return toCssText(rules, function (rule) {\n\t\t      if (!rule.isScoped) {\n\t\t        self.rule(rule, scope, hostScope);\n\t\t        rule.isScoped = true;\n\t\t      }\n\t\t      if (callback) {\n\t\t        callback(rule, scope, hostScope);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _calcElementScope: function _calcElementScope(scope) {\n\t\t    if (scope) {\n\t\t      return CSS_CLASS_PREFIX + scope;\n\t\t    } else {\n\t\t      return '';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t\t    return ext ? '[is=' + scope + ']' : scope;\n\t\t  },\n\t\t\n\t\t  rule: function rule(_rule, scope, hostScope) {\n\t\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  // transforms a css rule to a scoped rule.\n\t\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t\t    // against selectors (e.g. when calculating style properties)\n\t\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t\t  },\n\t\t\n\t\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t\t    // we want to skip transformation of rules that appear in keyframes,\n\t\t    // because they are keyframe selectors, not element selectors.\n\t\t    if (!isKeyframesSelector(rule)) {\n\t\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t\t      }\n\t\t    }\n\t\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t\t  },\n\t\t\n\t\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t\t    var _this = this;\n\t\t\n\t\t    var stop = false;\n\t\t    selector = selector.trim();\n\t\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t\t    });\n\t\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t\t      if (!stop) {\n\t\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t\t        stop = stop || info.stop;\n\t\t        c = info.combinator;\n\t\t        s = info.value;\n\t\t      }\n\t\t      return c + s;\n\t\t    });\n\t\t    return selector;\n\t\t  },\n\t\t\n\t\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t\t    // replace :host with host scoping class\n\t\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t\t    if (selector.indexOf(HOST) >= 0) {\n\t\t      selector = this._transformHostSelector(selector, hostScope);\n\t\t      // replace other selectors with scoping class\n\t\t    } else if (slottedIndex !== 0) {\n\t\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t\t    }\n\t\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t\t    // also ignore left-side combinator\n\t\t    var slotted = false;\n\t\t    if (slottedIndex >= 0) {\n\t\t      combinator = '';\n\t\t      slotted = true;\n\t\t    }\n\t\t    // process scope jumping selectors up to the scope jump and then stop\n\t\t    var stop = void 0;\n\t\t    if (slotted) {\n\t\t      stop = true;\n\t\t      if (slotted) {\n\t\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t\t          return ' > ' + paren;\n\t\t        });\n\t\t      }\n\t\t    }\n\t\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t\t    });\n\t\t    return { value: selector, combinator: combinator, stop: stop };\n\t\t  },\n\t\t\n\t\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t\t    p$[0] += scope;\n\t\t    return p$.join(PSEUDO_PREFIX);\n\t\t  },\n\t\t\n\t\t  // :host(...) -> scopeName...\n\t\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t\t    var m = selector.match(HOST_PAREN);\n\t\t    var paren = m && m[2].trim() || '';\n\t\t    if (paren) {\n\t\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t\t        // paren starts with a type selector\n\t\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t\t        // if the type selector is our hostScope then avoid pre-pending it\n\t\t        if (typeSelector === hostScope) {\n\t\t          return paren;\n\t\t          // otherwise, this selector should not match in this scope so\n\t\t          // output a bogus selector.\n\t\t        } else {\n\t\t          return SELECTOR_NO_MATCH;\n\t\t        }\n\t\t      } else {\n\t\t        // make sure to do a replace here to catch selectors like:\n\t\t        // `:host(.foo)::before`\n\t\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t\t          return hostScope + paren;\n\t\t        });\n\t\t      }\n\t\t      // if no paren, do a straight :host replacement.\n\t\t      // TODO(sorvell): this should not strictly be necessary but\n\t\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t\t      // which have been improperly used under Shady DOM. This should be\n\t\t      // deprecated.\n\t\t    } else {\n\t\t      return selector.replace(HOST, hostScope);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  documentRule: function documentRule(rule) {\n\t\t    // reset selector in case this is redone.\n\t\t    rule.selector = rule.parsedSelector;\n\t\t    this.normalizeRootSelector(rule);\n\t\t    this._transformRule(rule, this._transformDocumentSelector);\n\t\t  },\n\t\t\n\t\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t\t    if (rule.selector === ROOT) {\n\t\t      rule.selector = 'html';\n\t\t    }\n\t\t  },\n\t\t\n\t\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t\t  },\n\t\t  SCOPE_NAME: SCOPE_NAME\n\t\t};\n\t\t\n\t\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\t\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\t\tvar COMPLEX_SELECTOR_SEP = ',';\n\t\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\t\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\t\tvar HOST = ':host';\n\t\tvar ROOT = ':root';\n\t\tvar SLOTTED = '::slotted';\n\t\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t\t// NOTE: this supports 1 nested () pair for things like\n\t\t// :host(:not([selected]), more general support requires\n\t\t// parsing which seems like overkill\n\t\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\t// similar to HOST_PAREN\n\t\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\t\tvar CSS_CLASS_PREFIX = '.';\n\t\tvar PSEUDO_PREFIX = ':';\n\t\tvar CLASS = 'class';\n\t\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\t\n\t\tvar classCallCheck = function (instance, Constructor) {\n\t\t  if (!(instance instanceof Constructor)) {\n\t\t    throw new TypeError(\"Cannot call a class as a function\");\n\t\t  }\n\t\t};\n\t\t\n\t\tvar createClass = function () {\n\t\t  function defineProperties(target, props) {\n\t\t    for (var i = 0; i < props.length; i++) {\n\t\t      var descriptor = props[i];\n\t\t      descriptor.enumerable = descriptor.enumerable || false;\n\t\t      descriptor.configurable = true;\n\t\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return function (Constructor, protoProps, staticProps) {\n\t\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t\t    return Constructor;\n\t\t  };\n\t\t}();\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar set$1 = function set$1(object, property, value, receiver) {\n\t\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\t\n\t\t  if (desc === undefined) {\n\t\t    var parent = Object.getPrototypeOf(object);\n\t\t\n\t\t    if (parent !== null) {\n\t\t      set$1(parent, property, value, receiver);\n\t\t    }\n\t\t  } else if (\"value\" in desc && desc.writable) {\n\t\t    desc.value = value;\n\t\t  } else {\n\t\t    var setter = desc.set;\n\t\t\n\t\t    if (setter !== undefined) {\n\t\t      setter.call(receiver, value);\n\t\t    }\n\t\t  }\n\t\t\n\t\t  return value;\n\t\t};\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar toConsumableArray = function (arr) {\n\t\t  if (Array.isArray(arr)) {\n\t\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\t\n\t\t    return arr2;\n\t\t  } else {\n\t\t    return Array.from(arr);\n\t\t  }\n\t\t};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar StyleInfo = function () {\n\t\t  createClass(StyleInfo, null, [{\n\t\t    key: 'get',\n\t\t    value: function get(node) {\n\t\t      return node.__styleInfo;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'set',\n\t\t    value: function set(node, styleInfo) {\n\t\t      node.__styleInfo = styleInfo;\n\t\t      return styleInfo;\n\t\t    }\n\t\t  }]);\n\t\t\n\t\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t\t    classCallCheck(this, StyleInfo);\n\t\t\n\t\t    this.styleRules = ast || null;\n\t\t    this.placeholder = placeholder || null;\n\t\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t\t    this.overrideStyleProperties = {};\n\t\t    this.elementName = elementName || '';\n\t\t    this.cssBuild = cssBuild || '';\n\t\t    this.typeExtension = typeExtension || '';\n\t\t    this.styleProperties = null;\n\t\t    this.scopeSelector = null;\n\t\t    this.customStyle = null;\n\t\t  }\n\t\t\n\t\t  return StyleInfo;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO: dedupe with shady\n\t\tvar p = window.Element.prototype;\n\t\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\t\n\t\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\t\n\t\tvar StyleProperties = {\n\t\t\n\t\t  // decorates styles with rule info and returns an array of used style\n\t\t  // property names\n\t\t  decorateStyles: function decorateStyles(rules) {\n\t\t    var self = this,\n\t\t        props = {},\n\t\t        keyframes = [],\n\t\t        ruleIndex = 0;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      self.decorateRule(rule);\n\t\t      // mark in-order position of ast rule in styles block, used for cache key\n\t\t      rule.index = ruleIndex++;\n\t\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t\t    }, function onKeyframesRule(rule) {\n\t\t      keyframes.push(rule);\n\t\t    });\n\t\t    // Cache all found keyframes rules for later reference:\n\t\t    rules._keyframes = keyframes;\n\t\t    // return this list of property names *consumes* in these styles.\n\t\t    var names = [];\n\t\t    for (var i in props) {\n\t\t      names.push(i);\n\t\t    }\n\t\t    return names;\n\t\t  },\n\t\t\n\t\t  // decorate a single rule with property info\n\t\t  decorateRule: function decorateRule(rule) {\n\t\t    if (rule.propertyInfo) {\n\t\t      return rule.propertyInfo;\n\t\t    }\n\t\t    var info = {},\n\t\t        properties = {};\n\t\t    var hasProperties = this.collectProperties(rule, properties);\n\t\t    if (hasProperties) {\n\t\t      info.properties = properties;\n\t\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t\t      rule.rules = null;\n\t\t    }\n\t\t    info.cssText = this.collectCssText(rule);\n\t\t    rule.propertyInfo = info;\n\t\t    return info;\n\t\t  },\n\t\t\n\t\t  // collects the custom properties from a rule's cssText\n\t\t  collectProperties: function collectProperties(rule, properties) {\n\t\t    var info = rule.propertyInfo;\n\t\t    if (info) {\n\t\t      if (info.properties) {\n\t\t        Object.assign(properties, info.properties);\n\t\t        return true;\n\t\t      }\n\t\t    } else {\n\t\t      var m = void 0,\n\t\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t\t      var cssText = rule.parsedCssText;\n\t\t      var value = void 0;\n\t\t      var any = void 0;\n\t\t      while (m = rx$$1.exec(cssText)) {\n\t\t        // note: group 2 is var, 3 is mixin\n\t\t        value = (m[2] || m[3]).trim();\n\t\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t\t        if (value !== 'inherit' || value !== 'unset') {\n\t\t          properties[m[1].trim()] = value;\n\t\t        }\n\t\t        any = true;\n\t\t      }\n\t\t      return any;\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // returns cssText of properties that consume variables/mixins\n\t\t  collectCssText: function collectCssText(rule) {\n\t\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t\t  },\n\t\t\n\t\t  // NOTE: we support consumption inside mixin assignment\n\t\t  // but not production, so strip out {...}\n\t\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t\t  },\n\t\t\n\t\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t\t    var m = void 0;\n\t\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t\t      var name = m[1];\n\t\t      // This regex catches all variable names, and following non-whitespace char\n\t\t      // If next char is not ':', then variable is a consumer\n\t\t      if (m[2] !== ':') {\n\t\t        props[name] = true;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // turns custom properties into realized values.\n\t\t  reify: function reify(props) {\n\t\t    // big perf optimization here: reify only *own* properties\n\t\t    // since this object has __proto__ of the element's scope properties\n\t\t    var names = Object.getOwnPropertyNames(props);\n\t\t    for (var i = 0, n; i < names.length; i++) {\n\t\t      n = names[i];\n\t\t      props[n] = this.valueForProperty(props[n], props);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  // given a property value, returns the reified value\n\t\t  // a property value may be:\n\t\t  // (1) a literal value like: red or 5px;\n\t\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t\t  // var(--a, var(--b));\n\t\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t\t  valueForProperty: function valueForProperty(property, props) {\n\t\t    var _this = this;\n\t\t\n\t\t    // case (1) default\n\t\t    // case (3) defines a mixin and we have to reify the internals\n\t\t    if (property) {\n\t\t      if (property.indexOf(';') >= 0) {\n\t\t        property = this.valueForProperties(property, props);\n\t\t      } else {\n\t\t        (function () {\n\t\t          // case (2) variable\n\t\t          var self = _this;\n\t\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t\t            if (!value) {\n\t\t              return prefix + suffix;\n\t\t            }\n\t\t            var propertyValue = self.valueForProperty(props[value], props);\n\t\t            // if value is \"initial\", then the variable should be treated as unset\n\t\t            if (!propertyValue || propertyValue === 'initial') {\n\t\t              // fallback may be --a or var(--a) or literal\n\t\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t\t              // for use with native css variables.\n\t\t              // Since we have full control, we can use `inherit` directly.\n\t\t              propertyValue = 'inherit';\n\t\t            }\n\t\t            return prefix + (propertyValue || '') + suffix;\n\t\t          };\n\t\t          property = processVariableAndFallback(property, fn);\n\t\t        })();\n\t\t      }\n\t\t    }\n\t\t    return property && property.trim() || '';\n\t\t  },\n\t\t\n\t\t  // note: we do not yet support mixin within mixin\n\t\t  valueForProperties: function valueForProperties(property, props) {\n\t\t    var parts = property.split(';');\n\t\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t\t      if (_p = parts[i]) {\n\t\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t\t        if (m) {\n\t\t          _p = this.valueForProperty(props[m[1]], props);\n\t\t        } else {\n\t\t          var colon = _p.indexOf(':');\n\t\t          if (colon !== -1) {\n\t\t            var pp = _p.substring(colon);\n\t\t            pp = pp.trim();\n\t\t            pp = this.valueForProperty(pp, props) || pp;\n\t\t            _p = _p.substring(0, colon) + pp;\n\t\t          }\n\t\t        }\n\t\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t\t        // strip trailing ;\n\t\t        _p.slice(0, -1) : _p || '';\n\t\t      }\n\t\t    }\n\t\t    return parts.join(';');\n\t\t  },\n\t\t\n\t\t  applyProperties: function applyProperties(rule, props) {\n\t\t    var output = '';\n\t\t    // dynamically added sheets may not be decorated so ensure they are.\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (rule.propertyInfo.cssText) {\n\t\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t\t  // functions which take in cssText and spit out transformed cssText.\n\t\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t\t    var input = rule.cssText;\n\t\t    var output = rule.cssText;\n\t\t    if (rule.hasAnimations == null) {\n\t\t      // Cache whether or not the rule has any animations to begin with:\n\t\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t\t    }\n\t\t    // If there are no animations referenced, we can skip transforms:\n\t\t    if (rule.hasAnimations) {\n\t\t      var transform = void 0;\n\t\t      // If we haven't transformed this rule before, we iterate over all\n\t\t      // transforms:\n\t\t      if (rule.keyframeNamesToTransform == null) {\n\t\t        rule.keyframeNamesToTransform = [];\n\t\t        for (var keyframe in keyframeTransforms) {\n\t\t          transform = keyframeTransforms[keyframe];\n\t\t          output = transform(input);\n\t\t          // If the transform actually changed the CSS text, we cache the\n\t\t          // transform name for future use:\n\t\t          if (input !== output) {\n\t\t            input = output;\n\t\t            rule.keyframeNamesToTransform.push(keyframe);\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        // If we already have a list of keyframe names that apply to this\n\t\t        // rule, we apply only those keyframe name transforms:\n\t\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t\t          input = transform(input);\n\t\t        }\n\t\t        output = input;\n\t\t      }\n\t\t    }\n\t\t    rule.cssText = output;\n\t\t  },\n\t\t\n\t\t  // Test if the rules in these styles matches the given `element` and if so,\n\t\t  // collect any custom properties into `props`.\n\t\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t\t    var props = {},\n\t\t        self = this;\n\t\t    // generates a unique key for these matches\n\t\t    var o = [];\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t\t      // time to only include ones that have properties\n\t\t      if (!rule.propertyInfo) {\n\t\t        self.decorateRule(rule);\n\t\t      }\n\t\t      // match element against transformedSelector: selector may contain\n\t\t      // unwanted uniquification and parsedSelector does not directly match\n\t\t      // for :host selectors.\n\t\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t\t          self.collectProperties(rule, props);\n\t\t          // produce numeric key for these matches for lookup\n\t\t          addToBitMask(rule.index, o);\n\t\t        }\n\t\t      }\n\t\t    }, null, true);\n\t\t    return { properties: props, key: o };\n\t\t  },\n\t\t\n\t\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t\t    if (!rule.propertyInfo) {\n\t\t      this.decorateRule(rule);\n\t\t    }\n\t\t    if (!rule.propertyInfo.properties) {\n\t\t      return;\n\t\t    }\n\t\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t\t    var parsedSelector = rule.parsedSelector;\n\t\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t\t    // build info is either in scope (when scope is an element) or in the style\n\t\t    // when scope is the default scope; note: this allows default scope to have\n\t\t    // mixed mode built and unbuilt styles.\n\t\t    if (cssBuild === 'shady') {\n\t\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t\t    }\n\t\t    if (cssBuild === 'shadow') {\n\t\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t\t      isHost = isHost && !isRoot;\n\t\t    }\n\t\t    if (!isRoot && !isHost) {\n\t\t      return;\n\t\t    }\n\t\t    var selectorToMatch = hostScope;\n\t\t    if (isHost) {\n\t\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t\t      if (nativeShadow && !rule.transformedSelector) {\n\t\t        // transform :host into a matchable selector\n\t\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t\t      }\n\t\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t\t    }\n\t\t    callback({\n\t\t      selector: selectorToMatch,\n\t\t      isHost: isHost,\n\t\t      isRoot: isRoot\n\t\t    });\n\t\t  },\n\t\t\n\t\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t\t    var hostProps = {},\n\t\t        rootProps = {},\n\t\t        self = this;\n\t\t    // note: active rules excludes non-matching @media rules\n\t\t    var cssBuild = rules && rules.__cssBuild;\n\t\t    forEachRule(rules, function (rule) {\n\t\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t\t        var element = scope._element || scope;\n\t\t        if (matchesSelector.call(element, info.selector)) {\n\t\t          if (info.isHost) {\n\t\t            self.collectProperties(rule, hostProps);\n\t\t          } else {\n\t\t            self.collectProperties(rule, rootProps);\n\t\t          }\n\t\t        }\n\t\t      });\n\t\t    }, null, true);\n\t\t    return { rootProps: rootProps, hostProps: hostProps };\n\t\t  },\n\t\t\n\t\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t\t    var self = this;\n\t\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t\t    var rules = StyleInfo.get(element).styleRules;\n\t\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t\t      self.applyProperties(rule, properties);\n\t\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t\t        // is not necessary to apply them in ShadowDOM.\n\t\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t\t    var keyframesRules = rules._keyframes;\n\t\t    var keyframeTransforms = {};\n\t\t    if (!nativeShadow && keyframesRules) {\n\t\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t\t      // advance for the current scope. This allows us to catch keyframes\n\t\t      // rules that appear anywhere in the stylesheet:\n\t\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t\t      }\n\t\t    }\n\t\t    return keyframeTransforms;\n\t\t  },\n\t\t\n\t\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t\t  // particular scoped keyframes rule.\n\t\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t\t    return function (cssText) {\n\t\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t\t    };\n\t\t  },\n\t\t\n\t\t  // Transforms `@keyframes` names to be unique for the current host.\n\t\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t\t  },\n\t\t\n\t\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t\t  // have low specificity. They are overrideable by class selectors but,\n\t\t  // unfortunately, not by type selectors (e.g. overriding via\n\t\t  // `.special` is ok, but not by `x-foo`).\n\t\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t\t    var selector = rule.transformedSelector;\n\t\t    var scope = '.' + scopeId;\n\t\t    var parts = selector.split(',');\n\t\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t\t    }\n\t\t    rule.selector = parts.join(',');\n\t\t  },\n\t\t\n\t\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t\t    var c = element.getAttribute('class') || '';\n\t\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t\t    if (c !== v) {\n\t\t      element.setAttribute('class', v);\n\t\t    }\n\t\t  },\n\t\t\n\t\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t\t    // calculate cssText to apply\n\t\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t\t    // if shady and we have a cached style that is not style, decrement\n\t\t    var styleInfo = StyleInfo.get(element);\n\t\t    var s = styleInfo.customStyle;\n\t\t    if (s && !nativeShadow && s !== style) {\n\t\t      s._useCount--;\n\t\t      if (s._useCount <= 0 && s.parentNode) {\n\t\t        s.parentNode.removeChild(s);\n\t\t      }\n\t\t    }\n\t\t    // apply styling always under native or if we generated style\n\t\t    // or the cached style is not in document(!)\n\t\t    if (nativeShadow) {\n\t\t      // update existing style only under native\n\t\t      if (styleInfo.customStyle) {\n\t\t        styleInfo.customStyle.textContent = cssText;\n\t\t        style = styleInfo.customStyle;\n\t\t        // otherwise, if we have css to apply, do so\n\t\t      } else if (cssText) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t\t      }\n\t\t    } else {\n\t\t      // shady and no cache hit\n\t\t      if (!style) {\n\t\t        // apply css after the scope style of the element to help with\n\t\t        // style precedence rules.\n\t\t        if (cssText) {\n\t\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t\t        }\n\t\t        // shady and cache hit but not in document\n\t\t      } else if (!style.parentNode) {\n\t\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t\t      }\n\t\t    }\n\t\t    // ensure this style is our custom style and increment its use count.\n\t\t    if (style) {\n\t\t      style._useCount = style._useCount || 0;\n\t\t      // increment use count if we changed styles\n\t\t      if (styleInfo.customStyle != style) {\n\t\t        style._useCount++;\n\t\t      }\n\t\t      styleInfo.customStyle = style;\n\t\t    }\n\t\t    // @media rules may be stale in IE 10 and 11\n\t\t    if (IS_IE) {\n\t\t      style.textContent = style.textContent;\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t\n\t\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t\t    var rules = rulesForStyle(style);\n\t\t    var self = this;\n\t\t    style.textContent = toCssText(rules, function (rule) {\n\t\t      var css = rule.cssText = rule.parsedCssText;\n\t\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t\t        // remove property assignments\n\t\t        // so next function isn't confused\n\t\t        // NOTE: we have 3 categories of css:\n\t\t        // (1) normal properties,\n\t\t        // (2) custom property assignments (--foo: red;),\n\t\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t\t        // are not and this makes this case unique.\n\t\t        css = removeCustomPropAssignment(css);\n\t\t        // replace with reified properties, scenario is same as mixin\n\t\t        rule.cssText = self.valueForProperties(css, properties);\n\t\t      }\n\t\t    });\n\t\t  },\n\t\t\n\t\t  rx: rx,\n\t\t  XSCOPE_NAME: 'x-scope'\n\t\t};\n\t\t\n\t\tfunction addToBitMask(n, bits) {\n\t\t  var o = parseInt(n / 32);\n\t\t  var v = 1 << n % 32;\n\t\t  bits[o] = (bits[o] || 0) | v;\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar templateMap = {};\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar placeholderMap = {};\n\t\t\n\t\tvar ce = window.customElements;\n\t\tif (ce && !nativeShadow) {\n\t\t  (function () {\n\t\t    var origDefine = ce.define;\n\t\t    ce.define = function (name, clazz, options) {\n\t\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t\t      return origDefine.call(ce, name, clazz, options);\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\tvar StyleCache = function () {\n\t\t  function StyleCache() {\n\t\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t\t    classCallCheck(this, StyleCache);\n\t\t\n\t\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t\t    this.cache = {};\n\t\t    this.typeMax = typeMax;\n\t\t  }\n\t\t\n\t\t  createClass(StyleCache, [{\n\t\t    key: '_validate',\n\t\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t\t        var pn = ownPropertyNames[idx];\n\t\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t      return true;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'store',\n\t\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t\t      var list = this.cache[tagname] || [];\n\t\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t\t      if (list.length > this.typeMax) {\n\t\t        list.shift();\n\t\t      }\n\t\t      this.cache[tagname] = list;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'fetch',\n\t\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t\t      var list = this.cache[tagname];\n\t\t      if (!list) {\n\t\t        return;\n\t\t      }\n\t\t      // reverse list for most-recent lookups\n\t\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t\t        var entry = list[idx];\n\t\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t\t          return entry;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }]);\n\t\t  return StyleCache;\n\t\t}();\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/**\n\t\t * The apply shim simulates the behavior of `@apply` proposed at\n\t\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t\t * The approach is to convert a property like this:\n\t\t *\n\t\t *    --foo: {color: red; background: blue;}\n\t\t *\n\t\t * to this:\n\t\t *\n\t\t *    --foo_-_color: red;\n\t\t *    --foo_-_background: blue;\n\t\t *\n\t\t * Then where `@apply --foo` is used, that is converted to:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background);\n\t\t *\n\t\t * This approach generally works but there are some issues and limitations.\n\t\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t\t * another element sets it to:\n\t\t *\n\t\t *    --foo: { border: 2px solid red; }\n\t\t *\n\t\t * We must now ensure that the color and background from the previous setting\n\t\t * do not apply. This is accomplished by changing the property set to this:\n\t\t *\n\t\t *    --foo_-_border: 2px solid red;\n\t\t *    --foo_-_color: initial;\n\t\t *    --foo_-_background: initial;\n\t\t *\n\t\t * This works but introduces one new issue.\n\t\t * Consider this setup at the point where the `@apply` is used:\n\t\t *\n\t\t *    background: orange;\n\t\t *    @apply --foo;\n\t\t *\n\t\t * In this case the background will be unset (initial) rather than the desired\n\t\t * `orange`. We address this by altering the property set to use a fallback\n\t\t * value like this:\n\t\t *\n\t\t *    color: var(--foo_-_color);\n\t\t *    background: var(--foo_-_background, orange);\n\t\t *    border: var(--foo_-_border);\n\t\t *\n\t\t * Note that the default is retained in the property set and the `background` is\n\t\t * the desired `orange`. This leads us to a limitation.\n\t\t *\n\t\t * Limitation 1:\n\t\t\n\t\t * Only properties in the rule where the `@apply`\n\t\t * is used are considered as default values.\n\t\t * If another rule matches the element and sets `background` with\n\t\t * less specificity than the rule in which `@apply` appears,\n\t\t * the `background` will not be set.\n\t\t *\n\t\t * Limitation 2:\n\t\t *\n\t\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t\t * `@apply` properties.\n\t\t\n\t\t*/\n\t\t\n\t\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\t\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\t\n\t\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\t\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\t\n\t\t// separator used between mixin-name and mixin-property-name when producing properties\n\t\t// NOTE: plain '-' may cause collisions in user styles\n\t\tvar MIXIN_VAR_SEP = '_-_';\n\t\t\n\t\t// map of mixin to property names\n\t\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\t\n\t\tvar MixinMap = function () {\n\t\t  function MixinMap() {\n\t\t    classCallCheck(this, MixinMap);\n\t\t\n\t\t    this._map = {};\n\t\t  }\n\t\t\n\t\t  createClass(MixinMap, [{\n\t\t    key: 'set',\n\t\t    value: function set(name, props) {\n\t\t      name = name.trim();\n\t\t      this._map[name] = {\n\t\t        properties: props,\n\t\t        dependants: {}\n\t\t      };\n\t\t    }\n\t\t  }, {\n\t\t    key: 'get',\n\t\t    value: function get(name) {\n\t\t      name = name.trim();\n\t\t      return this._map[name];\n\t\t    }\n\t\t  }]);\n\t\t  return MixinMap;\n\t\t}();\n\t\t\n\t\tvar ApplyShim = function () {\n\t\t  function ApplyShim() {\n\t\t    var _this = this;\n\t\t\n\t\t    classCallCheck(this, ApplyShim);\n\t\t\n\t\t    this._currentTemplate = null;\n\t\t    this._measureElement = null;\n\t\t    this._map = new MixinMap();\n\t\t    this._separator = MIXIN_VAR_SEP;\n\t\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t\t    };\n\t\t  }\n\t\t\n\t\t  createClass(ApplyShim, [{\n\t\t    key: 'transformStyle',\n\t\t    value: function transformStyle(style, elementName) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      this.transformRules(ast, elementName);\n\t\t      return ast;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRules',\n\t\t    value: function transformRules(rules, elementName) {\n\t\t      var _this2 = this;\n\t\t\n\t\t      this._currentTemplate = templateMap[elementName];\n\t\t      forEachRule(rules, function (r) {\n\t\t        _this2.transformRule(r);\n\t\t      });\n\t\t      if (this._currentTemplate) {\n\t\t        this._currentTemplate.__applyShimInvalid = false;\n\t\t      }\n\t\t      this._currentTemplate = null;\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformRule',\n\t\t    value: function transformRule(rule) {\n\t\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t\t      // :root was only used for variable assignment in property shim,\n\t\t      // but generates invalid selectors with real properties.\n\t\t      // replace with `:host > *`, which serves the same effect\n\t\t      if (rule.selector === ':root') {\n\t\t        rule.selector = ':host > *';\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: 'transformCssText',\n\t\t    value: function transformCssText(cssText) {\n\t\t      // produce variables\n\t\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t\t      // consume mixins\n\t\t      return this._consumeCssProperties(cssText);\n\t\t    }\n\t\t  }, {\n\t\t    key: '_getInitialValueForProperty',\n\t\t    value: function _getInitialValueForProperty(property) {\n\t\t      if (!this._measureElement) {\n\t\t        this._measureElement = document.createElement('meta');\n\t\t        this._measureElement.style.all = 'initial';\n\t\t        document.head.appendChild(this._measureElement);\n\t\t      }\n\t\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t\t    }\n\t\t    // replace mixin consumption with variable consumption\n\t\t\n\t\t  }, {\n\t\t    key: '_consumeCssProperties',\n\t\t    value: function _consumeCssProperties(text) {\n\t\t      var m = void 0;\n\t\t      // loop over text until all mixins with defintions have been applied\n\t\t      while (m = MIXIN_MATCH.exec(text)) {\n\t\t        var matchText = m[0];\n\t\t        var mixinName = m[1];\n\t\t        var idx = m.index;\n\t\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t\t        var applyPos = idx + matchText.indexOf('@apply');\n\t\t        var afterApplyPos = idx + matchText.length;\n\t\t        // find props defined before this @apply\n\t\t        var textBeforeApply = text.slice(0, applyPos);\n\t\t        var textAfterApply = text.slice(afterApplyPos);\n\t\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t\t        // use regex match position to replace mixin, keep linear processing time\n\t\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t\t        // move regex search to _after_ replacement\n\t\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t\t      }\n\t\t      return text;\n\t\t    }\n\t\t    // produce variable consumption at the site of mixin consumption\n\t\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t\t    // Example:\n\t\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\t\n\t\t  }, {\n\t\t    key: '_atApplyToCssProperties',\n\t\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t\t      var vars = [];\n\t\t      var mixinEntry = this._map.get(mixinName);\n\t\t      // if we depend on a mixin before it is created\n\t\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t\t      if (!mixinEntry) {\n\t\t        this._map.set(mixinName, {});\n\t\t        mixinEntry = this._map.get(mixinName);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        if (this._currentTemplate) {\n\t\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t\t        }\n\t\t        var p = void 0,\n\t\t            parts = void 0,\n\t\t            f = void 0;\n\t\t        for (p in mixinEntry.properties) {\n\t\t          f = fallbacks && fallbacks[p];\n\t\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t\t          if (f) {\n\t\t            parts.push(',', f);\n\t\t          }\n\t\t          parts.push(')');\n\t\t          vars.push(parts.join(''));\n\t\t        }\n\t\t      }\n\t\t      return vars.join('; ');\n\t\t    }\n\t\t  }, {\n\t\t    key: '_replaceInitialOrInherit',\n\t\t    value: function _replaceInitialOrInherit(property, value) {\n\t\t      var match = INITIAL_INHERIT.exec(value);\n\t\t      if (match) {\n\t\t        if (match[1]) {\n\t\t          // initial\n\t\t          // replace `initial` with the concrete initial value for this property\n\t\t          value = ApplyShim._getInitialValueForProperty(property);\n\t\t        } else {\n\t\t          // inherit\n\t\t          // with this purposfully illegal value, the variable will be invalid at\n\t\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t\t          // and for inheriting values, will behave similarly\n\t\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t\t          value = 'apply-shim-inherit';\n\t\t        }\n\t\t      }\n\t\t      return value;\n\t\t    }\n\t\t\n\t\t    // \"parse\" a mixin definition into a map of properties and values\n\t\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\t\n\t\t  }, {\n\t\t    key: '_cssTextToMap',\n\t\t    value: function _cssTextToMap(text) {\n\t\t      var props = text.split(';');\n\t\t      var property = void 0,\n\t\t          value = void 0;\n\t\t      var out = {};\n\t\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t\t        p = props[i];\n\t\t        if (p) {\n\t\t          sp = p.split(':');\n\t\t          // ignore lines that aren't definitions like @media\n\t\t          if (sp.length > 1) {\n\t\t            property = sp[0].trim();\n\t\t            // some properties may have ':' in the value, like data urls\n\t\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t\t            out[property] = value;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return out;\n\t\t    }\n\t\t  }, {\n\t\t    key: '_invalidateMixinEntry',\n\t\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t\t      for (var elementName in mixinEntry.dependants) {\n\t\t        if (elementName !== this._currentTemplate) {\n\t\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }, {\n\t\t    key: '_produceCssProperties',\n\t\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t\t      var _this3 = this;\n\t\t\n\t\t      // handle case where property value is a mixin\n\t\t      if (valueProperty) {\n\t\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t\t          if (value && _this3._map.get(value)) {\n\t\t            valueMixin = '@apply ' + value + ';';\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      if (!valueMixin) {\n\t\t        return matchText;\n\t\t      }\n\t\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t\t      var combinedProps = mixinValues;\n\t\t      var mixinEntry = this._map.get(propertyName);\n\t\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t\t      if (oldProps) {\n\t\t        // NOTE: since we use mixin, the map of properties is updated here\n\t\t        // and this is what we want.\n\t\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t\t      } else {\n\t\t        this._map.set(propertyName, combinedProps);\n\t\t      }\n\t\t      var out = [];\n\t\t      var p = void 0,\n\t\t          v = void 0;\n\t\t      // set variables defined by current mixin\n\t\t      var needToInvalidate = false;\n\t\t      for (p in combinedProps) {\n\t\t        v = mixinValues[p];\n\t\t        // if property not defined by current mixin, set initial\n\t\t        if (v === undefined) {\n\t\t          v = 'initial';\n\t\t        }\n\t\t        if (oldProps && !(p in oldProps)) {\n\t\t          needToInvalidate = true;\n\t\t        }\n\t\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t\t      }\n\t\t      if (needToInvalidate) {\n\t\t        this._invalidateMixinEntry(mixinEntry);\n\t\t      }\n\t\t      if (mixinEntry) {\n\t\t        mixinEntry.properties = combinedProps;\n\t\t      }\n\t\t      // because the mixinMap is global, the mixin might conflict with\n\t\t      // a different scope's simple variable definition:\n\t\t      // Example:\n\t\t      // some style somewhere:\n\t\t      // --mixin1:{ ... }\n\t\t      // --mixin2: var(--mixin1);\n\t\t      // some other element:\n\t\t      // --mixin1: 10px solid red;\n\t\t      // --foo: var(--mixin1);\n\t\t      // In this case, we leave the original variable definition in place.\n\t\t      if (valueProperty) {\n\t\t        prefix = matchText + ';' + prefix;\n\t\t      }\n\t\t      return prefix + out.join('; ') + ';';\n\t\t    }\n\t\t  }]);\n\t\t  return ApplyShim;\n\t\t}();\n\t\t\n\t\tvar applyShim = new ApplyShim();\n\t\twindow['ApplyShim'] = applyShim;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\tvar flush = function flush() {};\n\t\t\n\t\tif (!nativeShadow) {\n\t\t  (function () {\n\t\t    var handler = function handler(mxns) {\n\t\t      for (var x = 0; x < mxns.length; x++) {\n\t\t        var mxn = mxns[x];\n\t\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t\t          var n = mxn.addedNodes[i];\n\t\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t\t            var root = n.getRootNode();\n\t\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t\t              // may no longer be in a shadowroot\n\t\t              var host = root.host;\n\t\t              if (host) {\n\t\t                var scope = host.is || host.localName;\n\t\t                StyleTransformer.dom(n, scope);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t\t          var _n = mxn.removedNodes[_i];\n\t\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t\t            if (classIdx >= 0) {\n\t\t              // NOTE: relies on the scoping class always being adjacent to the\n\t\t              // SCOPE_NAME class.\n\t\t              var _scope = _n.classList[classIdx + 1];\n\t\t              if (_scope) {\n\t\t                StyleTransformer.dom(_n, _scope, true);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    };\n\t\t\n\t\t    var observer = new MutationObserver(handler);\n\t\t    var startState = 'interactive';\n\t\t\n\t\t    var start = function start() {\n\t\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t\t    };\n\t\t    if (window.HTMLImports) {\n\t\t      window.HTMLImports.whenReady(start);\n\t\t    } else if (document.readyState === startState) {\n\t\t      requestAnimationFrame(start);\n\t\t    } else {\n\t\t      document.addEventListener('readystatechange', function () {\n\t\t        if (document.readyState === startState) {\n\t\t          start();\n\t\t        }\n\t\t      });\n\t\t    }\n\t\t\n\t\t    flush = function flush() {\n\t\t      handler(observer.takeRecords());\n\t\t    };\n\t\t  })();\n\t\t}\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t// TODO(dfreedm): consider spliting into separate global\n\t\tvar styleCache = new StyleCache();\n\t\t\n\t\tvar ShadyCSS = {\n\t\t  flush: flush,\n\t\t  scopeCounter: {},\n\t\t  nativeShadow: nativeShadow,\n\t\t  nativeCss: nativeCssVariables,\n\t\t  nativeCssApply: nativeCssApply,\n\t\t  _documentOwner: document.documentElement,\n\t\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t\t    return name + '-' + id;\n\t\t  },\n\t\t  getStyleAst: function getStyleAst(style) {\n\t\t    return rulesForStyle(style);\n\t\t  },\n\t\t  styleAstToString: function styleAstToString(ast) {\n\t\t    return toCssText(ast);\n\t\t  },\n\t\t  _gatherStyles: function _gatherStyles(template) {\n\t\t    var styles = template.content.querySelectorAll('style');\n\t\t    var cssText = [];\n\t\t    for (var i = 0; i < styles.length; i++) {\n\t\t      var s = styles[i];\n\t\t      cssText.push(s.textContent);\n\t\t      s.parentNode.removeChild(s);\n\t\t    }\n\t\t    return cssText.join('').trim();\n\t\t  },\n\t\t  _getCssBuild: function _getCssBuild(template) {\n\t\t    var style = template.content.querySelector('style');\n\t\t    if (!style) {\n\t\t      return '';\n\t\t    }\n\t\t    return style.getAttribute('css-build') || '';\n\t\t  },\n\t\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t\t    if (template._prepared) {\n\t\t      return;\n\t\t    }\n\t\t    template._prepared = true;\n\t\t    template.name = elementName;\n\t\t    template.extends = typeExtension;\n\t\t    templateMap[elementName] = template;\n\t\t    var cssBuild = this._getCssBuild(template);\n\t\t    var cssText = this._gatherStyles(template);\n\t\t    var info = {\n\t\t      is: elementName,\n\t\t      extends: typeExtension,\n\t\t      __cssBuild: cssBuild\n\t\t    };\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleTransformer.dom(template.content, elementName);\n\t\t    }\n\t\t    var ast = parse(cssText);\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      applyShim.transformRules(ast, elementName);\n\t\t    }\n\t\t    template._styleAst = ast;\n\t\t\n\t\t    var ownPropertyNames = [];\n\t\t    if (!this.nativeCss) {\n\t\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t\t    }\n\t\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t\t      var root = this.nativeShadow ? template.content : null;\n\t\t      var placeholder = placeholderMap[elementName];\n\t\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t\t      template._style = style;\n\t\t    }\n\t\t    template._ownPropertyNames = ownPropertyNames;\n\t\t  },\n\t\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t\t    if (cssText.length) {\n\t\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t\t    }\n\t\t  },\n\t\t  _prepareHost: function _prepareHost(host) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var typeExtension = void 0;\n\t\t    if (is !== host.localName) {\n\t\t      typeExtension = host.localName;\n\t\t    }\n\t\t    var placeholder = placeholderMap[is];\n\t\t    var template = templateMap[is];\n\t\t    var ast = void 0;\n\t\t    var ownStylePropertyNames = void 0;\n\t\t    var cssBuild = void 0;\n\t\t    if (template) {\n\t\t      ast = template._styleAst;\n\t\t      ownStylePropertyNames = template._ownPropertyNames;\n\t\t      cssBuild = template._cssBuild;\n\t\t    }\n\t\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t\t  },\n\t\t  applyStyle: function applyStyle(host, overrideProps) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    if (window.CustomStyle) {\n\t\t      var CS = window.CustomStyle;\n\t\t      if (CS._documentDirty) {\n\t\t        CS.findStyles();\n\t\t        if (!this.nativeCss) {\n\t\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t\t        } else if (!this.nativeCssApply) {\n\t\t          CS._revalidateApplyShim();\n\t\t        }\n\t\t        CS.applyStyles();\n\t\t        CS._documentDirty = false;\n\t\t      }\n\t\t    }\n\t\t    var styleInfo = StyleInfo.get(host);\n\t\t    if (!styleInfo) {\n\t\t      styleInfo = this._prepareHost(host);\n\t\t    }\n\t\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t\t    if (this.nativeCss) {\n\t\t      var template = templateMap[is];\n\t\t      if (template && template.__applyShimInvalid && template._style) {\n\t\t        // update template\n\t\t        applyShim.transformRules(template._styleAst, is);\n\t\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        // update instance if native shadowdom\n\t\t        if (this.nativeShadow) {\n\t\t          var style = host.shadowRoot.querySelector('style');\n\t\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t\t        }\n\t\t        styleInfo.styleRules = template._styleAst;\n\t\t      }\n\t\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t\t    } else {\n\t\t      this._updateProperties(host, styleInfo);\n\t\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t\t        // TODO: use caching\n\t\t        this._applyStyleProperties(host, styleInfo);\n\t\t      }\n\t\t    }\n\t\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t\t    // note: some elements may not have a root!\n\t\t    if (root) {\n\t\t      this._applyToDescendants(root);\n\t\t    }\n\t\t  },\n\t\t  _applyToDescendants: function _applyToDescendants(root) {\n\t\t    var c$ = root.children;\n\t\t    for (var i = 0, c; i < c$.length; i++) {\n\t\t      c = c$[i];\n\t\t      if (c.shadowRoot) {\n\t\t        this.applyStyle(c);\n\t\t      }\n\t\t      this._applyToDescendants(c);\n\t\t    }\n\t\t  },\n\t\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t\t    var root = node.getRootNode();\n\t\t    var host = root.host;\n\t\t    if (host) {\n\t\t      if (StyleInfo.get(host)) {\n\t\t        return host;\n\t\t      } else {\n\t\t        return this._styleOwnerForNode(host);\n\t\t      }\n\t\t    }\n\t\t    return this._documentOwner;\n\t\t  },\n\t\t  _isRootOwner: function _isRootOwner(node) {\n\t\t    return node === this._documentOwner;\n\t\t  },\n\t\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t\t    var is = host.getAttribute('is') || host.localName;\n\t\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t\t    // only generate new scope if cached style is not found\n\t\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t\t    if (!this.nativeShadow) {\n\t\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t\t    }\n\t\t    if (!cacheEntry) {\n\t\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t\t    }\n\t\t    return style;\n\t\t  },\n\t\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t\t    var owner = this._styleOwnerForNode(host);\n\t\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t\t    var props = Object.create(ownerProperties || null);\n\t\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t\t    var propertiesMatchingHost = propertyData.properties;\n\t\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t\t    StyleProperties.reify(props);\n\t\t    styleInfo.styleProperties = props;\n\t\t  },\n\t\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t\t    for (var p in overrides) {\n\t\t      var v = overrides[p];\n\t\t      // skip override props if they are not truthy or 0\n\t\t      // in order to fall back to inherited values\n\t\t      if (v || v === 0) {\n\t\t        props[p] = v;\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t\t    // remove previous properties\n\t\t    for (var p in properties) {\n\t\t      // NOTE: for bc with shim, don't apply null values.\n\t\t      if (p === null) {\n\t\t        element.style.removeProperty(p);\n\t\t      } else {\n\t\t        element.style.setProperty(p, properties[p]);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  updateStyles: function updateStyles(properties) {\n\t\t    if (window.CustomStyle) {\n\t\t      window.CustomStyle._documentDirty = true;\n\t\t    }\n\t\t    this.applyStyle(this._documentOwner, properties);\n\t\t  },\n\t\t\n\t\t  /* Custom Style operations */\n\t\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t\t    var _this = this;\n\t\t\n\t\t    var ast = rulesForStyle(style);\n\t\t    forEachRule(ast, function (rule) {\n\t\t      if (nativeShadow) {\n\t\t        StyleTransformer.normalizeRootSelector(rule);\n\t\t      } else {\n\t\t        StyleTransformer.documentRule(rule);\n\t\t      }\n\t\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t\t        applyShim.transformRule(rule);\n\t\t      }\n\t\t    });\n\t\t    if (this.nativeCss) {\n\t\t      style.textContent = toCssText(ast);\n\t\t    } else {\n\t\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t\t    }\n\t\t  },\n\t\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t\t    if (this.nativeCss && !this.nativeCssApply) {\n\t\t      var ast = rulesForStyle(style);\n\t\t      applyShim.transformRules(ast);\n\t\t      style.textContent = toCssText(ast);\n\t\t    }\n\t\t  },\n\t\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t\t    if (!this.nativeCss) {\n\t\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t\t    }\n\t\t  },\n\t\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t\t    var value = void 0;\n\t\t    if (!this.nativeCss) {\n\t\t      // element is either a style host, or an ancestor of a style host\n\t\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t\t      value = styleInfo.styleProperties[property];\n\t\t    }\n\t\t    // fall back to the property value from the computed styling\n\t\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t\t    // trim whitespace that can come after the `:` in css\n\t\t    // example: padding: 2px -> \" 2px\"\n\t\t    return value.trim();\n\t\t  },\n\t\t\n\t\t  // given an element and a classString, replaces\n\t\t  // the element's class with the provided classString and adds\n\t\t  // any necessary ShadyCSS static and property based scoping selectors\n\t\t  // NOTE: this method is suitable to be called in an environment in which\n\t\t  // setAttribute('class', ...) and className setter have been overridden so\n\t\t  // it cannot rely on those methods.\n\t\t  setElementClass: function setElementClass(element, classString) {\n\t\t    var _element$classList;\n\t\t\n\t\t    // use classList to clear existing classes\n\t\t    while (element.classList.length) {\n\t\t      element.classList.remove(element.classList[0]);\n\t\t    }\n\t\t    // add user classString\n\t\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t\t    // add static scoping: scope by shadyRoot\n\t\t    var root = element.getRootNode();\n\t\t    if (root.host) {\n\t\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t\t    }\n\t\t    // add property scoping: scope by special selector\n\t\t    if (!this.nativeCss) {\n\t\t      var styleInfo = StyleInfo.get(element);\n\t\t      if (styleInfo && styleInfo.scopeSelector) {\n\t\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t\t      }\n\t\t    }\n\t\t  },\n\t\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t\t    return StyleInfo.get(node);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow['ShadyCSS'] = ShadyCSS;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t\n\t\t/*\n\t\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\t\n\t\tExample:\n\t\t<shady-style>\n\t\t  <style>\n\t\t  ...\n\t\t  </style>\n\t\t</shady-style>\n\t\t*/\n\t\t\n\t\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\t\n\t\tvar enqueued = false;\n\t\t\n\t\tvar customStyles = [];\n\t\t\n\t\tvar hookFn = null;\n\t\t\n\t\t/*\n\t\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\t\tas all the instances will boot asynchronously after page load.\n\t\t\n\t\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t\t*/\n\t\tfunction enqueueDocumentValidation() {\n\t\t  if (enqueued) {\n\t\t    return;\n\t\t  }\n\t\t  enqueued = true;\n\t\t  if (window.HTMLImports) {\n\t\t    window.HTMLImports.whenReady(validateDocument);\n\t\t  } else if (document.readyState === 'complete') {\n\t\t    requestAnimationFrame(validateDocument);\n\t\t  } else {\n\t\t    document.addEventListener('readystatechange', function () {\n\t\t      if (document.readyState === 'complete') {\n\t\t        validateDocument();\n\t\t      }\n\t\t    });\n\t\t  }\n\t\t}\n\t\t\n\t\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t\t// helps ensure that the first run of validateDocument will actually\n\t\t// have access to all the custom-style's created via loading imports.\n\t\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t\t// then the enqueue immediately calls validateDocument and work that could be\n\t\t// batched is not.\n\t\tenqueueDocumentValidation();\n\t\t\n\t\tfunction validateDocument() {\n\t\t  if (enqueued) {\n\t\t    ShadyCSS$1.updateStyles();\n\t\t    enqueued = false;\n\t\t  }\n\t\t}\n\t\t\n\t\tfunction CustomStyle() {\n\t\t  /*\n\t\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t\t  CustomElement polyfill replacement that can be `.call`ed\n\t\t  */\n\t\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t\t  customStyles.push(self);\n\t\t  enqueueDocumentValidation();\n\t\t  return self;\n\t\t}\n\t\t\n\t\tObject.defineProperties(CustomStyle, {\n\t\t  /*\n\t\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t\t   The function must take a <style> element as input, and return nothing.\n\t\t  */\n\t\t  processHook: {\n\t\t    get: function get() {\n\t\t      return hookFn;\n\t\t    },\n\t\t    set: function set(fn) {\n\t\t      hookFn = fn;\n\t\t      return fn;\n\t\t    }\n\t\t  },\n\t\t  _customStyles: {\n\t\t    get: function get() {\n\t\t      return customStyles;\n\t\t    }\n\t\t  },\n\t\t  _documentDirty: {\n\t\t    get: function get() {\n\t\t      return enqueued;\n\t\t    },\n\t\t    set: function set(value) {\n\t\t      enqueued = value;\n\t\t      return value;\n\t\t    }\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.findStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._findStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle._revalidateApplyShim = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    var s = customStyles[i];\n\t\t    if (s._style) {\n\t\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t\t    }\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.applyStyles = function () {\n\t\t  for (var i = 0; i < customStyles.length; i++) {\n\t\t    customStyles[i]._applyStyle();\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t\t  'constructor': {\n\t\t    value: CustomStyle,\n\t\t    configurable: true,\n\t\t    writable: true\n\t\t  }\n\t\t});\n\t\t\n\t\tCustomStyle.prototype._findStyle = function () {\n\t\t  if (!this._style) {\n\t\t    var style = this.querySelector('style');\n\t\t    if (!style) {\n\t\t      return;\n\t\t    }\n\t\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t\t    // which is referenced with __appliedElement.\n\t\t    // Also, we must copy over the attributes.\n\t\t    if (style.__appliedElement) {\n\t\t      for (var i = 0; i < style.attributes.length; i++) {\n\t\t        var attr = style.attributes[i];\n\t\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t\t      }\n\t\t    }\n\t\t    this._style = style.__appliedElement || style;\n\t\t    if (hookFn) {\n\t\t      hookFn(this._style);\n\t\t    }\n\t\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\tCustomStyle.prototype._applyStyle = function () {\n\t\t  if (this._style) {\n\t\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t\t  }\n\t\t};\n\t\t\n\t\twindow.customElements.define('custom-style', CustomStyle);\n\t\twindow['CustomStyle'] = CustomStyle;\n\t\t\n\t\t/**\n\t\t@license\n\t\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t\tCode distributed by Google as part of the polymer project is also\n\t\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t\t*/\n\t\t/*\n\t\tSmall module to load ShadyCSS and CustomStyle together\n\t\t*/\n\t\t\n\t\t}());\n\t\t\n\t\t//# sourceMappingURL=shadycss.min.js.map\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4)) :\n\t  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n\t  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n\t}(this, (function (exports,incrementalDom,root) {\n\t\n\troot = 'default' in root ? root['default'] : root;\n\t\n\tfunction keys() {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  var _ref$enumOnly = _ref.enumOnly;\n\t  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\t\n\t  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n\t  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n\t}\n\t\n\t// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n\t// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\n\tvar assign = (function (obj) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  args.forEach(function (arg) {\n\t    return keys(arg).forEach(function (name) {\n\t      return obj[name] = arg[name];\n\t    });\n\t  }); // eslint-disable-line no-return-assign\n\t  return obj;\n\t});\n\t\n\tvar empty = function (val) {\n\t  return typeof val === 'undefined' || val === null;\n\t};\n\t\n\t/**\n\t * Attributes value can only be null or string;\n\t */\n\tvar toNullOrString = function toNullOrString(val) {\n\t  return empty(val) ? null : String(val);\n\t};\n\t\n\tfunction create(def) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args.unshift({}, def);\n\t    return assign.apply(undefined, args);\n\t  };\n\t}\n\t\n\tvar array = create({\n\t  coerce: function coerce(val) {\n\t    return Array.isArray(val) ? val : empty(val) ? null : [val];\n\t  },\n\t  default: function _default() {\n\t    return [];\n\t  },\n\t  deserialize: function deserialize(val) {\n\t    return empty(val) ? null : JSON.parse(val);\n\t  },\n\t  serialize: JSON.stringify\n\t});\n\t\n\tvar boolean = create({\n\t  coerce: function coerce(val) {\n\t    return !!val;\n\t  },\n\t  default: false,\n\t  // todo: 'false' string must deserialize to false for angular 1.x to work\n\t  // This breaks one existing test.\n\t  // deserialize: val => !(val === null || val === 'false'),\n\t  deserialize: function deserialize(val) {\n\t    return !(val === null);\n\t  },\n\t  serialize: function serialize(val) {\n\t    return val ? '' : null;\n\t  }\n\t});\n\t\n\t// defaults empty to 0 and allows NaN\n\tvar zeroIfEmptyOrNumberIncludesNaN = function zeroIfEmptyOrNumberIncludesNaN(val) {\n\t  return empty(val) ? 0 : Number(val);\n\t};\n\t\n\tvar number = create({\n\t  default: 0,\n\t  coerce: zeroIfEmptyOrNumberIncludesNaN,\n\t  deserialize: zeroIfEmptyOrNumberIncludesNaN,\n\t  serialize: toNullOrString\n\t});\n\t\n\tvar string = create({\n\t  default: '',\n\t  coerce: toNullOrString,\n\t  deserialize: toNullOrString,\n\t  serialize: toNullOrString\n\t});\n\t\n\tvar prop = Object.freeze({\n\t\tcreate: create,\n\t\tarray: array,\n\t\tboolean: boolean,\n\t\tnumber: number,\n\t\tstring: string\n\t});\n\t\n\tvar connected = '____skate_connected';\n\tvar created = '____skate_created';\n\t\n\t// DEPRECATED\n\t//\n\t// This is the only \"symbol\" that must stay a string. This is because it is\n\t// relied upon across several versions. We should remove it, but ensure that\n\t// it's considered a breaking change that whatever version removes it cannot\n\t// be passed to vdom functions as tag names.\n\tvar name = '____skate_name';\n\t\n\t// Used on the Constructor\n\tvar ctorCreateInitProps = '____skate_ctor_createInitProps';\n\tvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\n\tvar ctorProps = '____skate_ctor_props';\n\tvar ctorPropsMap = '____skate_ctor_propsMap';\n\t\n\t// Used on the Element\n\tvar props = '____skate_props';\n\tvar ref$1 = '____skate_ref';\n\tvar renderer$1 = '____skate_renderer';\n\tvar rendering = '____skate_rendering';\n\tvar rendererDebounced = '____skate_rendererDebounced';\n\tvar updated$1 = '____skate_updated';\n\t\n\t// DEPRECTAED\n\t//\n\t// We should not be relying on internals for symbols as this creates version\n\t// coupling. We will move forward with platform agnostic ways of doing this.\n\t\n\t\n\tvar symbols$1 = Object.freeze({\n\t\tname: name\n\t});\n\t\n\tfunction enter(object, props) {\n\t  var saved = {};\n\t  Object.keys(props).forEach(function (key) {\n\t    saved[key] = object[key];\n\t    object[key] = props[key];\n\t  });\n\t  return saved;\n\t}\n\t\n\tfunction exit(object, saved) {\n\t  assign(object, saved);\n\t}\n\t\n\t// Decorates a function with a side effect that changes the properties of an\n\t// object during its execution, and restores them after. There is no error\n\t// handling here, if the wrapped function throws an error, properties are not\n\t// restored and all bets are off.\n\tvar propContext = function (object, props) {\n\t  return function (func) {\n\t    return function () {\n\t      var saved = enter(object, props);\n\t      var result = func.apply(undefined, arguments);\n\t      exit(object, saved);\n\t      return result;\n\t    };\n\t  };\n\t};\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\t\n\t\n\t\n\t\n\tvar asyncGenerator = function () {\n\t  function AwaitValue(value) {\n\t    this.value = value;\n\t  }\n\t\n\t  function AsyncGenerator(gen) {\n\t    var front, back;\n\t\n\t    function send(key, arg) {\n\t      return new Promise(function (resolve, reject) {\n\t        var request = {\n\t          key: key,\n\t          arg: arg,\n\t          resolve: resolve,\n\t          reject: reject,\n\t          next: null\n\t        };\n\t\n\t        if (back) {\n\t          back = back.next = request;\n\t        } else {\n\t          front = back = request;\n\t          resume(key, arg);\n\t        }\n\t      });\n\t    }\n\t\n\t    function resume(key, arg) {\n\t      try {\n\t        var result = gen[key](arg);\n\t        var value = result.value;\n\t\n\t        if (value instanceof AwaitValue) {\n\t          Promise.resolve(value.value).then(function (arg) {\n\t            resume(\"next\", arg);\n\t          }, function (arg) {\n\t            resume(\"throw\", arg);\n\t          });\n\t        } else {\n\t          settle(result.done ? \"return\" : \"normal\", result.value);\n\t        }\n\t      } catch (err) {\n\t        settle(\"throw\", err);\n\t      }\n\t    }\n\t\n\t    function settle(type, value) {\n\t      switch (type) {\n\t        case \"return\":\n\t          front.resolve({\n\t            value: value,\n\t            done: true\n\t          });\n\t          break;\n\t\n\t        case \"throw\":\n\t          front.reject(value);\n\t          break;\n\t\n\t        default:\n\t          front.resolve({\n\t            value: value,\n\t            done: false\n\t          });\n\t          break;\n\t      }\n\t\n\t      front = front.next;\n\t\n\t      if (front) {\n\t        resume(front.key, front.arg);\n\t      } else {\n\t        back = null;\n\t      }\n\t    }\n\t\n\t    this._invoke = send;\n\t\n\t    if (typeof gen.return !== \"function\") {\n\t      this.return = undefined;\n\t    }\n\t  }\n\t\n\t  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n\t    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n\t      return this;\n\t    };\n\t  }\n\t\n\t  AsyncGenerator.prototype.next = function (arg) {\n\t    return this._invoke(\"next\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.throw = function (arg) {\n\t    return this._invoke(\"throw\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.return = function (arg) {\n\t    return this._invoke(\"return\", arg);\n\t  };\n\t\n\t  return {\n\t    wrap: function (fn) {\n\t      return function () {\n\t        return new AsyncGenerator(fn.apply(this, arguments));\n\t      };\n\t    },\n\t    await: function (value) {\n\t      return new AwaitValue(value);\n\t    }\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\tvar defineProperty = function (obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\t\n\t  return obj;\n\t};\n\t\n\tvar get$1 = function get$1(object, property, receiver) {\n\t  if (object === null) object = Function.prototype;\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent === null) {\n\t      return undefined;\n\t    } else {\n\t      return get$1(parent, property, receiver);\n\t    }\n\t  } else if (\"value\" in desc) {\n\t    return desc.value;\n\t  } else {\n\t    var getter = desc.get;\n\t\n\t    if (getter === undefined) {\n\t      return undefined;\n\t    }\n\t\n\t    return getter.call(receiver);\n\t  }\n\t};\n\t\n\tvar inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\t\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/* eslint no-plusplus: 0 */\n\t\n\tvar customElements = root.customElements;\n\tvar HTMLElement = root.HTMLElement;\n\t\n\tvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\t\n\t// A stack of children that corresponds to the current function helper being\n\t// executed.\n\tvar stackChren = [];\n\t\n\tvar $skip = '__skip';\n\tvar $currentEventHandlers = '__events';\n\tvar $stackCurrentHelperProps = '__props';\n\t\n\t// The current function helper in the stack.\n\tvar stackCurrentHelper = void 0;\n\t\n\t// This is used for the Incremental DOM overrides to keep track of what args\n\t// to pass the main elementOpen() function.\n\tvar overrideArgs = void 0;\n\t\n\t// The number of levels deep after skipping a tree.\n\tvar skips = 0;\n\t\n\tvar noop = function noop() {};\n\t\n\t// Adds or removes an event listener for an element.\n\tfunction applyEvent(elem, ename, newFunc) {\n\t  var events = elem[$currentEventHandlers];\n\t\n\t  if (!events) {\n\t    events = elem[$currentEventHandlers] = {};\n\t  }\n\t\n\t  // Undefined indicates that there is no listener yet.\n\t  if (typeof events[ename] === 'undefined') {\n\t    // We only add a single listener once. Originally this was a workaround for\n\t    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n\t    // also a simpler model for binding / unbinding events because you only\n\t    // have a single handler you need to worry about and a single place where\n\t    // you only store one event handler\n\t    elem.addEventListener(ename, function (e) {\n\t      if (events[ename]) {\n\t        events[ename].call(this, e);\n\t      }\n\t    });\n\t  }\n\t\n\t  // Not undefined indicates that we have set a listener, so default to null.\n\t  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n\t}\n\t\n\tvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n\t  // Attributes that shouldn't be applied to the DOM.\n\t  key: noop,\n\t  statics: noop,\n\t\n\t  // Attributes that *must* be set via a property on all elements.\n\t  checked: incrementalDom.applyProp,\n\t  className: incrementalDom.applyProp,\n\t  disabled: incrementalDom.applyProp,\n\t  value: incrementalDom.applyProp,\n\t\n\t  // Ref handler.\n\t  ref: function ref(elem, name$$1, value) {\n\t    elem[ref$1] = value;\n\t  },\n\t\n\t\n\t  // Skip handler.\n\t  skip: function skip(elem, name$$1, value) {\n\t    if (value) {\n\t      elem[$skip] = true;\n\t    } else {\n\t      delete elem[$skip];\n\t    }\n\t  }\n\t}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n\t  var _ref = customElements.get(elem.localName) || {\n\t    props: {},\n\t    prototype: {}\n\t  };\n\t\n\t  var props$$1 = _ref.props;\n\t  var prototype = _ref.prototype;\n\t\n\t  // TODO when refactoring properties to not have to workaround the old\n\t  // WebKit bug we can remove the \"name in props\" check below.\n\t  //\n\t  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n\t  // elements that set a property that isn't explicitly specified in \"props\"\n\t  // or \"prototype\" unless it is added to the element explicitly as a\n\t  // property prior to passing the prop to the vdom function. For example, if\n\t  // it were added in a lifecycle callback because it wouldn't have been\n\t  // upgraded yet.\n\t  //\n\t  // We prefer setting props, so we do this if there's a property matching\n\t  // name that was passed. However, certain props on SVG elements are\n\t  // readonly and error when you try to set them.\n\t\n\t  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n\t    incrementalDom.applyProp(elem, name$$1, value);\n\t    return;\n\t  }\n\t\n\t  // Explicit false removes the attribute.\n\t  if (value === false) {\n\t    applyDefault(elem, name$$1);\n\t    return;\n\t  }\n\t\n\t  // Handle built-in and custom events.\n\t  if (name$$1.indexOf('on') === 0) {\n\t    var firstChar = name$$1[2];\n\t    var eventName = void 0;\n\t\n\t    if (firstChar === '-') {\n\t      eventName = name$$1.substring(3);\n\t    } else if (firstChar === firstChar.toUpperCase()) {\n\t      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n\t    }\n\t\n\t    if (eventName) {\n\t      applyEvent(elem, eventName, value);\n\t      return;\n\t    }\n\t  }\n\t\n\t  applyDefault(elem, name$$1, value);\n\t}));\n\t\n\tfunction resolveTagName(name$$1) {\n\t  // We return falsy values as some wrapped IDOM functions allow empty values.\n\t  if (!name$$1) {\n\t    return name$$1;\n\t  }\n\t\n\t  // We try and return the cached tag name, if one exists.\n\t  if (name$$1[name]) {\n\t    return name$$1[name];\n\t  }\n\t\n\t  // If it's a custom element, we get the tag name by constructing it and\n\t  // caching it.\n\t  if (name$$1.prototype instanceof HTMLElement) {\n\t    // eslint-disable-next-line\n\t    var elem = new name$$1();\n\t    return name$$1[name] = elem.localName;\n\t  }\n\t\n\t  // Pass all other values through so IDOM gets what it's expecting.\n\t  return name$$1;\n\t}\n\t\n\t// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n\t// so it's the only function we need to execute in the context of our attributes.\n\tvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\t\n\tfunction elementOpenStart(tag) {\n\t  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t\n\t  overrideArgs = [tag, key, statics];\n\t}\n\t\n\tfunction elementOpenEnd() {\n\t  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n\t  overrideArgs = null;\n\t  return node;\n\t}\n\t\n\tfunction wrapIdomFunc(func) {\n\t  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\t\n\t  return function wrap() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    args[0] = resolveTagName(args[0]);\n\t    stackCurrentHelper = null;\n\t    if (typeof args[0] === 'function') {\n\t      // If we've encountered a function, handle it according to the type of\n\t      // function that is being wrapped.\n\t      stackCurrentHelper = args[0];\n\t      return tnameFuncHandler.apply(undefined, args);\n\t    } else if (stackChren.length) {\n\t      // We pass the wrap() function in here so that when it's called as\n\t      // children, it will queue up for the next stack, if there is one.\n\t      stackChren[stackChren.length - 1].push([wrap, args]);\n\t    } else {\n\t      if (func === elementOpen$1) {\n\t        if (skips) {\n\t          return ++skips;\n\t        }\n\t\n\t        var elem = func.apply(undefined, args);\n\t\n\t        if (elem[$skip]) {\n\t          ++skips;\n\t        }\n\t\n\t        return elem;\n\t      }\n\t\n\t      if (func === incrementalDom.elementClose) {\n\t        if (skips === 1) {\n\t          incrementalDom.skip();\n\t        }\n\t\n\t        // We only want to skip closing if it's not the last closing tag in the\n\t        // skipped tree because we keep the element that initiated the skpping.\n\t        if (skips && --skips) {\n\t          return;\n\t        }\n\t\n\t        var _elem = func.apply(undefined, args);\n\t        var ref$$1 = _elem[ref$1];\n\t\n\t        // We delete so that it isn't called again for the same element. If the\n\t        // ref changes, or the element changes, this will be defined again.\n\t        delete _elem[ref$1];\n\t\n\t        // Execute the saved ref after esuring we've cleand up after it.\n\t        if (typeof ref$$1 === 'function') {\n\t          ref$$1(_elem);\n\t        }\n\t\n\t        return _elem;\n\t      }\n\t\n\t      // We must call elementOpenStart and elementOpenEnd even if we are\n\t      // skipping because they queue up attributes and then call elementClose.\n\t      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n\t        return func.apply(undefined, args);\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction newAttr() {\n\t  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t    args[_key2] = arguments[_key2];\n\t  }\n\t\n\t  if (stackCurrentHelper) {\n\t    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n\t  } else if (stackChren.length) {\n\t    stackChren[stackChren.length - 1].push([newAttr, args]);\n\t  } else {\n\t    overrideArgs.push(args[0]);\n\t    overrideArgs.push(args[1]);\n\t  }\n\t}\n\t\n\tfunction stackOpen(tname, key, statics) {\n\t  var props$$1 = { key: key, statics: statics };\n\t\n\t  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n\t    attrs[_key3 - 3] = arguments[_key3];\n\t  }\n\t\n\t  for (var a = 0; a < attrs.length; a += 2) {\n\t    props$$1[attrs[a]] = attrs[a + 1];\n\t  }\n\t  tname[$stackCurrentHelperProps] = props$$1;\n\t  stackChren.push([]);\n\t}\n\t\n\tfunction stackClose(tname) {\n\t  var chren = stackChren.pop();\n\t  var props$$1 = tname[$stackCurrentHelperProps];\n\t  delete tname[$stackCurrentHelperProps];\n\t  var elemOrFn = tname(props$$1, function () {\n\t    return chren.forEach(function (args) {\n\t      return args[0].apply(args, toConsumableArray(args[1]));\n\t    });\n\t  });\n\t  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n\t}\n\t\n\t// Incremental DOM overrides\n\t// -------------------------\n\t\n\t// We must override internal functions that call internal Incremental DOM\n\t// functions because we can't override the internal references. This means\n\t// we must roughly re-implement their behaviour. Luckily, they're fairly\n\t// simple.\n\tvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\n\tvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\t\n\t// Standard open / closed overrides don't need to reproduce internal behaviour\n\t// because they are the ones referenced from *End and *Start.\n\tvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\n\tvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\t\n\t// Ensure we call our overridden functions instead of the internal ones.\n\tfunction newElementVoid(tag) {\n\t  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n\t    args[_key4 - 1] = arguments[_key4];\n\t  }\n\t\n\t  newElementOpen.apply(undefined, [tag].concat(args));\n\t  return newElementClose(tag);\n\t}\n\t\n\t// Text override ensures their calls can queue if using function helpers.\n\tvar newText = wrapIdomFunc(incrementalDom.text);\n\t\n\t// Convenience function for declaring an Incremental DOM element using\n\t// hyperscript-style syntax.\n\tfunction element(tname, attrs) {\n\t  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\t\n\t  // If attributes are a function, then they should be treated as children.\n\t\n\t  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n\t    chren[_key5 - 2] = arguments[_key5];\n\t  }\n\t\n\t  if (atype === 'function' || atype === 'string' || atype === 'number') {\n\t    chren.unshift(attrs);\n\t  }\n\t\n\t  // Ensure the attributes are an object. Null is considered an object so we\n\t  // have to test for this explicitly.\n\t  if (attrs === null || atype !== 'object') {\n\t    attrs = {};\n\t  }\n\t\n\t  // We open the element so we can set attrs after.\n\t  newElementOpenStart(tname, attrs.key, attrs.statics);\n\t\n\t  // Delete so special attrs don't actually get set.\n\t  delete attrs.key;\n\t  delete attrs.statics;\n\t\n\t  // Set attributes.\n\t  Object.keys(attrs).forEach(function (name$$1) {\n\t    return newAttr(name$$1, attrs[name$$1]);\n\t  });\n\t\n\t  // Close before we render the descendant tree.\n\t  newElementOpenEnd(tname);\n\t\n\t  chren.forEach(function (ch) {\n\t    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n\t    if (ctype === 'function') {\n\t      ch();\n\t    } else if (ctype === 'string' || ctype === 'number') {\n\t      newText(ch);\n\t    } else if (Array.isArray(ch)) {\n\t      ch.forEach(function (sch) {\n\t        return sch();\n\t      });\n\t    }\n\t  });\n\t\n\t  return newElementClose(tname);\n\t}\n\t\n\t// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n\t// transpiles for JSX (React.createElement() / h).\n\tfunction builder() {\n\t  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t    tags[_key6] = arguments[_key6];\n\t  }\n\t\n\t  if (tags.length === 0) {\n\t    return function () {\n\t      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n\t        args[_key7] = arguments[_key7];\n\t      }\n\t\n\t      return element.bind.apply(element, [null].concat(args));\n\t    };\n\t  }\n\t  return tags.map(function (tag) {\n\t    return function () {\n\t      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n\t        args[_key8] = arguments[_key8];\n\t      }\n\t\n\t      return element.bind.apply(element, [null, tag].concat(args));\n\t    };\n\t  });\n\t}\n\t\n\t\n\t\n\tvar vdom = Object.freeze({\n\t\telement: element,\n\t\tbuilder: builder,\n\t\tattr: newAttr,\n\t\telementClose: newElementClose,\n\t\telementOpen: newElementOpen,\n\t\telementOpenEnd: newElementOpenEnd,\n\t\telementOpenStart: newElementOpenStart,\n\t\telementVoid: newElementVoid,\n\t\ttext: newText\n\t});\n\t\n\tfunction createSymbol(description) {\n\t  return typeof Symbol === 'function' ? Symbol(description) : description;\n\t}\n\t\n\tvar data = function (element) {\n\t  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\t\n\t  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n\t};\n\t\n\tvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n\t];\n\tvar native = (function (fn) {\n\t  return nativeHints.map(function (hint) {\n\t    return (fn || '').toString().indexOf([hint]) > -1;\n\t  }).reduce(function (a, b) {\n\t    return a || b;\n\t  });\n\t});\n\t\n\tvar MutationObserver = root.MutationObserver;\n\t\n\t\n\tfunction microtaskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var i = 0;\n\t  var cbArgs = [];\n\t  var elem = document.createElement('span');\n\t  var observer = new MutationObserver(function () {\n\t    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t    scheduled = false;\n\t    cbArgs = null;\n\t  });\n\t\n\t  observer.observe(elem, { childList: true });\n\t\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      elem.textContent = '' + i;\n\t      i += 1;\n\t    }\n\t  };\n\t}\n\t\n\t// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n\t// polyfill requires that the element be in the document to trigger Mutation\n\t// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n\t//\n\t// The soonest we can set the timeout for in IE is 1 as they have issues when\n\t// setting to 0.\n\tfunction taskDebounce(cbFunc) {\n\t  var scheduled = false;\n\t  var cbArgs = [];\n\t  return function () {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    cbArgs = args;\n\t    if (!scheduled) {\n\t      scheduled = true;\n\t      setTimeout(function () {\n\t        scheduled = false;\n\t        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n\t      }, 1);\n\t    }\n\t  };\n\t}\n\tvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\t\n\tvar isFunction = function isFunction(val) {\n\t  return typeof val === 'function';\n\t};\n\tvar isUndefined = function isUndefined(val) {\n\t  return typeof val === 'undefined';\n\t};\n\t\n\t/**\n\t * @internal\n\t * Attributes Manager\n\t *\n\t * Postpones attributes updates until when connected.\n\t */\n\t\n\tvar AttributesManager = function () {\n\t  function AttributesManager(elem) {\n\t    classCallCheck(this, AttributesManager);\n\t\n\t    this.elem = elem;\n\t    this.connected = false;\n\t    this.pendingValues = {};\n\t    this.lastSetValues = {};\n\t  }\n\t\n\t  /**\n\t   * Called from disconnectedCallback\n\t   */\n\t\n\t\n\t  createClass(AttributesManager, [{\n\t    key: 'suspendAttributesUpdates',\n\t    value: function suspendAttributesUpdates() {\n\t      this.connected = false;\n\t    }\n\t\n\t    /**\n\t     * Called from connectedCallback\n\t     */\n\t\n\t  }, {\n\t    key: 'resumeAttributesUpdates',\n\t    value: function resumeAttributesUpdates() {\n\t      var _this = this;\n\t\n\t      this.connected = true;\n\t      var names = Object.keys(this.pendingValues);\n\t      names.forEach(function (name) {\n\t        var value = _this.pendingValues[name];\n\t        // Skip if already cleared\n\t        if (!isUndefined(value)) {\n\t          delete _this.pendingValues[name];\n\t          _this._syncAttrValue(name, value);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns true if the value is different from the one set internally\n\t     * using setAttrValue()\n\t     */\n\t\n\t  }, {\n\t    key: 'onAttributeChanged',\n\t    value: function onAttributeChanged(name, value) {\n\t      value = toNullOrString(value);\n\t\n\t      // A new attribute value voids the pending one\n\t      this._clearPendingValue(name);\n\t\n\t      var changed = this.lastSetValues[name] !== value;\n\t      this.lastSetValues[name] = value;\n\t      return changed;\n\t    }\n\t\n\t    /**\n\t     * Updates or removes the attribute if value === null.\n\t     *\n\t     * When the component is not connected the value is saved and\n\t     * the attribute is only updated when the component is re-connected.\n\t     */\n\t\n\t  }, {\n\t    key: 'setAttrValue',\n\t    value: function setAttrValue(name, value) {\n\t      value = toNullOrString(value);\n\t\n\t      this.lastSetValues[name] = value;\n\t\n\t      if (this.connected) {\n\t        this._clearPendingValue(name);\n\t        this._syncAttrValue(name, value);\n\t      } else {\n\t        this.pendingValues[name] = value;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_syncAttrValue',\n\t    value: function _syncAttrValue(name, value) {\n\t      var currAttrValue = toNullOrString(this.elem.getAttribute(name));\n\t      if (value !== currAttrValue) {\n\t        if (value === null) {\n\t          this.elem.removeAttribute(name);\n\t        } else {\n\t          this.elem.setAttribute(name, value);\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_clearPendingValue',\n\t    value: function _clearPendingValue(name) {\n\t      if (name in this.pendingValues) {\n\t        delete this.pendingValues[name];\n\t      }\n\t    }\n\t  }]);\n\t  return AttributesManager;\n\t}();\n\t\n\t// Only used by getAttrMgr\n\t\n\t\n\tvar $attributesMgr = '____skate_attributesMgr';\n\t\n\t/**\n\t * @internal\n\t * Returns attribute manager instance for the given Component\n\t */\n\tfunction getAttrMgr(elem) {\n\t  var mgr = elem[$attributesMgr];\n\t  if (!mgr) {\n\t    mgr = new AttributesManager(elem);\n\t    elem[$attributesMgr] = mgr;\n\t  }\n\t  return mgr;\n\t}\n\t\n\tvar getOwnPropertyDescriptors = function () {\n\t  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  return keys(obj).reduce(function (prev, curr) {\n\t    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t    return prev;\n\t  }, {});\n\t};\n\t\n\tvar dashCase = function (str) {\n\t  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t    var dash = !one || idx % 2 === 0 ? '' : '-';\n\t    return '' + one + dash + two.toLowerCase();\n\t  });\n\t};\n\t\n\tfunction error$1(message) {\n\t  var DEBUG = root.DEBUG;\n\t\n\t  if (!isUndefined(DEBUG) && DEBUG) {\n\t    console.error(message);\n\t  } else {\n\t    throw new Error(message);\n\t  }\n\t}\n\t\n\t/**\n\t * @internal\n\t * Property Definition\n\t *\n\t * Internal meta data and strategies for a property.\n\t * Created from the options of a PropOptions config object.\n\t *\n\t * Once created a PropDefinition should be treated as immutable and final.\n\t * 'getPropsMap' function memoizes PropDefinitions by Component's Class.\n\t *\n\t * The 'attribute' option is normalized into the 'attrName' property.\n\t */\n\t\n\tvar PropDefinition = function () {\n\t  function PropDefinition(nameOrSymbol, propOptions) {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, PropDefinition);\n\t\n\t    this._name = nameOrSymbol;\n\t\n\t    propOptions = propOptions || {};\n\t\n\t    // default 'attrName': no linked attribute\n\t    this.attrName = null;\n\t\n\t    // default 'coerce': identity function\n\t    this.coerce = function (value) {\n\t      return value;\n\t    };\n\t\n\t    // default 'default': set prop to 'null'\n\t    this.default = null;\n\t\n\t    // default 'deserialize': return attribute's value (string or null)\n\t    this.deserialize = function (value) {\n\t      return value;\n\t    };\n\t\n\t    // default 'get': no function\n\t    this.get = null;\n\t\n\t    // 'initial' default: unspecified\n\t    // 'initial' option is truly optional and it cannot be initialized.\n\t    // Its presence is tested using: ('initial' in propDef)\n\t\n\t    // 'serialize' default: return string value or null\n\t    this.serialize = function (value) {\n\t      return empty(value) ? null : String(value);\n\t    };\n\t\n\t    // default 'set': no function\n\t    this.set = null;\n\t\n\t    // Note: option key is always a string (no symbols here)\n\t    Object.keys(propOptions).forEach(function (option) {\n\t      var optVal = propOptions[option];\n\t\n\t      // Only accept documented options and perform minimal input validation.\n\t      switch (option) {\n\t        case 'attribute':\n\t          _this.attrName = resolveAttrName(optVal, nameOrSymbol);\n\t          break;\n\t        case 'coerce':\n\t        case 'deserialize':\n\t        case 'get':\n\t        case 'serialize':\n\t        case 'set':\n\t          if (isFunction(optVal)) {\n\t            _this[option] = optVal;\n\t          } else {\n\t            error$1(option + ' must be a function.');\n\t          }\n\t          break;\n\t        case 'default':\n\t        case 'initial':\n\t          _this[option] = optVal;\n\t          break;\n\t        default:\n\t          error$1(option + ' is not a valid option. Options are: attribute, initial, default, coerce, deserialize, serialize.');\n\t          break;\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(PropDefinition, [{\n\t    key: 'name',\n\t    get: function get() {\n\t      return this._name;\n\t    }\n\t  }]);\n\t  return PropDefinition;\n\t}();\n\t\n\tfunction resolveAttrName(attrOption, nameOrSymbol) {\n\t  if ((typeof nameOrSymbol === 'undefined' ? 'undefined' : _typeof(nameOrSymbol)) === 'symbol') {\n\t    error$1(nameOrSymbol.toString() + ' symbol property cannot have an attribute.');\n\t  } else {\n\t    if (attrOption === true) {\n\t      return dashCase(String(nameOrSymbol));\n\t    }\n\t    if (typeof attrOption === 'string') {\n\t      return attrOption;\n\t    }\n\t  }\n\t  return null;\n\t}\n\t\n\t/**\n\t * This is needed to avoid IE11 \"stack size errors\" when creating\n\t * a new property on the constructor of an HTMLElement\n\t */\n\tfunction setCtorNativeProperty(Ctor, propName, value) {\n\t  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n\t}\n\t\n\t/**\n\t * Memoizes a map of PropDefinition for the given component class.\n\t * Keys in the map are the properties name which can a string or a symbol.\n\t *\n\t * The map is created from the result of: static get props\n\t */\n\tfunction getPropsMap(Ctor) {\n\t  // Must be defined on constructor and not from a superclass\n\t  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n\t    (function () {\n\t      var props$$1 = Ctor.props || {};\n\t\n\t      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n\t        result[propNameOrSymbol] = new PropDefinition(propNameOrSymbol, props$$1[propNameOrSymbol]);\n\t        return result;\n\t      }, {});\n\t      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n\t    })();\n\t  }\n\t\n\t  return Ctor[ctorPropsMap];\n\t}\n\t\n\tfunction get$2(elem) {\n\t  var props$$1 = {};\n\t\n\t  keys(getPropsMap(elem.constructor)).forEach(function (propNameOrSymbol) {\n\t    props$$1[propNameOrSymbol] = elem[propNameOrSymbol];\n\t  });\n\t\n\t  return props$$1;\n\t}\n\t\n\tfunction set$2(elem, newProps) {\n\t  assign(elem, newProps);\n\t  if (elem[renderer$1]) {\n\t    elem[renderer$1]();\n\t  }\n\t}\n\t\n\tvar props$1 = function (elem, newProps) {\n\t  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n\t};\n\t\n\tfunction getDefaultValue(elem, propDef) {\n\t  return typeof propDef.default === 'function' ? propDef.default(elem, { name: propDef.name }) : propDef.default;\n\t}\n\t\n\tfunction getInitialValue(elem, propDef) {\n\t  return typeof propDef.initial === 'function' ? propDef.initial(elem, { name: propDef.name }) : propDef.initial;\n\t}\n\t\n\tfunction getPropData(elem, name) {\n\t  var elemData = data(elem, 'props');\n\t  return elemData[name] || (elemData[name] = {});\n\t}\n\t\n\tfunction createNativePropertyDescriptor(propDef) {\n\t  var nameOrSymbol = propDef.name;\n\t\n\t  var prop = {\n\t    configurable: true,\n\t    enumerable: true\n\t  };\n\t\n\t  prop.beforeDefineProperty = function (elem) {\n\t    var propData = getPropData(elem, nameOrSymbol);\n\t    var attrName = propDef.attrName;\n\t\n\t    // Store attribute to property link.\n\t    if (attrName) {\n\t      data(elem, 'attributeLinks')[attrName] = nameOrSymbol;\n\t    }\n\t\n\t    // prop value before upgrading\n\t    var initialValue = elem[nameOrSymbol];\n\t\n\t    // Set up initial value if it wasn't specified.\n\t    var valueFromAttribute = false;\n\t    if (empty(initialValue)) {\n\t      if (attrName && elem.hasAttribute(attrName)) {\n\t        valueFromAttribute = true;\n\t        initialValue = propDef.deserialize(elem.getAttribute(attrName));\n\t      } else if ('initial' in propDef) {\n\t        initialValue = getInitialValue(elem, propDef);\n\t      } else {\n\t        initialValue = getDefaultValue(elem, propDef);\n\t      }\n\t    }\n\t\n\t    initialValue = propDef.coerce(initialValue);\n\t\n\t    propData.internalValue = initialValue;\n\t\n\t    // Reflect to attribute unless valueFromAttribute\n\t    if (!valueFromAttribute && attrName && !empty(initialValue)) {\n\t      var serializedValue = propDef.serialize(initialValue);\n\t      getAttrMgr(elem).setAttrValue(propDef.attrName, serializedValue);\n\t    }\n\t  };\n\t\n\t  prop.get = function get() {\n\t    var propData = getPropData(this, nameOrSymbol);\n\t    var internalValue = propData.internalValue;\n\t\n\t    return propDef.get ? propDef.get(this, { name: nameOrSymbol, internalValue: internalValue }) : internalValue;\n\t  };\n\t\n\t  prop.set = function set(newValue) {\n\t    var propData = getPropData(this, nameOrSymbol);\n\t\n\t    var useDefaultValue = empty(newValue);\n\t    if (useDefaultValue) {\n\t      newValue = getDefaultValue(this, propDef);\n\t    }\n\t\n\t    newValue = propDef.coerce(newValue);\n\t\n\t    if (propDef.set) {\n\t      var oldValue = propData.oldValue;\n\t\n\t\n\t      if (empty(oldValue)) {\n\t        oldValue = null;\n\t      }\n\t      var changeData = { name: nameOrSymbol, newValue: newValue, oldValue: oldValue };\n\t      propDef.set(this, changeData);\n\t    }\n\t\n\t    // Queue a re-render.\n\t    this[rendererDebounced](this);\n\t\n\t    // Update prop data so we can use it next time.\n\t    propData.internalValue = propData.oldValue = newValue;\n\t\n\t    // Link up the attribute.\n\t    if (propDef.attrName && !propData.settingProp) {\n\t      // Note: setting the prop to empty implies the default value\n\t      // and therefore no attribute should be present!\n\t      var serializedValue = useDefaultValue ? null : propDef.serialize(newValue);\n\t      getAttrMgr(this).setAttrValue(propDef.attrName, serializedValue);\n\t    }\n\t  };\n\t\n\t  return prop;\n\t}\n\t\n\tvar objectIs = (function (x, y) {\n\t  if (Object.is) {\n\t    return Object.is(x, y);\n\t  }\n\t  // SameValue algorithm\n\t  if (x === y) {\n\t    // Steps 1-5, 7-10\n\t    // Steps 6.b-6.e: +0 != -0\n\t    return x !== 0 || 1 / x === 1 / y;\n\t  } else {\n\t    // Step 6.a: NaN == NaN\n\t    return x !== x && y !== y;\n\t  }\n\t});\n\t\n\tvar HTMLElement$1 = root.HTMLElement || function () {\n\t  function _class() {\n\t    classCallCheck(this, _class);\n\t  }\n\t\n\t  return _class;\n\t}();\n\tvar _prevName = createSymbol('prevName');\n\tvar _prevOldValue = createSymbol('prevOldValue');\n\tvar _prevNewValue = createSymbol('prevNewValue');\n\t\n\tfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n\t  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n\t}\n\t\n\t// TODO remove when not catering to Safari < 10.\n\tfunction createNativePropertyDescriptors(Ctor) {\n\t  var propDefs = getPropsMap(Ctor);\n\t  return keys(propDefs).reduce(function (propDescriptors, propName) {\n\t    propDescriptors[propName] = createNativePropertyDescriptor(propDefs[propName]);\n\t    return propDescriptors;\n\t  }, {});\n\t}\n\t\n\t// TODO refactor when not catering to Safari < 10.\n\t//\n\t// We should be able to simplify this where all we do is Object.defineProperty().\n\tfunction createInitProps(Ctor) {\n\t  var propDescriptors = createNativePropertyDescriptors(Ctor);\n\t\n\t  return function (elem) {\n\t    keys(propDescriptors).forEach(function (name$$1) {\n\t      var propDescriptor = propDescriptors[name$$1];\n\t      propDescriptor.beforeDefineProperty(elem);\n\t\n\t      // We check here before defining to see if the prop was specified prior\n\t      // to upgrading.\n\t      var hasPropBeforeUpgrading = name$$1 in elem;\n\t\n\t      // This is saved prior to defining so that we can set it after it it was\n\t      // defined prior to upgrading. We don't want to invoke the getter if we\n\t      // don't need to, so we only get the value if we need to re-sync.\n\t      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\t\n\t      // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t      //\n\t      // When Webkit fixes that bug so that native property accessors can be\n\t      // retrieved, we can move defining the property to the prototype and away\n\t      // from having to do if for every instance as all other browsers support\n\t      // this.\n\t      Object.defineProperty(elem, name$$1, propDescriptor);\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We'll be removing get / set callbacks on properties. Use the\n\t      // updatedCallback() instead.\n\t      //\n\t      // We re-set the prop if it was specified prior to upgrading because we\n\t      // need to ensure set() is triggered both in polyfilled environments and\n\t      // in native where the definition may be registerd after elements it\n\t      // represents have already been created.\n\t      if (hasPropBeforeUpgrading) {\n\t        elem[name$$1] = valueBeforeUpgrading;\n\t      }\n\t    });\n\t  };\n\t}\n\t\n\tvar _class2 = function (_HTMLElement) {\n\t  inherits(_class2, _HTMLElement);\n\t  createClass(_class2, null, [{\n\t    key: 'observedAttributes',\n\t\n\t    /**\n\t     * Returns unique attribute names configured with props and\n\t     * those set on the Component constructor if any\n\t     */\n\t    get: function get() {\n\t      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n\t      var propDefs = getPropsMap(this);\n\t\n\t      // Use Object.keys to skips symbol props since they have no linked attributes\n\t      var attrsFromLinkedProps = Object.keys(propDefs).map(function (propName) {\n\t        return propDefs[propName].attrName;\n\t      }).filter(Boolean);\n\t\n\t      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n\t      return all.filter(function (item, index) {\n\t        return all.indexOf(item) === index;\n\t      });\n\t    },\n\t    set: function set(value) {\n\t      value = Array.isArray(value) ? value : [];\n\t      setCtorNativeProperty(this, 'observedAttributes', value);\n\t    }\n\t\n\t    // Returns superclass props overwritten with this Component props\n\t\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n\t    },\n\t    set: function set(value) {\n\t      setCtorNativeProperty(this, ctorProps, value);\n\t    }\n\t\n\t    // Passing args is designed to work with document-register-element. It's not\n\t    // necessary for the webcomponents/custom-element polyfill.\n\t\n\t  }]);\n\t\n\t  function _class2() {\n\t    var _ref;\n\t\n\t    classCallCheck(this, _class2);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var _this = possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\n\t\n\t    var constructor = _this.constructor;\n\t\n\t    // Used for the ready() function so it knows when it can call its callback.\n\t\n\t    _this[created] = true;\n\t\n\t    // TODO refactor to not cater to Safari < 10. This means we can depend on\n\t    // built-in property descriptors.\n\t    // Must be defined on constructor and not from a superclass\n\t    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n\t      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n\t    }\n\t\n\t    // Set up a renderer that is debounced for property sets to call directly.\n\t    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\t\n\t    // Set up property lifecycle.\n\t    var propDefsCount = keys(getPropsMap(constructor)).length;\n\t    if (propDefsCount && constructor[ctorCreateInitProps]) {\n\t      constructor[ctorCreateInitProps](_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static render()\n\t    // Note that renderCallback is an optional method!\n\t    if (!_this.renderCallback && constructor.render) {\n\t      _this.renderCallback = constructor.render.bind(constructor, _this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // static created()\n\t    //\n\t    // Props should be set up before calling this.\n\t    var created$$1 = constructor.created;\n\t\n\t    if (isFunction(created$$1)) {\n\t      created$$1(_this);\n\t    }\n\t\n\t    // DEPRECATED\n\t    //\n\t    // Feature has rarely been used.\n\t    //\n\t    // Created should be set before invoking the ready listeners.\n\t    var elemData = data(_this);\n\t    var readyCallbacks = elemData.readyCallbacks;\n\t    if (readyCallbacks) {\n\t      readyCallbacks.forEach(function (cb) {\n\t        return cb(_this);\n\t      });\n\t      delete elemData.readyCallbacks;\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  // Custom Elements v1\n\t\n\t\n\t  createClass(_class2, [{\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      // Reflect attributes pending values\n\t      getAttrMgr(this).resumeAttributesUpdates();\n\t\n\t      // Used to check whether or not the component can render.\n\t      this[connected] = true;\n\t\n\t      // Render!\n\t      this[rendererDebounced]();\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static attached()\n\t      var attached = this.constructor.attached;\n\t\n\t      if (isFunction(attached)) {\n\t        attached(this);\n\t      }\n\t\n\t      // DEPRECATED\n\t      //\n\t      // We can remove this once all browsers support :defined.\n\t      this.setAttribute('defined', '');\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'disconnectedCallback',\n\t    value: function disconnectedCallback() {\n\t      // Suspend updating attributes until re-connected\n\t      getAttrMgr(this).suspendAttributesUpdates();\n\t\n\t      // Ensures the component can't be rendered while disconnected.\n\t      this[connected] = false;\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static detached()\n\t      var detached = this.constructor.detached;\n\t\n\t      if (isFunction(detached)) {\n\t        detached(this);\n\t      }\n\t    }\n\t\n\t    // Custom Elements v1\n\t\n\t  }, {\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n\t      // Polyfill calls this twice.\n\t      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n\t        return;\n\t      }\n\t\n\t      // Set data so we can prevent double calling if the polyfill.\n\t      this[_prevName] = name$$1;\n\t      this[_prevOldValue] = oldValue;\n\t      this[_prevNewValue] = newValue;\n\t\n\t      var propNameOrSymbol = data(this, 'attributeLinks')[name$$1];\n\t      if (propNameOrSymbol) {\n\t        var changedExternally = getAttrMgr(this).onAttributeChanged(name$$1, newValue);\n\t        if (changedExternally) {\n\t          // Sync up the property.\n\t          var propDef = getPropsMap(this.constructor)[propNameOrSymbol];\n\t          var newPropVal = newValue !== null && propDef.deserialize ? propDef.deserialize(newValue) : newValue;\n\t\n\t          var propData = data(this, 'props')[propNameOrSymbol];\n\t          propData.settingProp = true;\n\t          this[propNameOrSymbol] = newPropVal;\n\t          propData.settingProp = false;\n\t        }\n\t      }\n\t\n\t      // DEPRECATED\n\t      //\n\t      // static attributeChanged()\n\t      var attributeChanged = this.constructor.attributeChanged;\n\t\n\t      if (isFunction(attributeChanged)) {\n\t        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n\t      }\n\t    }\n\t\n\t    // Skate\n\t\n\t  }, {\n\t    key: 'updatedCallback',\n\t    value: function updatedCallback(prevProps) {\n\t      return this.constructor.updated(this, prevProps);\n\t    }\n\t\n\t    // Skate\n\t\n\t  }, {\n\t    key: 'renderedCallback',\n\t    value: function renderedCallback() {\n\t      return this.constructor.rendered(this);\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // Maps to the static renderer() callback. That logic should be moved here\n\t    // when that is finally removed.\n\t    // todo: finalize how to support different rendering strategies.\n\t\n\t  }, {\n\t    key: 'rendererCallback',\n\t    value: function rendererCallback() {\n\t      // todo: cannot move code here because tests expects renderer function to still exist on constructor!\n\t      return this.constructor.renderer(this);\n\t    }\n\t\n\t    // Skate\n\t    // @internal\n\t    // Invokes the complete render lifecycle.\n\t\n\t  }, {\n\t    key: renderer$1,\n\t    value: function value() {\n\t      if (this[rendering] || !this[connected]) {\n\t        return;\n\t      }\n\t\n\t      // Flag as rendering. This prevents anything from trying to render - or\n\t      // queueing a render - while there is a pending render.\n\t      this[rendering] = true;\n\t      if (this[updated$1]() && isFunction(this.renderCallback)) {\n\t        this.rendererCallback();\n\t        this.renderedCallback();\n\t      }\n\t\n\t      this[rendering] = false;\n\t    }\n\t\n\t    // Skate\n\t    // @internal\n\t    // Calls the updatedCallback() with previous props.\n\t\n\t  }, {\n\t    key: updated$1,\n\t    value: function value() {\n\t      var prevProps = this[props];\n\t      this[props] = props$1(this);\n\t      return this.updatedCallback(prevProps);\n\t    }\n\t\n\t    // Skate\n\t\n\t  }], [{\n\t    key: 'extend',\n\t    value: function extend() {\n\t      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\t\n\t      // Create class for the user.\n\t      var Ctor = function (_Base) {\n\t        inherits(Ctor, _Base);\n\t\n\t        function Ctor() {\n\t          classCallCheck(this, Ctor);\n\t          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n\t        }\n\t\n\t        return Ctor;\n\t      }(Base);\n\t\n\t      // For inheriting from the object literal.\n\t\n\t\n\t      var opts = getOwnPropertyDescriptors(definition);\n\t      var prot = getOwnPropertyDescriptors(definition.prototype);\n\t\n\t      // Prototype is non configurable (but is writable).\n\t      delete opts.prototype;\n\t\n\t      // Pass on static and instance members from the definition.\n\t      Object.defineProperties(Ctor, opts);\n\t      Object.defineProperties(Ctor.prototype, prot);\n\t\n\t      return Ctor;\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Stubbed in case any subclasses are calling it.\n\t\n\t  }, {\n\t    key: 'rendered',\n\t    value: function rendered() {}\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to rendererCallback() before removing.\n\t\n\t  }, {\n\t    key: 'renderer',\n\t    value: function renderer(elem) {\n\t      if (!elem.shadowRoot) {\n\t        elem.attachShadow({ mode: 'open' });\n\t      }\n\t      incrementalDom.patchInner(elem.shadowRoot, function () {\n\t        var possibleFn = elem.renderCallback(elem);\n\t        if (isFunction(possibleFn)) {\n\t          possibleFn();\n\t        } else if (Array.isArray(possibleFn)) {\n\t          possibleFn.forEach(function (fn) {\n\t            if (isFunction(fn)) {\n\t              fn();\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    // Skate\n\t    //\n\t    // DEPRECATED\n\t    //\n\t    // Move this to updatedCallback() before removing.\n\t\n\t  }, {\n\t    key: 'updated',\n\t    value: function updated(elem, prevProps) {\n\t      // short-circuits if this is the first time\n\t      if (!prevProps) {\n\t        return true;\n\t      }\n\t\n\t      // Use getAllKeys to include all props names and Symbols\n\t      var allKeys = keys(prevProps);\n\t\n\t      // Use classic loop because 'for ... of' skips symbols\n\t      for (var i = 0; i < allKeys.length; i++) {\n\t        var nameOrSymbol = allKeys[i];\n\t\n\t        // Object.is (NaN is equal NaN)\n\t        if (!objectIs(prevProps[nameOrSymbol], elem[nameOrSymbol])) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t  }]);\n\t  return _class2;\n\t}(HTMLElement$1);\n\t\n\tfunction uniqueId(prefix) {\n\t  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n\t  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n\t    var r = Math.random() * 16 | 0;\n\t    // eslint-disable-next-line no-mixed-operators\n\t    var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t    return v.toString(16);\n\t  });\n\t  return (prefix || 'x') + '-' + rand;\n\t}\n\t\n\tvar define = function () {\n\t  var customElements = root.customElements;\n\t\n\t  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t    args[_key] = arguments[_key];\n\t  }\n\t\n\t  var name$$1 = args[0];\n\t  var Ctor = args[1];\n\t\n\t\n\t  if (!customElements) {\n\t    throw new Error('Skate requires native custom element support or a polyfill.');\n\t  }\n\t\n\t  // Support passing an anonymous definition.\n\t  if (args.length === 1) {\n\t    // We are checking string for now, but once we remove the ability to pass\n\t    // an object literal, we can change this to check \"function\" and invert the\n\t    // blocks of logic.\n\t    if (typeof name$$1 === 'string') {\n\t      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n\t    } else {\n\t      Ctor = name$$1;\n\t      name$$1 = uniqueId();\n\t    }\n\t  }\n\t\n\t  // Ensure there's no conflicts.\n\t  if (customElements.get(name$$1)) {\n\t    name$$1 = uniqueId(name$$1);\n\t  }\n\t\n\t  // DEPRECATED\n\t  //\n\t  // Object literals.\n\t  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n\t    Ctor = _class2.extend(Ctor);\n\t  }\n\t\n\t  // This allows us to check this before instantiating the custom element to\n\t  // find its name from the constructor in the vdom module, thus improving\n\t  // performance but still falling back to a robust method.\n\t  Ctor[name] = name$$1;\n\t\n\t  // Sipmle define. Not supporting customised built-ins yet.\n\t  customElements.define(name$$1, Ctor);\n\t\n\t  // The spec doesn't return but this allows for a simpler, more concise API.\n\t  return Ctor;\n\t};\n\t\n\tvar Event = function (TheEvent) {\n\t  if (TheEvent) {\n\t    try {\n\t      new TheEvent('emit-init'); // eslint-disable-line no-new\n\t    } catch (e) {\n\t      return undefined;\n\t    }\n\t  }\n\t  return TheEvent;\n\t}(root.Event);\n\t\n\tfunction createCustomEvent(name) {\n\t  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var detail = opts.detail;\n\t\n\t  delete opts.detail;\n\t\n\t  var e = void 0;\n\t  if (Event) {\n\t    e = new Event(name, opts);\n\t    Object.defineProperty(e, 'detail', { value: detail });\n\t  } else {\n\t    e = document.createEvent('CustomEvent');\n\t    Object.defineProperty(e, 'composed', { value: opts.composed });\n\t    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n\t  }\n\t  return e;\n\t}\n\t\n\tvar emit = function (elem, name) {\n\t  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (opts.bubbles === undefined) {\n\t    opts.bubbles = true;\n\t  }\n\t  if (opts.cancelable === undefined) {\n\t    opts.cancelable = true;\n\t  }\n\t  if (opts.composed === undefined) {\n\t    opts.composed = true;\n\t  }\n\t  return elem.dispatchEvent(createCustomEvent(name, opts));\n\t};\n\t\n\tfunction getValue(elem) {\n\t  var type = elem.type;\n\t  if (type === 'checkbox' || type === 'radio') {\n\t    return elem.checked ? elem.value || true : false;\n\t  }\n\t  return elem.value;\n\t}\n\t\n\tvar link = function (elem, target) {\n\t  return function (e) {\n\t    var value = getValue(e.target);\n\t    var localTarget = target || e.target.name || 'value';\n\t\n\t    if (localTarget.indexOf('.') > -1) {\n\t      var parts = localTarget.split('.');\n\t      var firstPart = parts[0];\n\t      var propName = parts.pop();\n\t      var obj = parts.reduce(function (prev, curr) {\n\t        return prev && prev[curr];\n\t      }, elem);\n\t\n\t      obj[propName || e.target.name] = value;\n\t      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n\t    } else {\n\t      props$1(elem, defineProperty({}, localTarget, value));\n\t    }\n\t  };\n\t};\n\t\n\tvar ready = function (elem, done) {\n\t  var info = data(elem);\n\t  if (elem[created]) {\n\t    done(elem);\n\t  } else if (info.readyCallbacks) {\n\t    info.readyCallbacks.push(done);\n\t  } else {\n\t    info.readyCallbacks = [done];\n\t  }\n\t};\n\t\n\tvar h = builder();\n\t\n\texports.Component = _class2;\n\texports.define = define;\n\texports.emit = emit;\n\texports.h = h;\n\texports.link = link;\n\texports.prop = prop;\n\texports.props = props$1;\n\texports.ready = ready;\n\texports.symbols = symbols$1;\n\texports.vdom = vdom;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=index.js.map\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function (name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function (doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function (nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function (run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function (node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function () {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function () {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function () {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function () {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function (tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function () {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function () {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function () {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function () {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function (tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function (name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function () {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function (tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function (tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function (value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict'\n\tmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n\t  (typeof global === 'object' && global.global === global && global) ||\n\t  this\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.classes = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _base = __webpack_require__(6);\n\t\n\tvar _base2 = _interopRequireDefault(_base);\n\t\n\tvar _index = __webpack_require__(8);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar _document = document,\n\t    head = _document.head;\n\t\n\tvar cssBaseStyle = document.createElement('style');\n\tvar cssAppStyle = document.createElement('style');\n\t\n\tcssBaseStyle.textContent = _base2.default.toString();\n\tcssAppStyle.textContent = _index2.default.toString();\n\t\n\thead.appendChild(cssBaseStyle);\n\thead.appendChild(cssAppStyle);\n\t\n\texports.default = _base2.default.toString() + _index2.default.toString();\n\tvar classes = exports.classes = _extends({}, _base2.default.locals, _index2.default.locals);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"hr{margin:20px 0;border:0;border-top:1px dashed #c5c5c5;border-bottom:1px dashed #f7f7f7}.cPEPub0maVFxkzbgWUVOd a{font-weight:400;text-decoration:none;color:#b83f45}.cPEPub0maVFxkzbgWUVOd a:hover{text-decoration:underline;color:#787e7e}.cPEPub0maVFxkzbgWUVOd h3,.cPEPub0maVFxkzbgWUVOd h4,.cPEPub0maVFxkzbgWUVOd h5{margin:10px 0;font-weight:500;line-height:1.2;color:#000}.cPEPub0maVFxkzbgWUVOd h3{font-size:24px}.cPEPub0maVFxkzbgWUVOd h4{font-size:18px}.cPEPub0maVFxkzbgWUVOd h5{margin-bottom:0;font-size:14px}.cPEPub0maVFxkzbgWUVOd ul{padding:0;margin:0 0 30px 25px}.cPEPub0maVFxkzbgWUVOd li{line-height:20px}.cPEPub0maVFxkzbgWUVOd p{font-size:15px;font-weight:300;line-height:1.3;margin-top:0;margin-bottom:0}#_3-nj88w-cbLlFAkd9E0Nbc{display:none}._2L69OI9oxKrr_A0PkWO2KF{border:none;margin:20px 0 60px}._2L69OI9oxKrr_A0PkWO2KF p{font-style:italic}._2L69OI9oxKrr_A0PkWO2KF p:before{content:'\\\\201C';font-size:50px;opacity:.15;position:absolute;top:-20px;left:3px}._2L69OI9oxKrr_A0PkWO2KF p:after{content:'\\\\201D';font-size:50px;opacity:.15;position:absolute;bottom:-42px;right:3px}._2L69OI9oxKrr_A0PkWO2KF footer{position:absolute;bottom:-40px;right:0}._2L69OI9oxKrr_A0PkWO2KF footer img{border-radius:3px}._2L69OI9oxKrr_A0PkWO2KF footer a{margin-left:5px;vertical-align:middle}._1nt1kCjSYEPZou23lObNdv{position:relative;padding:10px;background:rgba(0,0,0,.04);border-radius:5px}._1nt1kCjSYEPZou23lObNdv:after{content:'';position:absolute;top:100%;right:30px;border:13px solid transparent;border-top-color:rgba(0,0,0,.04)}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{position:absolute;width:272px;top:8px;left:-300px;padding:10px;border-radius:5px;background-color:hsla(0,0%,100%,.6);transition-property:left;transition-duration:.5s}@media (min-width:899px){._2vLQrIvSjobb3988bLfSTa{width:auto;padding-left:300px}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{left:8px}}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\t\"issue-count\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\t\"issueCount\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\t\"speech-bubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\t\"speechBubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\t\"learn-bar\": \"_2vLQrIvSjobb3988bLfSTa\",\n\t\t\"learnBar\": \"_2vLQrIvSjobb3988bLfSTa\"\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"body,button,html{margin:0;padding:0}button{border:0;background:none;font-size:100%;vertical-align:baseline;font-family:inherit;font-weight:inherit;color:inherit;-webkit-appearance:none;appearance:none;-webkit-font-smoothing:antialiased}body,button{-moz-osx-font-smoothing:grayscale}body{font:14px Helvetica Neue,Helvetica,Arial,sans-serif;line-height:1.4em;background:#f5f5f5;color:#4d4d4d;min-width:230px;max-width:550px;margin:0 auto;-webkit-font-smoothing:antialiased;font-weight:300}:focus{outline:0}.RBzyqGlIYFAdozfNAWX9T{display:none}._2lTeO9Nfd9StmHCibrKyDn{background:#fff;margin:130px 0 40px;position:relative;box-shadow:0 2px 4px 0 rgba(0,0,0,.2),0 25px 50px 0 rgba(0,0,0,.1)}._2lTeO9Nfd9StmHCibrKyDn input::-webkit-input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::-moz-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn h1{position:absolute;top:-155px;width:100%;font-size:100px;font-weight:100;text-align:center;color:rgba(175,47,47,.15);-webkit-text-rendering:optimizeLegibility;-moz-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility}._3RmQY0IMcqwS7R81Tj0dlC,.vdff5WcLi7yBBYDjtZljm{position:relative;margin:0;width:100%;font-size:24px;font-family:inherit;font-weight:inherit;line-height:1.4em;border:0;color:inherit;padding:6px;border:1px solid #999;box-shadow:inset 0 -1px 5px 0 rgba(0,0,0,.2);box-sizing:border-box;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.vdff5WcLi7yBBYDjtZljm{padding:16px 16px 16px 60px;border:none;background:rgba(0,0,0,.003);box-shadow:inset 0 -2px 1px rgba(0,0,0,.03)}._3dnsc4idur8-yk5Sjjq6VG{position:relative;z-index:2;border-top:1px solid #e6e6e6}label[for=toggle-all]{display:none}.DG0VaCEN4BXUysJd_tTIb{position:absolute;top:-55px;left:-12px;width:60px;height:34px;text-align:center;border:none}.DG0VaCEN4BXUysJd_tTIb:before{content:'\\\\276F';font-size:22px;color:#e6e6e6;padding:10px 27px}.DG0VaCEN4BXUysJd_tTIb:checked:before{color:#737373}._1p_AB3iiKNbxBsOlJi5CVw{margin:0;padding:0;list-style:none}._1p_AB3iiKNbxBsOlJi5CVw li{position:relative;font-size:24px;border-bottom:1px solid #ededed}._1p_AB3iiKNbxBsOlJi5CVw li:last-child{border-bottom:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm{border-bottom:none;padding:0}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm ._3RmQY0IMcqwS7R81Tj0dlC{display:block;width:506px;padding:12px 16px;margin:0 0 0 43px}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm .oksgs4_M9fAGjexFoJHTE{display:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{text-align:center;width:40px;height:auto;position:absolute;top:0;bottom:0;margin:auto 0;border:none;-webkit-appearance:none;appearance:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#ededed\\\" stroke-width=\\\"3\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:checked:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#bddad5\\\" stroke-width=\\\"3\\\"/><path fill=\\\"#5dc2af\\\" d=\\\"M72 25L42 71 27 56l-4 4 20 20 34-52z\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li label{word-break:break-all;padding:15px 60px 15px 15px;margin-left:45px;display:block;line-height:1.2;transition:color .4s}._1p_AB3iiKNbxBsOlJi5CVw li._29S5oJEhfUYjuw83RXIvg0 label{color:#d9d9d9;text-decoration:line-through}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE{display:none;position:absolute;top:0;right:10px;bottom:0;width:40px;height:40px;margin:auto 0;font-size:30px;color:#cc9a9a;margin-bottom:11px;transition:color .2s ease-out}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:hover{color:#af5b5e}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:after{content:'\\\\D7'}._1p_AB3iiKNbxBsOlJi5CVw li:hover ._3dDZq0iA7OOgE8KkLYlAeE{display:block}._1p_AB3iiKNbxBsOlJi5CVw li ._3RmQY0IMcqwS7R81Tj0dlC{display:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm:last-child{margin-bottom:-1px}.OfZp78rLkg_PWvZV9RYDG{color:#777;padding:10px 15px;height:20px;text-align:center;border-top:1px solid #e6e6e6}.OfZp78rLkg_PWvZV9RYDG:before{content:'';position:absolute;right:0;bottom:0;left:0;height:50px;overflow:hidden;box-shadow:0 1px 1px rgba(0,0,0,.2),0 8px 0 -3px #f6f6f6,0 9px 1px -3px rgba(0,0,0,.2),0 16px 0 -6px #f6f6f6,0 17px 2px -6px rgba(0,0,0,.2)}._1r5RuM5EHD-zS8b-wG0XPc{float:left;text-align:left}._1r5RuM5EHD-zS8b-wG0XPc strong{font-weight:300}._2tY47NKf597SqoScbkboy0{margin:0;padding:0;list-style:none;position:absolute;right:0;left:0}._2tY47NKf597SqoScbkboy0 li{display:inline}._2tY47NKf597SqoScbkboy0 li a{color:inherit;margin:3px;padding:3px 7px;text-decoration:none;border:1px solid transparent;border-radius:3px}._2tY47NKf597SqoScbkboy0 li a:hover{border-color:rgba(175,47,47,.1)}._2tY47NKf597SqoScbkboy0 li a.a8u8grJpMWz2FTlLtocrT{border-color:rgba(175,47,47,.2)}._1uOFz1y8zCB-ylF3BS8V7J,html ._1uOFz1y8zCB-ylF3BS8V7J:active{float:right;position:relative;line-height:20px;text-decoration:none;cursor:pointer}._1uOFz1y8zCB-ylF3BS8V7J:hover{text-decoration:underline}._3qrb6fjG3vwl0RExKf3l_q{margin:65px auto 0;color:#bfbfbf;font-size:10px;text-shadow:0 1px 0 hsla(0,0%,100%,.5);text-align:center}._3qrb6fjG3vwl0RExKf3l_q p{line-height:1}._3qrb6fjG3vwl0RExKf3l_q a{color:inherit;text-decoration:none;font-weight:400}._3qrb6fjG3vwl0RExKf3l_q a:hover{text-decoration:underline}@media screen and (-webkit-min-device-pixel-ratio:0){._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5,.DG0VaCEN4BXUysJd_tTIb{background:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{height:40px}.DG0VaCEN4BXUysJd_tTIb{-webkit-transform:rotate(90deg);transform:rotate(90deg);-webkit-appearance:none;appearance:none}}@media (max-width:430px){.OfZp78rLkg_PWvZV9RYDG{height:50px}._2tY47NKf597SqoScbkboy0{bottom:10px}}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\t\"new-todo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\t\"newTodo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\t\"toggle-all\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\t\"toggleAll\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\t\"todo-list\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\t\"todoList\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\t\"todo-count\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\t\"todoCount\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\t\"clear-completed\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\t\"clearCompleted\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\",\n\t\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\"\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// dist/index.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a8da79e1ae2cd244c1a4","/** @jsx h */\n\nimport 'skatejs-web-components';\nimport { Component, h, link, prop } from 'skatejs';\nimport css, { classes } from './style';\n\nconst { customElements } = window;\n\nfunction getCompleted (todos) {\n  return todos.filter(todo => todo.isCompleted);\n}\n\nfunction getPlural (count) {\n  return count === 1 ? '' : 's';\n}\n\nfunction getTodoMode (todo) {\n  if (todo.isEditing) {\n    return classes.editing;\n  }\n\n  if (todo.isCompleted) {\n    return classes.completed;\n  }\n\n  return '';\n}\n\nclass TodoApp extends Component {\n  static props = {\n    currentValue: prop.string(),\n    todos: prop.array()\n  }\n  handleChange = (e) => {\n    const { todos } = this;\n    const { target, target: { checked }} = e;\n    const todoIndex = parseFloat(target.getAttribute('data-todo-index'));\n    this.todos = todos.map((todo, currentTodoIndex) => {\n      if (currentTodoIndex === todoIndex) {\n        todo.isCompleted = checked;\n      }\n      return todo;\n    });\n  }\n  handleClear = () => {\n    this.todos = this.todos.filter(todo => !todo.isCompleted);\n  }\n  handleRemove = (e) => {\n    const todoIndex = parseFloat(e.target.getAttribute('data-todo-index'));\n    e.preventDefault();\n    this.todos = this.todos.filter((todo, currentTodoIndex) => currentTodoIndex !== todoIndex);\n  }\n  handleSubmit = (e) => {\n    e.preventDefault();\n    this.todos = this.todos.concat({\n      isCompleted: false,\n      isEditing: false,\n      description: this.currentValue\n    });\n    this.currentValue = '';\n  }\n  handleToggle = (e) => {\n    const { target: { checked } } = e;\n    this.todos = this.todos.map(todo => {\n      todo.isCompleted = checked;\n      return todo;\n    });\n  }\n  renderCallback ({\n    currentValue,\n    handleChange,\n    handleClear,\n    handleRemove,\n    handleToggle,\n    handleSubmit,\n    todos\n  }) {\n    const { length: todosLength } = todos;\n    const { length: todosCompletedLength } = getCompleted(todos);\n    const incompleteTodosLength = todosLength - todosCompletedLength;\n\n    return [\n      <style>{css}</style>,\n      <section class={classes.todoapp}>\n        <header class={classes.header}>\n          <h1>todos</h1>\n          <form onSubmit={handleSubmit}>\n            <input\n              autofocus\n              class={classes.newTodo}\n              name=\"currentValue\"\n              onKeyup={link(this)}\n              placeholder='What needs to be done?'\n              value={currentValue}\n            />\n          </form>\n        </header>\n\n        {todosLength ? (\n          <section class={classes.main}>\n            <input\n              class={classes.toggleAll} type='checkbox'\n              onChange={handleToggle}\n            />\n            <label for='toggle-all'>Mark all as complete</label>\n            <ul class={classes.todoList}>\n              {todos.map((todo, todoIndex) => (\n                <li class={getTodoMode(todo)}>\n                  <div class={classes.view}>\n                    <input\n                      class={classes.toggle}\n                      checked={todo.isCompleted}\n                      data-todo-index={todoIndex}\n                      onChange={handleChange}\n                      type='checkbox'\n                    />\n                    <label>{todo.description}</label>\n                    <button\n                      class={classes.destroy}\n                      data-todo-index={todoIndex}\n                      onClick={handleRemove}\n                    />\n                  </div>\n                  <input class={classes.edit} value='Create a TodoMVC template' />\n                </li>\n              ))}\n            </ul>\n          </section>\n        ) : ''}\n\n        {todosLength ? (\n          <footer class={classes.footer}>\n            <span class={classes.todoCount}>\n              <strong>{incompleteTodosLength}</strong>\n              {` item${getPlural(incompleteTodosLength)} left`}\n            </span>\n\n            {/*\n              Remove this if you don't implement routing\n              TODO should we anyways?\n              <ul class={classes.filters}>\n                <li>\n                  <a class={classes.selected} href='#/'>All</a>\n                </li>\n                <li>\n                  <a href='#/active'>Active</a>\n                </li>\n                <li>\n                  <a href='#/completed'>Completed</a>\n                </li>\n              </ul>\n            */}\n\n            {todosCompletedLength ? (\n              <button\n                class={classes.clearCompleted}\n                onClick={handleClear}\n              >Clear completed</button>\n            ) : ''}\n          </footer>\n        ) : ''}\n      </section>,\n      <footer class={classes.info}>\n        <p>Double-click to edit a todo</p>\n        <p>Created by the <a href='https://github.com/skatejs/skatejs'>SkateJS Team</a></p>\n        <p>Part of <a href='http://todomvc.com'>TodoMVC</a></p>\n      </footer>\n    ];\n  }\n}\n\ncustomElements.define('todo-app', TodoApp);\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsWebComponents\"] = factory();\n\telse\n\t\troot[\"skatejsWebComponents\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t// We load the Safari fix first because the custom element polyfill overrides\n\t// attachShadow() to observe the shadow root.\n\t__webpack_require__(1);\n\t\n\t// We have to include this first so that it can patch native.\n\t__webpack_require__(2);\n\t\n\t// These must appear in this order. The ShadyCSS polyfill requires that the\n\t// ShadyDOM polyfill be loaded first.\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _window = window,\n\t    HTMLElement = _window.HTMLElement,\n\t    MutationObserver = _window.MutationObserver,\n\t    navigator = _window.navigator;\n\tvar userAgent = navigator.userAgent;\n\t\n\tvar safari = userAgent.indexOf('Safari/60') !== -1;\n\tvar safariVersion = safari && userAgent.match(/Version\\/([^\\s]+)/)[1];\n\tvar safariVersions = [0, 1].map(function (v) {\n\t  return '10.0.' + v;\n\t}).concat(['10.0']);\n\tvar patch = safari && safariVersions.indexOf(safariVersion) > -1;\n\t\n\t// Workaround for https://bugs.webkit.org/show_bug.cgi?id=160331\n\tfunction fixSafari() {\n\t  var oldAttachShadow = HTMLElement.prototype.attachShadow;\n\t\n\t  // We observe a shadow root, but only need to know if the target that was mutated is a <style>\n\t  // element as this is the only scenario where styles aren't recalculated.\n\t  var moOpts = { childList: true, subtree: true };\n\t  var mo = new MutationObserver(function (muts) {\n\t    muts.forEach(function (mut) {\n\t      var target = mut.target;\n\t\n\t      if (target.tagName === 'STYLE') {\n\t        var nextSibling = target.nextSibling,\n\t            parentNode = target.parentNode;\n\t\n\t        // We actually have to remove and subsequently re-insert rather than doing insertBefore()\n\t        // as it seems that doesn't trigger a recalc.\n\t\n\t        parentNode.removeChild(target);\n\t        parentNode.insertBefore(target, nextSibling);\n\t      }\n\t    });\n\t  });\n\t\n\t  // Our override simply calls the native (or overridden) attachShadow but it ensures that changes\n\t  // to it are observed so that we can take any <style> elements and re-insert them.\n\t  function newAttachShadow(opts) {\n\t    var sr = oldAttachShadow.call(this, opts);\n\t    mo.observe(sr, moOpts);\n\t    return sr;\n\t  }\n\t\n\t  // We have to define a property because Safari won't take the override if it is set directly.\n\t  Object.defineProperty(HTMLElement.prototype, 'attachShadow', {\n\t    // Ensure polyfills can override it (hoping they call it back).\n\t    configurable: true,\n\t    enumerable: true,\n\t    value: newAttachShadow,\n\t    writable: true\n\t  });\n\t}\n\t\n\t// We target a specific version of Safari instead of trying to but detect as it seems to involve\n\t// contriving a breaking case and detecting computed styles. We can remove this code when Safari\n\t// fixes the bug.\n\tif (patch) {\n\t  fixSafari();\n\t}\n\t\n\texports.default = patch;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\twindow.customElements && eval(\"/**\\n * @license\\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\\n * Code distributed by Google as part of the polymer project is also\\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\\n */\\n\\n/**\\n * This shim allows elements written in, or compiled to, ES5 to work on native\\n * implementations of Custom Elements.\\n *\\n * ES5-style classes don't work with native Custom Elements because the\\n * HTMLElement constructor uses the value of `new.target` to look up the custom\\n * element definition for the currently called constructor. `new.target` is only\\n * set when `new` is called and is only propagated via super() calls. super()\\n * is not emulatable in ES5. The pattern of `SuperClass.call(this)`` only works\\n * when extending other ES5-style classes, and does not propagate `new.target`.\\n *\\n * This shim allows the native HTMLElement constructor to work by generating and\\n * registering a stand-in class instead of the users custom element class. This\\n * stand-in class's constructor has an actual call to super().\\n * `customElements.define()` and `customElements.get()` are both overridden to\\n * hide this stand-in class from users.\\n *\\n * In order to create instance of the user-defined class, rather than the stand\\n * in, the stand-in's constructor swizzles its instances prototype and invokes\\n * the user-defined constructor. When the user-defined constructor is called\\n * directly it creates an instance of the stand-in class to get a real extension\\n * of HTMLElement and returns that.\\n *\\n * There are two important constructors: A patched HTMLElement constructor, and\\n * the StandInElement constructor. They both will be called to create an element\\n * but which is called first depends on whether the browser creates the element\\n * or the user-defined constructor is called directly. The variables\\n * `browserConstruction` and `userConstruction` control the flow between the\\n * two constructors.\\n *\\n * This shim should be better than forcing the polyfill because:\\n *   1. It's smaller\\n *   2. All reaction timings are the same as native (mostly synchronous)\\n *   3. All reaction triggering DOM operations are automatically supported\\n *\\n * There are some restrictions and requirements on ES5 constructors:\\n *   1. All constructors in a inheritance hierarchy must be ES5-style, so that\\n *      they can be called with Function.call(). This effectively means that the\\n *      whole application must be compiled to ES5.\\n *   2. Constructors must return the value of the emulated super() call. Like\\n *      `return SuperClass.call(this)`\\n *   3. The `this` reference should not be used before the emulated super() call\\n *      just like `this` is illegal to use before super() in ES6.\\n *   4. Constructors should not create other custom elements before the emulated\\n *      super() call. This is the same restriction as with native custom\\n *      elements.\\n *\\n *  Compiling valid class-based custom elements to ES5 will satisfy these\\n *  requirements with the latest version of popular transpilers.\\n */\\n(() => {\\n  'use strict';\\n\\n  const NativeHTMLElement = window.HTMLElement;\\n  const nativeDefine = window.customElements.define;\\n  const nativeGet = window.customElements.get;\\n\\n  /**\\n   * Map of user-provided constructors to tag names.\\n   *\\n   * @type {Map<Function, string>}\\n   */\\n  const tagnameByConstructor = new Map();\\n\\n  /**\\n   * Map of tag anmes to user-provided constructors.\\n   *\\n   * @type {Map<string, Function>}\\n   */\\n  const constructorByTagname = new Map();\\n\\n\\n  /**\\n   * Whether the constructors are being called by a browser process, ie parsing\\n   * or createElement.\\n   */\\n  let browserConstruction = false;\\n\\n  /**\\n   * Whether the constructors are being called by a user-space process, ie\\n   * calling an element constructor.\\n   */\\n  let userConstruction = false;\\n\\n  window.HTMLElement = function() {\\n    if (!browserConstruction) {\\n      const tagname = tagnameByConstructor.get(this.constructor);\\n      const fakeClass = nativeGet.call(window.customElements, tagname);\\n\\n      // Make sure that the fake constructor doesn't call back to this constructor\\n      userConstruction = true;\\n      const instance = new (fakeClass)();\\n      return instance;\\n    }\\n    // Else do nothing. This will be reached by ES5-style classes doing\\n    // HTMLElement.call() during initialization\\n    browserConstruction = false;\\n  };\\n\\n  window.HTMLElement.prototype = Object.create(NativeHTMLElement.prototype);\\n  window.HTMLElement.prototype.constructor = window.HTMLElement;\\n\\n  window.customElements.define = (tagname, elementClass) => {\\n    const elementProto = elementClass.prototype;\\n    const StandInElement = class extends NativeHTMLElement {\\n      constructor() {\\n        // Call the native HTMLElement constructor, this gives us the\\n        // under-construction instance as `this`:\\n        super();\\n\\n        // The prototype will be wrong up because the browser used our fake\\n        // class, so fix it:\\n        Object.setPrototypeOf(this, elementProto);\\n\\n        if (!userConstruction) {\\n          // Make sure that user-defined constructor bottom's out to a do-nothing\\n          // HTMLElement() call\\n          browserConstruction = true;\\n          // Call the user-defined constructor on our instance:\\n          elementClass.call(this);\\n        }\\n        userConstruction = false;\\n      }\\n    };\\n    const standInProto = StandInElement.prototype;\\n    StandInElement.observedAttributes = elementClass.observedAttributes;\\n    standInProto.connectedCallback = elementProto.connectedCallback;\\n    standInProto.disconnectedCallback = elementProto.disconnectedCallback;\\n    standInProto.attributeChangedCallback = elementProto.attributeChangedCallback;\\n    standInProto.adoptedCallback = elementProto.adoptedCallback;\\n\\n    tagnameByConstructor.set(elementClass, tagname);\\n    constructorByTagname.set(tagname, elementClass);\\n    nativeDefine.call(window.customElements, tagname, StandInElement);\\n  };\\n\\n  window.customElements.get = (tagname) => constructorByTagname.get(tagname);\\n\\n})();\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\t Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\t This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\t The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\t The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\t Code distributed by Google as part of the polymer project is also\n\t subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t'use strict';(function(){function c(){this.a=new Map;this.j=new Map;this.h=new Map;this.o=new Set;this.C=new MutationObserver(this.D.bind(this));this.f=null;this.F=new Set;this.enableFlush=!0;this.s=!1;this.m=null}function g(){return h.customElements}function k(a){if(!/^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(a)||-1!==q.indexOf(a))return Error(\"The element name '\"+a+\"' is not valid.\")}function l(a,b,d,e){var c=g();a=d?m.call(a,b,d):m.call(a,b);(b=c.a.get(b.toLowerCase()))&&c.u(a,b,e);c.b(a);return a}\n\tfunction n(a,b,d,e){b=b.toLowerCase();var c=a.getAttribute(b);e.call(a,b,d);1==a.__$CE_upgraded&&(e=g().a.get(a.localName),d=e.A,(e=e.i)&&0<=d.indexOf(b)&&(d=a.getAttribute(b),d!==c&&e.call(a,b,c,d,null)))}var f=document,h=window;if(g()&&(g().g=function(){},!g().forcePolyfill))return;var q=\"annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph\".split(\" \");c.prototype.L=function(a,b){function d(a){var b=f[a];if(void 0!==b&&\"function\"!==typeof b)throw Error(c+\n\t\" '\"+a+\"' is not a Function\");return b}if(\"function\"!==typeof b)throw new TypeError(\"constructor must be a Constructor\");var e=k(a);if(e)throw e;if(this.a.has(a))throw Error(\"An element with name '\"+a+\"' is already defined\");if(this.j.has(b))throw Error(\"Definition failed for '\"+a+\"': The constructor is already used.\");var c=a,f=b.prototype;if(\"object\"!==typeof f)throw new TypeError(\"Definition failed for '\"+a+\"': constructor.prototype must be an object\");var e=d(\"connectedCallback\"),g=d(\"disconnectedCallback\"),\n\th=d(\"attributeChangedCallback\");this.a.set(c,{name:a,localName:c,constructor:b,v:e,w:g,i:h,A:h&&b.observedAttributes||[]});this.j.set(b,c);this.K();if(a=this.h.get(c))a.resolve(void 0),this.h.delete(c)};c.prototype.get=function(a){return(a=this.a.get(a))?a.constructor:void 0};c.prototype.M=function(a){var b=k(a);if(b)return Promise.reject(b);if(this.a.has(a))return Promise.resolve();if(b=this.h.get(a))return b.N;var d,e=new Promise(function(a){d=a}),b={N:e,resolve:d};this.h.set(a,b);return e};c.prototype.g=\n\tfunction(){this.enableFlush&&(this.l(this.m.takeRecords()),this.D(this.C.takeRecords()),this.o.forEach(function(a){this.l(a.takeRecords())},this))};c.prototype.K=function(){var a=this;if(!this.s){this.s=!0;var b=function(){a.s=!1;a.m||(a.m=a.b(f));a.c(f.childNodes)};window.HTMLImports?window.HTMLImports.whenReady(b):b()}};c.prototype.I=function(a){this.f=a};c.prototype.b=function(a){if(null!=a.__$CE_observer)return a.__$CE_observer;a.__$CE_observer=new MutationObserver(this.l.bind(this));a.__$CE_observer.observe(a,\n\t{childList:!0,subtree:!0});this.enableFlush&&this.o.add(a.__$CE_observer);return a.__$CE_observer};c.prototype.J=function(a){null!=a.__$CE_observer&&(a.__$CE_observer.disconnect(),this.enableFlush&&this.o.delete(a.__$CE_observer),a.__$CE_observer=null)};c.prototype.l=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"childList\"===d.type){var e=d.removedNodes;this.c(d.addedNodes);this.H(e)}}};c.prototype.c=function(a,b){b=b||new Set;for(var d=0;d<a.length;d++){var e=a[d];if(e.nodeType===Node.ELEMENT_NODE){this.J(e);\n\te=f.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,null,!1);do this.G(e.currentNode,b);while(e.nextNode())}}};c.prototype.G=function(a,b){if(!b.has(a)){b.add(a);var d=this.a.get(a.localName);if(d){a.__$CE_upgraded||this.u(a,d,!0);var e;if(e=a.__$CE_upgraded&&!a.__$CE_attached)a:{e=a;do{if(e.__$CE_attached||e.nodeType===Node.DOCUMENT_NODE){e=!0;break a}e=e.parentNode||e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host}while(e);e=!1}e&&(a.__$CE_attached=!0,d.v&&d.v.call(a))}a.shadowRoot&&this.c(a.shadowRoot.childNodes,\n\tb);\"LINK\"===a.tagName&&a.rel&&-1!==a.rel.toLowerCase().split(\" \").indexOf(\"import\")&&this.B(a,b)}};c.prototype.B=function(a,b){var d=a.import;if(d)b.has(d)||(b.add(d),d.__$CE_observer||this.b(d),this.c(d.childNodes,b));else if(b=a.href,!this.F.has(b)){this.F.add(b);var e=this,c=function(){a.removeEventListener(\"load\",c);a.import.__$CE_observer||e.b(a.import);e.c(a.import.childNodes)};a.addEventListener(\"load\",c)}};c.prototype.H=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(d.nodeType===Node.ELEMENT_NODE){this.b(d);\n\td=f.createTreeWalker(d,NodeFilter.SHOW_ELEMENT,null,!1);do{var e=d.currentNode;if(e.__$CE_upgraded&&e.__$CE_attached){e.__$CE_attached=!1;var c=this.a.get(e.localName);c&&c.w&&c.w.call(e)}}while(d.nextNode())}}};c.prototype.u=function(a,b,d){a.__proto__=b.constructor.prototype;d&&(this.I(a),new b.constructor,a.__$CE_upgraded=!0,console.assert(!this.f));d=b.A;if((b=b.i)&&0<d.length){this.C.observe(a,{attributes:!0,attributeOldValue:!0,attributeFilter:d});for(var e=0;e<d.length;e++){var c=d[e];if(a.hasAttribute(c)){var f=\n\ta.getAttribute(c);b.call(a,c,null,f,null)}}}};c.prototype.D=function(a){for(var b=0;b<a.length;b++){var d=a[b];if(\"attributes\"===d.type){var c=d.target,f=this.a.get(c.localName),g=d.attributeName,h=d.oldValue,k=c.getAttribute(g);k!==h&&f.i.call(c,g,h,k,d.attributeNamespace)}}};window.CustomElementRegistry=c;c.prototype.define=c.prototype.L;c.prototype.get=c.prototype.get;c.prototype.whenDefined=c.prototype.M;c.prototype.flush=c.prototype.g;c.prototype.polyfilled=!0;c.prototype._observeRoot=c.prototype.b;\n\tc.prototype._addImport=c.prototype.B;var r=h.HTMLElement;h.HTMLElement=function(){var a=g();if(a.f){var b=a.f;a.f=null;return b}if(this.constructor)return a=a.j.get(this.constructor),l(f,a,void 0,!1);throw Error(\"Unknown constructor. Did you call customElements.define()?\");};h.HTMLElement.prototype=Object.create(r.prototype,{constructor:{value:h.HTMLElement,configurable:!0,writable:!0}});var m=f.createElement;f.createElement=function(a,b){return l(f,a,b,!0)};var t=f.createElementNS;f.createElementNS=\n\tfunction(a,b){return\"http://www.w3.org/1999/xhtml\"===a?f.createElement(b):t.call(f,a,b)};var p=Element.prototype.attachShadow;p&&Object.defineProperty(Element.prototype,\"attachShadow\",{value:function(a){a=p.call(this,a);g().b(a);return a}});var u=f.importNode;f.importNode=function(a,b){a=u.call(f,a,b);g().c(a.nodeType===Node.ELEMENT_NODE?[a]:a.childNodes);return a};var v=Element.prototype.setAttribute;Element.prototype.setAttribute=function(a,b){n(this,a,b,v)};var w=Element.prototype.removeAttribute;\n\tElement.prototype.removeAttribute=function(a){n(this,a,null,w)};Object.defineProperty(window,\"customElements\",{value:new c,configurable:!0,enumerable:!0});window.CustomElements={takeRecords:function(){g().g&&g().g()}}})();\n\t\n\t//# sourceMappingURL=custom-elements.min.js.map\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar settings = window.ShadyDOM || {};\n\t\n\tsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\t\n\tsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\t\n\tfunction isShadyRoot(obj) {\n\t  return Boolean(obj.__localName === 'ShadyRoot');\n\t}\n\t\n\tvar p = Element.prototype;\n\tvar matches = p.matches || p.matchesSelector ||\n\t  p.mozMatchesSelector || p.msMatchesSelector ||\n\t  p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tfunction matchesSelector(element, selector) {\n\t  return matches.call(element, selector);\n\t}\n\t\n\tfunction copyOwnProperty(name, source, target) {\n\t  var pd = Object.getOwnPropertyDescriptor(source, name);\n\t  if (pd) {\n\t    Object.defineProperty(target, name, pd);\n\t  }\n\t}\n\t\n\tfunction extend(target, source) {\n\t  if (target && source) {\n\t    var n$ = Object.getOwnPropertyNames(source);\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n\t      copyOwnProperty(n, source, target);\n\t    }\n\t  }\n\t  return target || source;\n\t}\n\t\n\tfunction extendAll(target) {\n\t  var sources = [], len = arguments.length - 1;\n\t  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  for (var i=0; i < sources.length; i++) {\n\t    extend(target, sources[i]);\n\t  }\n\t  return target;\n\t}\n\t\n\tfunction mixin(target, source) {\n\t  for (var i in source) {\n\t    target[i] = source[i];\n\t  }\n\t  return target;\n\t}\n\t\n\tvar setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {\n\t  obj.__proto__ = proto;\n\t  return obj;\n\t}\n\t\n\tfunction patchPrototype(obj, mixin) {\n\t  var proto = Object.getPrototypeOf(obj);\n\t  if (!proto.hasOwnProperty('__patchProto')) {\n\t    var patchProto = Object.create(proto);\n\t    patchProto.__sourceProto = proto;\n\t    extend(patchProto, mixin);\n\t    proto.__patchProto = patchProto;\n\t  }\n\t  setPrototypeOf(obj, proto.__patchProto);\n\t}\n\t\n\t\n\t\n\tvar common = {};\n\t\n\t// TODO(sorvell): actually rely on a real Promise polyfill...\n\tvar promish;\n\tif (window.Promise) {\n\t  promish = Promise.resolve();\n\t} else {\n\t  promish = {\n\t    then: function(cb) {\n\t      var twiddle = document.createTextNode('');\n\t      var observer = new MutationObserver(function() {\n\t        observer.disconnect();\n\t        cb();\n\t      });\n\t      observer.observe(twiddle, {characterData: true});\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction newSplice(index, removed, addedCount) {\n\t  return {\n\t    index: index,\n\t    removed: removed,\n\t    addedCount: addedCount\n\t  };\n\t}\n\t\n\tvar EDIT_LEAVE = 0;\n\tvar EDIT_UPDATE = 1;\n\tvar EDIT_ADD = 2;\n\tvar EDIT_DELETE = 3;\n\t\n\tvar ArraySplice = {\n\t\n\t  // Note: This function is *based* on the computation of the Levenshtein\n\t  // \"edit\" distance. The one change is that \"updates\" are treated as two\n\t  // edits - not one. With Array splices, an update is really a delete\n\t  // followed by an add. By retaining this, we optimize for \"keeping\" the\n\t  // maximum array items in the original array. For example:\n\t  //\n\t  //   'xxxx123' -> '123yyyy'\n\t  //\n\t  // With 1-edit updates, the shortest path would be just to update all seven\n\t  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n\t  // leaves the substring '123' intact.\n\t  calcEditDistances: function calcEditDistances(current, currentStart, currentEnd,\n\t                              old, oldStart, oldEnd) {\n\t    var this$1 = this;\n\t\n\t    // \"Deletion\" columns\n\t    var rowCount = oldEnd - oldStart + 1;\n\t    var columnCount = currentEnd - currentStart + 1;\n\t    var distances = new Array(rowCount);\n\t\n\t    // \"Addition\" rows. Initialize null column.\n\t    for (var i = 0; i < rowCount; i++) {\n\t      distances[i] = new Array(columnCount);\n\t      distances[i][0] = i;\n\t    }\n\t\n\t    // Initialize null row\n\t    for (var j = 0; j < columnCount; j++)\n\t      distances[0][j] = j;\n\t\n\t    for (var i$1 = 1; i$1 < rowCount; i$1++) {\n\t      for (var j$1 = 1; j$1 < columnCount; j$1++) {\n\t        if (this$1.equals(current[currentStart + j$1 - 1], old[oldStart + i$1 - 1]))\n\t          distances[i$1][j$1] = distances[i$1 - 1][j$1 - 1];\n\t        else {\n\t          var north = distances[i$1 - 1][j$1] + 1;\n\t          var west = distances[i$1][j$1 - 1] + 1;\n\t          distances[i$1][j$1] = north < west ? north : west;\n\t        }\n\t      }\n\t    }\n\t\n\t    return distances;\n\t  },\n\t\n\t  // This starts at the final weight, and walks \"backward\" by finding\n\t  // the minimum previous weight recursively until the origin of the weight\n\t  // matrix.\n\t  spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {\n\t    var i = distances.length - 1;\n\t    var j = distances[0].length - 1;\n\t    var current = distances[i][j];\n\t    var edits = [];\n\t    while (i > 0 || j > 0) {\n\t      if (i == 0) {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        continue;\n\t      }\n\t      if (j == 0) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        continue;\n\t      }\n\t      var northWest = distances[i - 1][j - 1];\n\t      var west = distances[i - 1][j];\n\t      var north = distances[i][j - 1];\n\t\n\t      var min;\n\t      if (west < north)\n\t        min = west < northWest ? west : northWest;\n\t      else\n\t        min = north < northWest ? north : northWest;\n\t\n\t      if (min == northWest) {\n\t        if (northWest == current) {\n\t          edits.push(EDIT_LEAVE);\n\t        } else {\n\t          edits.push(EDIT_UPDATE);\n\t          current = northWest;\n\t        }\n\t        i--;\n\t        j--;\n\t      } else if (min == west) {\n\t        edits.push(EDIT_DELETE);\n\t        i--;\n\t        current = west;\n\t      } else {\n\t        edits.push(EDIT_ADD);\n\t        j--;\n\t        current = north;\n\t      }\n\t    }\n\t\n\t    edits.reverse();\n\t    return edits;\n\t  },\n\t\n\t  /**\n\t   * Splice Projection functions:\n\t   *\n\t   * A splice map is a representation of how a previous array of items\n\t   * was transformed into a new array of items. Conceptually it is a list of\n\t   * tuples of\n\t   *\n\t   *   <index, removed, addedCount>\n\t   *\n\t   * which are kept in ascending index order of. The tuple represents that at\n\t   * the |index|, |removed| sequence of items were removed, and counting forward\n\t   * from |index|, |addedCount| items were added.\n\t   */\n\t\n\t  /**\n\t   * Lacking individual splice mutation information, the minimal set of\n\t   * splices can be synthesized given the previous state and final state of an\n\t   * array. The basic approach is to calculate the edit distance matrix and\n\t   * choose the shortest path through it.\n\t   *\n\t   * Complexity: O(l * p)\n\t   *   l: The length of the current array\n\t   *   p: The length of the old array\n\t   */\n\t  calcSplices: function calcSplices(current, currentStart, currentEnd,\n\t                        old, oldStart, oldEnd) {\n\t    var prefixCount = 0;\n\t    var suffixCount = 0;\n\t    var splice;\n\t\n\t    var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n\t    if (currentStart == 0 && oldStart == 0)\n\t      prefixCount = this.sharedPrefix(current, old, minLength);\n\t\n\t    if (currentEnd == current.length && oldEnd == old.length)\n\t      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\t\n\t    currentStart += prefixCount;\n\t    oldStart += prefixCount;\n\t    currentEnd -= suffixCount;\n\t    oldEnd -= suffixCount;\n\t\n\t    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n\t      return [];\n\t\n\t    if (currentStart == currentEnd) {\n\t      splice = newSplice(currentStart, [], 0);\n\t      while (oldStart < oldEnd)\n\t        splice.removed.push(old[oldStart++]);\n\t\n\t      return [ splice ];\n\t    } else if (oldStart == oldEnd)\n\t      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\t\n\t    var ops = this.spliceOperationsFromEditDistances(\n\t        this.calcEditDistances(current, currentStart, currentEnd,\n\t                               old, oldStart, oldEnd));\n\t\n\t    splice = undefined;\n\t    var splices = [];\n\t    var index = currentStart;\n\t    var oldIndex = oldStart;\n\t    for (var i = 0; i < ops.length; i++) {\n\t      switch(ops[i]) {\n\t        case EDIT_LEAVE:\n\t          if (splice) {\n\t            splices.push(splice);\n\t            splice = undefined;\n\t          }\n\t\n\t          index++;\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_UPDATE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t        case EDIT_ADD:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.addedCount++;\n\t          index++;\n\t          break;\n\t        case EDIT_DELETE:\n\t          if (!splice)\n\t            splice = newSplice(index, [], 0);\n\t\n\t          splice.removed.push(old[oldIndex]);\n\t          oldIndex++;\n\t          break;\n\t      }\n\t    }\n\t\n\t    if (splice) {\n\t      splices.push(splice);\n\t    }\n\t    return splices;\n\t  },\n\t\n\t  sharedPrefix: function sharedPrefix(current, old, searchLength) {\n\t    var this$1 = this;\n\t\n\t    for (var i = 0; i < searchLength; i++)\n\t      if (!this$1.equals(current[i], old[i]))\n\t        return i;\n\t    return searchLength;\n\t  },\n\t\n\t  sharedSuffix: function sharedSuffix(current, old, searchLength) {\n\t    var index1 = current.length;\n\t    var index2 = old.length;\n\t    var count = 0;\n\t    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n\t      count++;\n\t\n\t    return count;\n\t  },\n\t\n\t  calculateSplices: function calculateSplices$1(current, previous) {\n\t    return this.calcSplices(current, 0, current.length, previous, 0,\n\t                            previous.length);\n\t  },\n\t\n\t  equals: function equals(currentValue, previousValue) {\n\t    return currentValue === previousValue;\n\t  }\n\t\n\t};\n\t\n\tvar calculateSplices = function (current, previous) { return ArraySplice.calculateSplices(current, previous); };\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(sorvell): circular (patch loads tree and tree loads patch)\n\t// for now this is stuck on `utils`\n\t//import {patchNode} from './patch'\n\t// native add/remove\n\tvar nativeInsertBefore = Element.prototype.insertBefore;\n\tvar nativeAppendChild = Element.prototype.appendChild;\n\tvar nativeRemoveChild = Element.prototype.removeChild;\n\t\n\t/**\n\t * `tree` is a dom manipulation library used by ShadyDom to\n\t * manipulate composed and logical trees.\n\t */\n\tvar tree = {\n\t\n\t  // sad but faster than slice...\n\t  arrayCopyChildNodes: function arrayCopyChildNodes(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstChild; n; n=n.nextSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopyChildren: function arrayCopyChildren(parent) {\n\t    var copy=[], i=0;\n\t    for (var n=parent.firstElementChild; n; n=n.nextElementSibling) {\n\t      copy[i++] = n;\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  arrayCopy: function arrayCopy(a$) {\n\t    var l = a$.length;\n\t    var copy = new Array(l);\n\t    for (var i=0; i < l; i++) {\n\t      copy[i] = a$[i];\n\t    }\n\t    return copy;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes(node) {\n\t    tree.Logical.saveChildNodes(node);\n\t    if (!tree.Composed.hasParentNode(node)) {\n\t      tree.Composed.saveComposedData(node);\n\t      //tree.Composed.saveParentNode(node);\n\t    }\n\t    tree.Composed.saveChildNodes(node);\n\t  }\n\t\n\t};\n\t\n\ttree.Logical = {\n\t\n\t  hasParentNode: function hasParentNode(node) {\n\t    return Boolean(node.__dom && node.__dom.parentNode);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes(node) {\n\t    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes(node) {\n\t    // note: we're distinguishing here between undefined and false-y:\n\t    // hasChildNodes uses undefined check to see if this element has logical\n\t    // children; the false-y check indicates whether or not we should rebuild\n\t    // the cached childNodes array.\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      tree.Composed.getChildNodes(node);\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes(node) {\n\t    if (!node.__dom.childNodes) {\n\t      node.__dom.childNodes = [];\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        node.__dom.childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.childNodes;\n\t  },\n\t\n\t  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n\t  // logical tree, or (2) an element is in a logical tree. In case (1), the\n\t  // element will store firstChild/lastChild, and in case (2), the element\n\t  // will store parentNode, nextSibling, previousSibling. This means that\n\t  // the mere existence of __dom is not enough to know if the requested\n\t  // logical data is available and instead we do an explicit undefined check.\n\t  getParentNode: function getParentNode(node) {\n\t    return node.__dom && node.__dom.parentNode !== undefined ?\n\t      node.__dom.parentNode : tree.Composed.getParentNode(node);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n\t  },\n\t\n\t  getLastChild: function getLastChild(node) {\n\t    return node.__dom && node.__dom.lastChild  !== undefined ?\n\t      node.__dom.lastChild : tree.Composed.getLastChild(node);\n\t  },\n\t\n\t  getNextSibling: function getNextSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling  !== undefined ?\n\t      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling  !== undefined ?\n\t      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild(node) {\n\t    return node.__dom && node.__dom.firstChild !== undefined ?\n\t      this._getFirstElementChild(node) :\n\t      tree.Composed.getFirstElementChild(node);\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild(node) {\n\t    var n = node.__dom.firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild(node) {\n\t    return node.__dom && node.__dom.lastChild !== undefined ?\n\t      this._getLastElementChild(node) :\n\t      tree.Composed.getLastElementChild(node);\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild(node) {\n\t    var n = node.__dom.lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling(node) {\n\t    return node.__dom && node.__dom.nextSibling !== undefined ?\n\t      this._getNextElementSibling(node) :\n\t      tree.Composed.getNextElementSibling(node);\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling(node) {\n\t    return node.__dom && node.__dom.previousSibling !== undefined ?\n\t      this._getPreviousElementSibling(node) :\n\t      tree.Composed.getPreviousElementSibling(node);\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  // Capture the list of light children. It's important to do this before we\n\t  // start transforming the DOM into \"rendered\" state.\n\t  // Children may be added to this list dynamically. It will be treated as the\n\t  // source of truth for the light children of the element. This element's\n\t  // actual children will be treated as the rendered state once this function\n\t  // has been called.\n\t  saveChildNodes: function saveChildNodes$1(node) {\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.firstChild;\n\t      node.__dom.lastChild = node.lastChild;\n\t      var c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        n.__dom = n.__dom || {};\n\t        n.__dom.parentNode = node;\n\t        n.__dom.nextSibling = c$[i+1] || null;\n\t        n.__dom.previousSibling = c$[i-1] || null;\n\t        common.patchNode(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n\t  // already been distributed.\n\t  // NOTE: ensure `node` is patched...\n\t  recordInsertBefore: function recordInsertBefore(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var c$ = tree.arrayCopyChildNodes(node);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1._linkNode(c$[i], container, ref_node);\n\t      }\n\t      // cleanup logical dom in doc fragment.\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.firstChild = node.__dom.lastChild = null;\n\t      node.__dom.childNodes = null;\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode(node, container, ref_node) {\n\t    common.patchNode(node);\n\t    ref_node = ref_node || null;\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n\t      container.__dom.lastChild;\n\t    if (node.__dom.previousSibling) {\n\t      node.__dom.previousSibling.__dom.nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.nextSibling = ref_node;\n\t    if (node.__dom.nextSibling) {\n\t      node.__dom.nextSibling.__dom.previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.lastChild = node;\n\t      if (!container.__dom.firstChild) {\n\t        container.__dom.firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.firstChild) {\n\t      container.__dom.firstChild = node.__dom.nextSibling;\n\t    }\n\t    if (node === container.__dom.lastChild) {\n\t      container.__dom.lastChild = node.__dom.previousSibling;\n\t    }\n\t    var p = node.__dom.previousSibling;\n\t    var n = node.__dom.nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.previousSibling = p;\n\t    }\n\t    // When an element is removed, logical data is no longer tracked.\n\t    // Explicitly set `undefined` here to indicate this. This is disginguished\n\t    // from `null` which is set if info is null.\n\t    node.__dom.parentNode = node.__dom.previousSibling =\n\t      node.__dom.nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.childNodes = null;\n\t  }\n\t\n\t}\n\t\n\t\n\t// TODO(sorvell): composed tree manipulation is made available\n\t// (1) to maninpulate the composed tree, and (2) to track changes\n\t// to the tree for optional patching pluggability.\n\ttree.Composed = {\n\t\n\t  hasParentNode: function hasParentNode$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n\t  },\n\t\n\t  hasChildNodes: function hasChildNodes$1(node) {\n\t    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n\t  },\n\t\n\t  getChildNodes: function getChildNodes$1(node) {\n\t    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n\t      (!node.__patched && tree.arrayCopy(node.childNodes));\n\t  },\n\t\n\t  _getChildNodes: function _getChildNodes$1(node) {\n\t    if (!node.__dom.$childNodes) {\n\t      node.__dom.$childNodes = [];\n\t      for (var n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n\t        node.__dom.$childNodes.push(n);\n\t      }\n\t    }\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getComposedChildNodes: function getComposedChildNodes(node) {\n\t    return node.__dom.$childNodes;\n\t  },\n\t\n\t  getParentNode: function getParentNode$1(node) {\n\t    return this.hasParentNode(node) ? node.__dom.$parentNode :\n\t      (!node.__patched && node.parentNode);\n\t  },\n\t\n\t  getFirstChild: function getFirstChild$1(node) {\n\t    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n\t  },\n\t\n\t  getLastChild: function getLastChild$1(node) {\n\t    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n\t  },\n\t\n\t  getNextSibling: function getNextSibling$1(node) {\n\t    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n\t  },\n\t\n\t  getPreviousSibling: function getPreviousSibling$1(node) {\n\t    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n\t  },\n\t\n\t  getFirstElementChild: function getFirstElementChild$1(node) {\n\t    return node.__patched ? this._getFirstElementChild(node) :\n\t      node.firstElementChild;\n\t  },\n\t\n\t  _getFirstElementChild: function _getFirstElementChild$1(node) {\n\t    var n = node.__dom.$firstChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$nextSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getLastElementChild: function getLastElementChild$1(node) {\n\t    return node.__patched ? this._getLastElementChild(node) :\n\t      node.lastElementChild;\n\t  },\n\t\n\t  _getLastElementChild: function _getLastElementChild$1(node) {\n\t    var n = node.__dom.$lastChild;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = n.__dom.$previousSibling;\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getNextElementSibling: function getNextElementSibling$1(node) {\n\t    return node.__patched ? this._getNextElementSibling(node) :\n\t      node.nextElementSibling;\n\t  },\n\t\n\t  _getNextElementSibling: function _getNextElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$nextSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getNextSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  getPreviousElementSibling: function getPreviousElementSibling$1(node) {\n\t    return node.__patched ? this._getPreviousElementSibling(node) :\n\t      node.previousElementSibling;\n\t  },\n\t\n\t  _getPreviousElementSibling: function _getPreviousElementSibling$1(node) {\n\t    var this$1 = this;\n\t\n\t    var n = node.__dom.$previousSibling;\n\t    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n\t      n = this$1.getPreviousSibling(n);\n\t    }\n\t    return n;\n\t  },\n\t\n\t  saveChildNodes: function saveChildNodes$2(node) {\n\t    var this$1 = this;\n\t\n\t    if (!this.hasChildNodes(node)) {\n\t      node.__dom = node.__dom || {};\n\t      node.__dom.$firstChild = node.firstChild;\n\t      node.__dom.$lastChild = node.lastChild;\n\t      var c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n\t      for (var i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n\t        this$1.saveComposedData(n);\n\t      }\n\t    }\n\t  },\n\t\n\t  saveComposedData: function saveComposedData(node) {\n\t    node.__dom = node.__dom || {};\n\t    if (node.__dom.$parentNode === undefined) {\n\t      node.__dom.$parentNode = node.parentNode;\n\t    }\n\t    if (node.__dom.$nextSibling === undefined) {\n\t      node.__dom.$nextSibling = node.nextSibling;\n\t    }\n\t    if (node.__dom.$previousSibling === undefined) {\n\t      node.__dom.$previousSibling = node.previousSibling;\n\t    }\n\t  },\n\t\n\t  recordInsertBefore: function recordInsertBefore$1(node, container, ref_node) {\n\t    var this$1 = this;\n\t\n\t    container.__dom.$childNodes = null;\n\t    // handle document fragments\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t      // TODO(sorvell): remember this for patching:\n\t      // the act of setting this info can affect patched nodes\n\t      // getters; therefore capture childNodes before patching.\n\t      for (var n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n\t        this$1._linkNode(n, container, ref_node);\n\t      }\n\t    } else {\n\t      this._linkNode(node, container, ref_node);\n\t    }\n\t  },\n\t\n\t  _linkNode: function _linkNode$1(node, container, ref_node) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (ref_node) {\n\t      ref_node.__dom = ref_node.__dom || {};\n\t    }\n\t    // update ref_node.previousSibling <-> node\n\t    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n\t      container.__dom.$lastChild;\n\t    if (node.__dom.$previousSibling) {\n\t      node.__dom.$previousSibling.__dom.$nextSibling = node;\n\t    }\n\t    // update node <-> ref_node\n\t    node.__dom.$nextSibling = ref_node;\n\t    if (node.__dom.$nextSibling) {\n\t      node.__dom.$nextSibling.__dom.$previousSibling = node;\n\t    }\n\t    // update node <-> container\n\t    node.__dom.$parentNode = container;\n\t    if (ref_node) {\n\t      if (ref_node === container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    } else {\n\t      container.__dom.$lastChild = node;\n\t      if (!container.__dom.$firstChild) {\n\t        container.__dom.$firstChild = node;\n\t      }\n\t    }\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  recordRemoveChild: function recordRemoveChild$1(node, container) {\n\t    node.__dom = node.__dom || {};\n\t    container.__dom = container.__dom || {};\n\t    if (node === container.__dom.$firstChild) {\n\t      container.__dom.$firstChild = node.__dom.$nextSibling;\n\t    }\n\t    if (node === container.__dom.$lastChild) {\n\t      container.__dom.$lastChild = node.__dom.$previousSibling;\n\t    }\n\t    var p = node.__dom.$previousSibling;\n\t    var n = node.__dom.$nextSibling;\n\t    if (p) {\n\t      p.__dom = p.__dom || {};\n\t      p.__dom.$nextSibling = n;\n\t    }\n\t    if (n) {\n\t      n.__dom = n.__dom || {};\n\t      n.__dom.$previousSibling = p;\n\t    }\n\t    node.__dom.$parentNode = node.__dom.$previousSibling =\n\t      node.__dom.$nextSibling = null;\n\t    // remove caching of childNodes\n\t    container.__dom.$childNodes = null;\n\t  },\n\t\n\t  clearChildNodes: function clearChildNodes(node) {\n\t    var this$1 = this;\n\t\n\t    var c$ = this.getChildNodes(node);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      this$1.recordRemoveChild(c, node);\n\t      nativeRemoveChild.call(node, c)\n\t    }\n\t  },\n\t\n\t  saveParentNode: function saveParentNode(node) {\n\t    node.__dom = node.__dom || {};\n\t    node.__dom.$parentNode = node.parentNode;\n\t  },\n\t\n\t  insertBefore: function insertBefore(parentNode, newChild, refChild) {\n\t    this.saveChildNodes(parentNode);\n\t    // remove from current location.\n\t    this._addChild(parentNode, newChild, refChild);\n\t    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n\t  },\n\t\n\t  appendChild: function appendChild(parentNode, newChild) {\n\t    this.saveChildNodes(parentNode);\n\t    this._addChild(parentNode, newChild);\n\t    return nativeAppendChild.call(parentNode, newChild);\n\t  },\n\t\n\t  removeChild: function removeChild(parentNode, node) {\n\t    var currentParent = this.getParentNode(node);\n\t    this.saveChildNodes(parentNode);\n\t    this._removeChild(parentNode, node);\n\t    if (currentParent === parentNode) {\n\t      return nativeRemoveChild.call(parentNode, node);\n\t    }\n\t  },\n\t\n\t  _addChild: function _addChild(parentNode, newChild, refChild) {\n\t    var this$1 = this;\n\t\n\t    var isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n\t    var oldParent = this.getParentNode(newChild);\n\t    if (oldParent) {\n\t      this._removeChild(oldParent, newChild);\n\t    }\n\t    if (isFrag) {\n\t      var c$ = this.getChildNodes(newChild);\n\t      for (var i=0; i < c$.length; i++) {\n\t        var c = c$[i];\n\t        // unlink document fragment children\n\t        this$1._removeChild(newChild, c);\n\t        this$1.recordInsertBefore(c, parentNode, refChild);\n\t      }\n\t    } else {\n\t      this.recordInsertBefore(newChild, parentNode, refChild);\n\t    }\n\t  },\n\t\n\t  _removeChild: function _removeChild(parentNode, node) {\n\t    this.recordRemoveChild(node, parentNode);\n\t  }\n\t\n\t};\n\t\n\t// for testing...\n\tvar descriptors = {};\n\tfunction getNativeProperty(element, property) {\n\t  if (!descriptors[property]) {\n\t    descriptors[property] = Object.getOwnPropertyDescriptor(\n\t      HTMLElement.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Element.prototype, property) ||\n\t    Object.getOwnPropertyDescriptor(\n\t      Node.prototype, property);\n\t  }\n\t  return descriptors[property].get.call(element);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// NOTE: normalize event contruction where necessary (IE11)\n\tvar NormalizedEvent = typeof Event === 'function' ? Event :\n\t  function(inType, params) {\n\t    params = params || {};\n\t    var e = document.createEvent('Event');\n\t    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n\t    return e;\n\t  };\n\t\n\tvar Distributor = (function () {\n\t  function anonymous(root) {\n\t    this.root = root;\n\t    this.insertionPointTag = 'slot';\n\t  }\n\t\n\t  anonymous.prototype.getInsertionPoints = function getInsertionPoints () {\n\t    return this.root.querySelectorAll(this.insertionPointTag);\n\t  };\n\t\n\t  anonymous.prototype.hasInsertionPoint = function hasInsertionPoint () {\n\t    return Boolean(this.root._insertionPoints &&\n\t      this.root._insertionPoints.length);\n\t  };\n\t\n\t  anonymous.prototype.isInsertionPoint = function isInsertionPoint (node) {\n\t    return node.localName && node.localName == this.insertionPointTag;\n\t  };\n\t\n\t  anonymous.prototype.distribute = function distribute () {\n\t    if (this.hasInsertionPoint()) {\n\t      return this.distributePool(this.root, this.collectPool());\n\t    }\n\t    return [];\n\t  };\n\t\n\t  // Gather the pool of nodes that should be distributed. We will combine\n\t  // these with the \"content root\" to arrive at the composed tree.\n\t  anonymous.prototype.collectPool = function collectPool () {\n\t    return tree.arrayCopy(\n\t      tree.Logical.getChildNodes(this.root.host));\n\t  };\n\t\n\t  // perform \"logical\" distribution; note, no actual dom is moved here,\n\t  // instead elements are distributed into storage\n\t  // array where applicable.\n\t  anonymous.prototype.distributePool = function distributePool (node, pool) {\n\t    var this$1 = this;\n\t\n\t    var dirtyRoots = [];\n\t    var p$ = this.root._insertionPoints;\n\t    for (var i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n\t      this$1.distributeInsertionPoint(p, pool);\n\t      // provoke redistribution on insertion point parents\n\t      // must do this on all candidate hosts since distribution in this\n\t      // scope invalidates their distribution.\n\t      // only get logical parent.\n\t      var parent = tree.Logical.getParentNode(p);\n\t      if (parent && parent.shadyRoot &&\n\t          this$1.hasInsertionPoint(parent.shadyRoot)) {\n\t        dirtyRoots.push(parent.shadyRoot);\n\t      }\n\t    }\n\t    for (var i$1=0; i$1 < pool.length; i$1++) {\n\t      var p$1 = pool[i$1];\n\t      if (p$1) {\n\t        p$1._assignedSlot = undefined;\n\t        // remove undistributed elements from physical dom.\n\t        var parent$1 = tree.Composed.getParentNode(p$1);\n\t        if (parent$1) {\n\t          tree.Composed.removeChild(parent$1, p$1);\n\t        }\n\t      }\n\t    }\n\t    return dirtyRoots;\n\t  };\n\t\n\t  anonymous.prototype.distributeInsertionPoint = function distributeInsertionPoint (insertionPoint, pool) {\n\t    var this$1 = this;\n\t\n\t    var prevAssignedNodes = insertionPoint._assignedNodes;\n\t    if (prevAssignedNodes) {\n\t      this.clearAssignedSlots(insertionPoint, true);\n\t    }\n\t    insertionPoint._assignedNodes = [];\n\t    var needsSlotChange = false;\n\t    // distribute nodes from the pool that this selector matches\n\t    var anyDistributed = false;\n\t    for (var i=0, l=pool.length, node; i < l; i++) {\n\t      node=pool[i];\n\t      // skip nodes that were already used\n\t      if (!node) {\n\t        continue;\n\t      }\n\t      // distribute this node if it matches\n\t      if (this$1.matchesInsertionPoint(node, insertionPoint)) {\n\t        if (node.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node, insertionPoint)\n\t        // remove this node from the pool\n\t        pool[i] = undefined;\n\t        // since at least one node matched, we won't need fallback content\n\t        anyDistributed = true;\n\t      }\n\t    }\n\t    // Fallback content if nothing was distributed here\n\t    if (!anyDistributed) {\n\t      var children = tree.Logical.getChildNodes(insertionPoint);\n\t      for (var j = 0, node$1; j < children.length; j++) {\n\t        node$1 = children[j];\n\t        if (node$1.__prevAssignedSlot != insertionPoint) {\n\t          needsSlotChange = true;\n\t        }\n\t        this$1.distributeNodeInto(node$1, insertionPoint);\n\t      }\n\t    }\n\t    // we're already dirty if a node was newly added to the slot\n\t    // and we're also dirty if the assigned count decreased.\n\t    if (prevAssignedNodes) {\n\t      // TODO(sorvell): the tracking of previously assigned slots\n\t      // could instead by done with a Set and then we could\n\t      // avoid needing to iterate here to clear the info.\n\t      for (var i$1=0; i$1 < prevAssignedNodes.length; i$1++) {\n\t        prevAssignedNodes[i$1].__prevAssignedSlot = null;\n\t      }\n\t      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n\t        needsSlotChange = true;\n\t      }\n\t    }\n\t    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n\t    if (needsSlotChange) {\n\t      this._fireSlotChange(insertionPoint);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.clearAssignedSlots = function clearAssignedSlots (slot, savePrevious) {\n\t    var n$ = slot._assignedNodes;\n\t    if (n$) {\n\t      for (var i=0; i < n$.length; i++) {\n\t        var n = n$[i];\n\t        if (savePrevious) {\n\t          n.__prevAssignedSlot = n._assignedSlot;\n\t        }\n\t        // only clear if it was previously set to this slot;\n\t        // this helps ensure that if the node has otherwise been distributed\n\t        // ignore it.\n\t        if (n._assignedSlot === slot) {\n\t          n._assignedSlot = null;\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.matchesInsertionPoint = function matchesInsertionPoint (node, insertionPoint) {\n\t    var slotName = insertionPoint.getAttribute('name');\n\t    slotName = slotName ? slotName.trim() : '';\n\t    var slot = node.getAttribute && node.getAttribute('slot');\n\t    slot = slot ? slot.trim() : '';\n\t    return (slot == slotName);\n\t  };\n\t\n\t  anonymous.prototype.distributeNodeInto = function distributeNodeInto (child, insertionPoint) {\n\t    insertionPoint._assignedNodes.push(child);\n\t    child._assignedSlot = insertionPoint;\n\t  };\n\t\n\t  anonymous.prototype.setDistributedNodesOnInsertionPoint = function setDistributedNodesOnInsertionPoint (insertionPoint) {\n\t    var this$1 = this;\n\t\n\t    var n$ = insertionPoint._assignedNodes;\n\t    insertionPoint._distributedNodes = [];\n\t    for (var i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n\t      if (this$1.isInsertionPoint(n)) {\n\t        var d$ = n._distributedNodes;\n\t        if (d$) {\n\t          for (var j=0; j < d$.length; j++) {\n\t            insertionPoint._distributedNodes.push(d$[j]);\n\t          }\n\t        }\n\t      } else {\n\t        insertionPoint._distributedNodes.push(n$[i]);\n\t      }\n\t    }\n\t  };\n\t\n\t  anonymous.prototype._fireSlotChange = function _fireSlotChange (insertionPoint) {\n\t    // NOTE: cannot bubble correctly here so not setting bubbles: true\n\t    // Safari tech preview does not bubble but chrome does\n\t    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n\t    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n\t    if (insertionPoint._assignedSlot) {\n\t      this._fireSlotChange(insertionPoint._assignedSlot);\n\t    }\n\t  };\n\t\n\t  anonymous.prototype.isFinalDestination = function isFinalDestination (insertionPoint) {\n\t    return !(insertionPoint._assignedSlot);\n\t  };\n\t\n\t  return anonymous;\n\t}())\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t  Implements a pared down version of ShadowDOM's scoping, which is easy to\n\t  polyfill across browsers.\n\t*/\n\tvar ShadyRoot = function ShadyRoot(host) {\n\t  if (!host) {\n\t    throw 'Must provide a host';\n\t  }\n\t  // NOTE: this strange construction is necessary because\n\t  // DocumentFragment cannot be subclassed on older browsers.\n\t  var frag = document.createDocumentFragment();\n\t  frag.__proto__ = ShadyFragmentMixin;\n\t  frag._init(host);\n\t  return frag;\n\t};\n\t\n\tvar ShadyMixin = {\n\t\n\t  _init: function _init(host) {\n\t    // NOTE: set a fake local name so this element can be\n\t    // distinguished from a DocumentFragment when patching.\n\t    // FF doesn't allow this to be `localName`\n\t    this.__localName = 'ShadyRoot';\n\t    // root <=> host\n\t    host.shadyRoot = this;\n\t    this.host = host;\n\t    // logical dom setup\n\t    tree.Logical.saveChildNodes(host);\n\t    tree.Logical.saveChildNodes(this);\n\t    // state flags\n\t    this._clean = true;\n\t    this._hasRendered = false;\n\t    this._distributor = new Distributor(this);\n\t    this.update();\n\t  },\n\t\n\t  // async render the \"top\" distributor (this is all that is needed to\n\t  // distribute this host).\n\t  update: function update() {\n\t    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n\t    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n\t    var distributionRoot = this._findDistributionRoot(this.host);\n\t    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n\t    if (distributionRoot._clean) {\n\t      distributionRoot._clean = false;\n\t      enqueue(function() {\n\t        distributionRoot.render();\n\t      });\n\t    }\n\t  },\n\t\n\t  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n\t  // this should only return a shadowRoot.\n\t  // returns the host that's the top of this host's distribution tree\n\t  _findDistributionRoot: function _findDistributionRoot(element) {\n\t    var root = element.shadyRoot;\n\t    while (element && this._elementNeedsDistribution(element)) {\n\t      root = element.getRootNode();\n\t      element = root && root.host;\n\t    }\n\t    return root;\n\t  },\n\t\n\t  // Return true if a host's children includes\n\t  // an insertion point that selects selectively\n\t  _elementNeedsDistribution: function _elementNeedsDistribution(element) {\n\t    var this$1 = this;\n\t\n\t    var c$ = tree.Logical.getChildNodes(element);\n\t    for (var i=0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(c)) {\n\t        return element.getRootNode();\n\t      }\n\t    }\n\t  },\n\t\n\t  render: function render() {\n\t    if (!this._clean) {\n\t      this._clean = true;\n\t      if (!this._skipUpdateInsertionPoints) {\n\t        this.updateInsertionPoints();\n\t      } else if (!this._hasRendered) {\n\t        this._insertionPoints = [];\n\t      }\n\t      this._skipUpdateInsertionPoints = false;\n\t      // TODO(sorvell): previous ShadyDom had a fast path here\n\t      // that would avoid distribution for initial render if\n\t      // no insertion points exist. We cannot currently do this because\n\t      // it relies on elements being in the physical shadowRoot element\n\t      // so that native methods will be used. The current append code\n\t      // simply provokes distribution in this case and does not put the\n\t      // nodes in the shadowRoot. This could be done but we'll need to\n\t      // consider if the special processing is worth the perf gain.\n\t      // if (!this._hasRendered && !this._insertionPoints.length) {\n\t      //   tree.Composed.clearChildNodes(this.host);\n\t      //   tree.Composed.appendChild(this.host, this);\n\t      // } else {\n\t      // logical\n\t      this.distribute();\n\t      // physical\n\t      this.compose();\n\t      this._hasRendered = true;\n\t    }\n\t  },\n\t\n\t  forceRender: function forceRender() {\n\t    this._clean = false;\n\t    this.render();\n\t  },\n\t\n\t  distribute: function distribute() {\n\t    var dirtyRoots = this._distributor.distribute();\n\t    for (var i=0; i<dirtyRoots.length; i++) {\n\t      dirtyRoots[i].forceRender();\n\t    }\n\t  },\n\t\n\t  updateInsertionPoints: function updateInsertionPoints() {\n\t    var this$1 = this;\n\t\n\t    var i$ = this.__insertionPoints;\n\t    // if any insertion points have been removed, clear their distribution info\n\t    if (i$) {\n\t      for (var i=0, c; i < i$.length; i++) {\n\t        c = i$[i];\n\t        if (c.getRootNode() !== this$1) {\n\t          this$1._distributor.clearAssignedSlots(c);\n\t        }\n\t      }\n\t    }\n\t    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n\t    // ensure insertionPoints's and their parents have logical dom info.\n\t    // save logical tree info\n\t    // a. for shadyRoot\n\t    // b. for insertion points (fallback)\n\t    // c. for parents of insertion points\n\t    for (var i$1=0, c$1; i$1 < i$.length; i$1++) {\n\t      c$1 = i$[i$1];\n\t      tree.Logical.saveChildNodes(c$1);\n\t      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c$1));\n\t    }\n\t  },\n\t\n\t  get _insertionPoints() {\n\t    if (!this.__insertionPoints) {\n\t      this.updateInsertionPoints();\n\t    }\n\t    return this.__insertionPoints || (this.__insertionPoints = []);\n\t  },\n\t\n\t  set _insertionPoints(insertionPoints) {\n\t    this.__insertionPoints = insertionPoints;\n\t  },\n\t\n\t  hasInsertionPoint: function hasInsertionPoint() {\n\t    return this._distributor.hasInsertionPoint();\n\t  },\n\t\n\t  compose: function compose() {\n\t    // compose self\n\t    // note: it's important to mark this clean before distribution\n\t    // so that attachment that provokes additional distribution (e.g.\n\t    // adding something to your parentNode) works\n\t    this._composeTree();\n\t    // TODO(sorvell): See fast paths here in Polymer v1\n\t    // (these seem unnecessary)\n\t  },\n\t\n\t  // Reify dom such that it is at its correct rendering position\n\t  // based on logical distribution.\n\t  _composeTree: function _composeTree() {\n\t    var this$1 = this;\n\t\n\t    this._updateChildNodes(this.host, this._composeNode(this.host));\n\t    var p$ = this._insertionPoints || [];\n\t    for (var i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n\t      parent = tree.Logical.getParentNode(p);\n\t      if ((parent !== this$1.host) && (parent !== this$1)) {\n\t        this$1._updateChildNodes(parent, this$1._composeNode(parent));\n\t      }\n\t    }\n\t  },\n\t\n\t  // Returns the list of nodes which should be rendered inside `node`.\n\t  _composeNode: function _composeNode(node) {\n\t    var this$1 = this;\n\t\n\t    var children = [];\n\t    var c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n\t    for (var i = 0; i < c$.length; i++) {\n\t      var child = c$[i];\n\t      if (this$1._distributor.isInsertionPoint(child)) {\n\t        var distributedNodes = child._distributedNodes ||\n\t          (child._distributedNodes = []);\n\t        for (var j = 0; j < distributedNodes.length; j++) {\n\t          var distributedNode = distributedNodes[j];\n\t          if (this$1.isFinalDestination(child, distributedNode)) {\n\t            children.push(distributedNode);\n\t          }\n\t        }\n\t      } else {\n\t        children.push(child);\n\t      }\n\t    }\n\t    return children;\n\t  },\n\t\n\t  isFinalDestination: function isFinalDestination(insertionPoint, node) {\n\t    return this._distributor.isFinalDestination(\n\t      insertionPoint, node);\n\t  },\n\t\n\t  // Ensures that the rendered node list inside `container` is `children`.\n\t  _updateChildNodes: function _updateChildNodes(container, children) {\n\t    var composed = tree.Composed.getChildNodes(container);\n\t    var splices = calculateSplices(children, composed);\n\t    // process removals\n\t    for (var i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n\t      for (var j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n\t        // check if the node is still where we expect it is before trying\n\t        // to remove it; this can happen if we move a node and\n\t        // then schedule its previous host for distribution resulting in\n\t        // the node being removed here.\n\t        if (tree.Composed.getParentNode(n) === container) {\n\t          tree.Composed.removeChild(container, n);\n\t        }\n\t        composed.splice(s.index + d, 1);\n\t      }\n\t      d -= s.addedCount;\n\t    }\n\t    // process adds\n\t    for (var i$1=0, s$1, next; (i$1<splices.length) && (s$1=splices[i$1]); i$1++) { //eslint-disable-line no-redeclare\n\t      next = composed[s$1.index];\n\t      for (var j$1=s$1.index, n$1; j$1 < s$1.index + s$1.addedCount; j$1++) {\n\t        n$1 = children[j$1];\n\t        tree.Composed.insertBefore(container, n$1, next);\n\t        // TODO(sorvell): is this splice strictly needed?\n\t        composed.splice(j$1, 0, n$1);\n\t      }\n\t    }\n\t  },\n\t\n\t  getInsertionPointTag: function getInsertionPointTag() {\n\t    return this._distributor.insertionPointTag;\n\t  }\n\t\n\t}\n\t\n\tvar ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\n\textend(ShadyFragmentMixin, ShadyMixin);\n\t\n\t// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\t\n\t// function upgradeLogicalChildren(children) {\n\t//   if (needsUpgrade && children) {\n\t//     for (let i=0; i < children.length; i++) {\n\t//       CustomElements.upgrade(children[i]);\n\t//     }\n\t//   }\n\t// }\n\t\n\t// render enqueuer/flusher\n\tvar customElements = window.customElements;\n\tvar flushList = [];\n\tvar scheduled;\n\tvar flushCount = 0;\n\tvar flushMax = 100;\n\tfunction enqueue(callback) {\n\t  if (!scheduled) {\n\t    scheduled = true;\n\t    promish.then(flush$1);\n\t  }\n\t  flushList.push(callback);\n\t}\n\t\n\tfunction flush$1() {\n\t  scheduled = false;\n\t  flushCount++;\n\t  while (flushList.length) {\n\t    flushList.shift()();\n\t  }\n\t  if (customElements && customElements.flush) {\n\t    customElements.flush();\n\t  }\n\t  // continue flushing after elements are upgraded...\n\t  var isFlushedMaxed = (flushCount > flushMax);\n\t  if (flushList.length && !isFlushedMaxed) {\n\t      flush$1();\n\t  }\n\t  flushCount = 0;\n\t  if (isFlushedMaxed) {\n\t    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n\t  }\n\t}\n\t\n\tflush$1.list = flushList;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// Cribbed from ShadowDOM polyfill\n\t// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n\t/////////////////////////////////////////////////////////////////////////////\n\t// innerHTML and outerHTML\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\n\tvar escapeAttrRegExp = /[&\\u00A0\"]/g;\n\tvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\t\n\tfunction escapeReplace(c) {\n\t  switch (c) {\n\t    case '&':\n\t      return '&amp;';\n\t    case '<':\n\t      return '&lt;';\n\t    case '>':\n\t      return '&gt;';\n\t    case '\"':\n\t      return '&quot;';\n\t    case '\\u00A0':\n\t      return '&nbsp;';\n\t  }\n\t}\n\t\n\tfunction escapeAttr(s) {\n\t  return s.replace(escapeAttrRegExp, escapeReplace);\n\t}\n\t\n\tfunction escapeData(s) {\n\t  return s.replace(escapeDataRegExp, escapeReplace);\n\t}\n\t\n\tfunction makeSet(arr) {\n\t  var set = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    set[arr[i]] = true;\n\t  }\n\t  return set;\n\t}\n\t\n\t// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\tvar voidElements = makeSet([\n\t  'area',\n\t  'base',\n\t  'br',\n\t  'col',\n\t  'command',\n\t  'embed',\n\t  'hr',\n\t  'img',\n\t  'input',\n\t  'keygen',\n\t  'link',\n\t  'meta',\n\t  'param',\n\t  'source',\n\t  'track',\n\t  'wbr'\n\t]);\n\t\n\tvar plaintextParents = makeSet([\n\t  'style',\n\t  'script',\n\t  'xmp',\n\t  'iframe',\n\t  'noembed',\n\t  'noframes',\n\t  'plaintext',\n\t  'noscript'\n\t]);\n\t\n\tfunction getOuterHTML(node, parentNode, composed) {\n\t  switch (node.nodeType) {\n\t    case Node.ELEMENT_NODE: {\n\t      var tagName = node.localName;\n\t      var s = '<' + tagName;\n\t      var attrs = node.attributes;\n\t      for (var i = 0, attr; (attr = attrs[i]); i++) {\n\t        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n\t      }\n\t      s += '>';\n\t      if (voidElements[tagName]) {\n\t        return s;\n\t      }\n\t      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n\t    }\n\t    case Node.TEXT_NODE: {\n\t      var data = node.data;\n\t      if (parentNode && plaintextParents[parentNode.localName]) {\n\t        return data;\n\t      }\n\t      return escapeData(data);\n\t    }\n\t    case Node.COMMENT_NODE: {\n\t      return '<!--' + node.data + '-->';\n\t    }\n\t    default: {\n\t      window.console.error(node);\n\t      throw new Error('not implemented');\n\t    }\n\t  }\n\t}\n\t\n\tfunction getInnerHTML(node, composed) {\n\t  if (node.localName === 'template') {\n\t    node = node.content;\n\t  }\n\t  var s = '';\n\t  var c$ = composed ? composed(node) : node.childNodes;\n\t  for (var i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n\t    s += getOuterHTML(child, node, composed);\n\t  }\n\t  return s;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar mixinImpl = {\n\t\n\t  // Try to add node. Record logical info, track insertion points, perform\n\t  // distribution iff needed. Return true if the add is handled.\n\t  addNode: function addNode(container, node, ref_node) {\n\t    var ownerRoot = this.ownerShadyRootForNode(container);\n\t    if (ownerRoot) {\n\t      // optimization: special insertion point tracking\n\t      if (node.__noInsertionPoint && ownerRoot._clean) {\n\t        ownerRoot._skipUpdateInsertionPoints = true;\n\t      }\n\t      // note: we always need to see if an insertion point is added\n\t      // since this saves logical tree info; however, invalidation state\n\t      // needs\n\t      var ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n\t      // invalidate insertion points IFF not already invalid!\n\t      if (ipAdded) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t      }\n\t    }\n\t    if (tree.Logical.hasChildNodes(container)) {\n\t      tree.Logical.recordInsertBefore(node, container, ref_node);\n\t    }\n\t    // if not distributing and not adding to host, do a fast path addition\n\t    var handled = this._maybeDistribute(node, container, ownerRoot) ||\n\t      container.shadyRoot;\n\t    return handled;\n\t  },\n\t\n\t  // Try to remove node: update logical info and perform distribution iff\n\t  // needed. Return true if the removal has been handled.\n\t  // note that it's possible for both the node's host and its parent\n\t  // to require distribution... both cases are handled here.\n\t  removeNode: function removeNode(node) {\n\t    // important that we want to do this only if the node has a logical parent\n\t    var logicalParent = tree.Logical.hasParentNode(node) &&\n\t      tree.Logical.getParentNode(node);\n\t    var distributed;\n\t    var ownerRoot = this.ownerShadyRootForNode(node);\n\t    if (logicalParent) {\n\t      // distribute node's parent iff needed\n\t      distributed = this.maybeDistributeParent(node);\n\t      tree.Logical.recordRemoveChild(node, logicalParent);\n\t      // remove node from root and distribute it iff needed\n\t      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n\t        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n\t        ownerRoot._skipUpdateInsertionPoints = false;\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    this._removeOwnerShadyRoot(node);\n\t    return distributed;\n\t  },\n\t\n\t\n\t  _scheduleObserver: function _scheduleObserver(node, addedNode, removedNode) {\n\t    var observer = node.__dom && node.__dom.observer;\n\t    if (observer) {\n\t      if (addedNode) {\n\t        observer.addedNodes.push(addedNode);\n\t      }\n\t      if (removedNode) {\n\t        observer.removedNodes.push(removedNode);\n\t      }\n\t      observer.schedule();\n\t    }\n\t  },\n\t\n\t  removeNodeFromParent: function removeNodeFromParent(node, parent) {\n\t    if (parent) {\n\t      this._scheduleObserver(parent, null, node);\n\t      this.removeNode(node);\n\t    } else {\n\t      this._removeOwnerShadyRoot(node);\n\t    }\n\t  },\n\t\n\t  _hasCachedOwnerRoot: function _hasCachedOwnerRoot(node) {\n\t    return Boolean(node.__ownerShadyRoot !== undefined);\n\t  },\n\t\n\t  getRootNode: function getRootNode$1(node) {\n\t    if (!node || !node.nodeType) {\n\t      return;\n\t    }\n\t    var root = node.__ownerShadyRoot;\n\t    if (root === undefined) {\n\t      if (isShadyRoot(node)) {\n\t        root = node;\n\t      } else {\n\t        var parent = tree.Logical.getParentNode(node);\n\t        root = parent ? this.getRootNode(parent) : node;\n\t      }\n\t      // memo-ize result for performance but only memo-ize\n\t      // result if node is in the document. This avoids a problem where a root\n\t      // can be cached while an element is inside a fragment.\n\t      // If this happens and we cache the result, the value can become stale\n\t      // because for perf we avoid processing the subtree of added fragments.\n\t      if (document.documentElement.contains(node)) {\n\t        node.__ownerShadyRoot = root;\n\t      }\n\t    }\n\t    return root;\n\t  },\n\t\n\t  ownerShadyRootForNode: function ownerShadyRootForNode(node) {\n\t    var root = this.getRootNode(node);\n\t    if (isShadyRoot(root)) {\n\t      return root;\n\t    }\n\t  },\n\t\n\t  _maybeDistribute: function _maybeDistribute(node, container, ownerRoot) {\n\t    // TODO(sorvell): technically we should check non-fragment nodes for\n\t    // <content> children but since this case is assumed to be exceedingly\n\t    // rare, we avoid the cost and will address with some specific api\n\t    // when the need arises.  For now, the user must call\n\t    // distributeContent(true), which updates insertion points manually\n\t    // and forces distribution.\n\t    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n\t    var fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n\t      !node.__noInsertionPoint &&\n\t      insertionPointTag && node.querySelector(insertionPointTag);\n\t    var wrappedContent = fragContent &&\n\t      (tree.Logical.getParentNode(fragContent).nodeType !==\n\t      Node.DOCUMENT_FRAGMENT_NODE);\n\t    var hasContent = fragContent || (node.localName === insertionPointTag);\n\t    // There are 3 possible cases where a distribution may need to occur:\n\t    // 1. <content> being inserted (the host of the shady root where\n\t    //    content is inserted needs distribution)\n\t    // 2. children being inserted into parent with a shady root (parent\n\t    //    needs distribution)\n\t    // 3. container is an insertionPoint\n\t    if (hasContent || (container.localName === insertionPointTag)) {\n\t      if (ownerRoot) {\n\t        // note, insertion point list update is handled after node\n\t        // mutations are complete\n\t        ownerRoot.update();\n\t      }\n\t    }\n\t    var needsDist = this._nodeNeedsDistribution(container);\n\t    if (needsDist) {\n\t      container.shadyRoot.update();\n\t    }\n\t    // Return true when distribution will fully handle the composition\n\t    // Note that if a content was being inserted that was wrapped by a node,\n\t    // and the parent does not need distribution, return false to allow\n\t    // the nodes to be added directly, after which children may be\n\t    // distributed and composed into the wrapping node(s)\n\t    return needsDist || (hasContent && !wrappedContent);\n\t  },\n\t\n\t  /* note: parent argument is required since node may have an out\n\t  of date parent at this point; returns true if a <content> is being added */\n\t  _maybeAddInsertionPoint: function _maybeAddInsertionPoint(node, parent, root) {\n\t    var this$1 = this;\n\t\n\t    var added;\n\t    var insertionPointTag = root.getInsertionPointTag();\n\t    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n\t      !node.__noInsertionPoint) {\n\t      var c$ = node.querySelectorAll(insertionPointTag);\n\t      for (var i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n\t        np = tree.Logical.getParentNode(n);\n\t        // don't allow node's parent to be fragment itself\n\t        if (np === node) {\n\t          np = parent;\n\t        }\n\t        na = this$1._maybeAddInsertionPoint(n, np, root);\n\t        added = added || na;\n\t      }\n\t    } else if (node.localName === insertionPointTag) {\n\t      tree.Logical.saveChildNodes(parent);\n\t      tree.Logical.saveChildNodes(node);\n\t      added = true;\n\t    }\n\t    return added;\n\t  },\n\t\n\t  _nodeNeedsDistribution: function _nodeNeedsDistribution(node) {\n\t    return node && node.shadyRoot &&\n\t      node.shadyRoot.hasInsertionPoint();\n\t  },\n\t\n\t  _removeDistributedChildren: function _removeDistributedChildren(root, container) {\n\t    var this$1 = this;\n\t\n\t    var hostNeedsDist;\n\t    var ip$ = root._insertionPoints;\n\t    for (var i=0; i<ip$.length; i++) {\n\t      var insertionPoint = ip$[i];\n\t      if (this$1._contains(container, insertionPoint)) {\n\t        var dc$ = insertionPoint.assignedNodes({flatten: true});\n\t        for (var j=0; j<dc$.length; j++) {\n\t          hostNeedsDist = true;\n\t          var node = dc$[j];\n\t          var parent = tree.Composed.getParentNode(node);\n\t          if (parent) {\n\t            tree.Composed.removeChild(parent, node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return hostNeedsDist;\n\t  },\n\t\n\t  _contains: function _contains(container, node) {\n\t    while (node) {\n\t      if (node == container) {\n\t        return true;\n\t      }\n\t      node = tree.Logical.getParentNode(node);\n\t    }\n\t  },\n\t\n\t  _removeOwnerShadyRoot: function _removeOwnerShadyRoot(node) {\n\t    var this$1 = this;\n\t\n\t    // optimization: only reset the tree if node is actually in a root\n\t    if (this._hasCachedOwnerRoot(node)) {\n\t      var c$ = tree.Logical.getChildNodes(node);\n\t      for (var i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n\t        this$1._removeOwnerShadyRoot(n);\n\t      }\n\t    }\n\t    node.__ownerShadyRoot = undefined;\n\t  },\n\t\n\t  // TODO(sorvell): This will fail if distribution that affects this\n\t  // question is pending; this is expected to be exceedingly rare, but if\n\t  // the issue comes up, we can force a flush in this case.\n\t  firstComposedNode: function firstComposedNode(insertionPoint) {\n\t    var n$ = insertionPoint.assignedNodes({flatten: true});\n\t    var root = this.getRootNode(insertionPoint);\n\t    for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n\t      // means that we're composed to this spot.\n\t      if (root.isFinalDestination(insertionPoint, n)) {\n\t        return n;\n\t      }\n\t    }\n\t  },\n\t\n\t  clearNode: function clearNode(node) {\n\t    while (node.firstChild) {\n\t      node.removeChild(node.firstChild);\n\t    }\n\t  },\n\t\n\t  maybeDistributeParent: function maybeDistributeParent(node) {\n\t    var parent = tree.Logical.getParentNode(node);\n\t    if (this._nodeNeedsDistribution(parent)) {\n\t      parent.shadyRoot.update();\n\t      return true;\n\t    }\n\t  },\n\t\n\t  maybeDistributeAttributeChange: function maybeDistributeAttributeChange(node, name) {\n\t    if (name === 'slot') {\n\t      this.maybeDistributeParent(node);\n\t    } else if (node.localName === 'slot' && name === 'name') {\n\t      var root = this.ownerShadyRootForNode(node);\n\t      if (root) {\n\t        root.update();\n\t      }\n\t    }\n\t  },\n\t\n\t  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n\t  // but it's also generally useful to recurse through the element tree\n\t  // and is used by Polymer's styling system.\n\t  query: function query(node, matcher, halter) {\n\t    var list = [];\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t    return list;\n\t  },\n\t\n\t  _queryElements: function _queryElements(elements, matcher, halter, list) {\n\t    var this$1 = this;\n\t\n\t    for (var i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n\t      if (c.nodeType === Node.ELEMENT_NODE &&\n\t          this$1._queryElement(c, matcher, halter, list)) {\n\t        return true;\n\t      }\n\t    }\n\t  },\n\t\n\t  _queryElement: function _queryElement(node, matcher, halter, list) {\n\t    var result = matcher(node);\n\t    if (result) {\n\t      list.push(node);\n\t    }\n\t    if (halter && halter(result)) {\n\t      return result;\n\t    }\n\t    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n\t      halter, list);\n\t  },\n\t\n\t  activeElementForNode: function activeElementForNode(node) {\n\t    var this$1 = this;\n\t\n\t    var active = document.activeElement;\n\t    if (!active) {\n\t      return null;\n\t    }\n\t    var isShadyRoot$$1 = !!(isShadyRoot(node));\n\t    if (node !== document) {\n\t      // If this node isn't a document or shady root, then it doesn't have\n\t      // an active element.\n\t      if (!isShadyRoot$$1) {\n\t        return null;\n\t      }\n\t      // If this shady root's host is the active element or the active\n\t      // element is not a descendant of the host (in the composed tree),\n\t      // then it doesn't have an active element.\n\t      if (node.host === active ||\n\t          !node.host.contains(active)) {\n\t        return null;\n\t      }\n\t    }\n\t    // This node is either the document or a shady root of which the active\n\t    // element is a (composed) descendant of its host; iterate upwards to\n\t    // find the active element's most shallow host within it.\n\t    var activeRoot = this.ownerShadyRootForNode(active);\n\t    while (activeRoot && activeRoot !== node) {\n\t      active = activeRoot.host;\n\t      activeRoot = this$1.ownerShadyRootForNode(active);\n\t    }\n\t    if (node === document) {\n\t      // This node is the document, so activeRoot should be null.\n\t      return activeRoot ? null : active;\n\t    } else {\n\t      // This node is a non-document shady root, and it should be\n\t      // activeRoot.\n\t      return activeRoot === node ? active : null;\n\t    }\n\t  }\n\t\n\t};\n\t\n\tvar nativeCloneNode = Element.prototype.cloneNode;\n\tvar nativeImportNode = Document.prototype.importNode;\n\tvar nativeSetAttribute = Element.prototype.setAttribute;\n\tvar nativeRemoveAttribute = Element.prototype.removeAttribute;\n\t\n\tvar setAttribute = function(attr, value) {\n\t  if (window.ShadyCSS && attr === 'class') {\n\t    window.ShadyCSS.setElementClass(this, value);\n\t  } else {\n\t    nativeSetAttribute.call(this, attr, value);\n\t  }\n\t}\n\t\n\tvar NodeMixin = {};\n\t\n\tObject.defineProperties(NodeMixin, {\n\t\n\t  parentElement: {\n\t    get: function get() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  parentNode: {\n\t    get: function get$1() {\n\t      return tree.Logical.getParentNode(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextSibling: {\n\t    get: function get$2() {\n\t      return tree.Logical.getNextSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousSibling: {\n\t    get: function get$3() {\n\t      return tree.Logical.getPreviousSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  nextElementSibling: {\n\t    get: function get$4() {\n\t      return tree.Logical.getNextElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  previousElementSibling: {\n\t    get: function get$5() {\n\t      return tree.Logical.getPreviousElementSibling(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  assignedSlot: {\n\t    get: function get$6() {\n\t      return this._assignedSlot;\n\t    },\n\t    configurable: true\n\t  }\n\t});\n\t\n\tvar FragmentMixin = {\n\t\n\t  appendChild: function appendChild(node) {\n\t    return this.insertBefore(node);\n\t  },\n\t\n\t  // cases in which we may not be able to just do standard native call\n\t  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n\t  // has an insertion point)\n\t  // 2. container is a shadyRoot (don't distribute, instead set\n\t  // container to container.host.\n\t  // 3. node is <content> (host of container needs distribution)\n\t  insertBefore: function insertBefore(node, ref_node) {\n\t    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n\t      throw Error('The ref_node to be inserted before is not a child ' +\n\t        'of this node');\n\t    }\n\t    // remove node from its current position iff it's in a tree.\n\t    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n\t      var parent = tree.Logical.getParentNode(node);\n\t      mixinImpl.removeNodeFromParent(node, parent);\n\t    }\n\t    if (!mixinImpl.addNode(this, node, ref_node)) {\n\t      if (ref_node) {\n\t        // if ref_node is an insertion point replace with first distributed node\n\t        var root = mixinImpl.ownerShadyRootForNode(ref_node);\n\t        if (root) {\n\t          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n\t            mixinImpl.firstComposedNode(ref_node) : ref_node;\n\t        }\n\t      }\n\t      // if adding to a shadyRoot, add to host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host : this;\n\t      if (ref_node) {\n\t        tree.Composed.insertBefore(container, node, ref_node);\n\t      } else {\n\t        tree.Composed.appendChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, node);\n\t    return node;\n\t  },\n\t\n\t  /**\n\t    Removes the given `node` from the element's `lightChildren`.\n\t    This method also performs dom composition.\n\t  */\n\t  removeChild: function removeChild(node) {\n\t    if (tree.Logical.getParentNode(node) !== this) {\n\t      throw Error('The node to be removed is not a child of this node: ' +\n\t        node);\n\t    }\n\t    if (!mixinImpl.removeNode(node)) {\n\t      // if removing from a shadyRoot, remove form host instead\n\t      var container = isShadyRoot(this) ?\n\t        this.host :\n\t        this;\n\t      // not guaranteed to physically be in container; e.g.\n\t      // undistributed nodes.\n\t      var parent = tree.Composed.getParentNode(node);\n\t      if (container === parent) {\n\t        tree.Composed.removeChild(container, node);\n\t      }\n\t    }\n\t    mixinImpl._scheduleObserver(this, null, node);\n\t    return node;\n\t  },\n\t\n\t  replaceChild: function replaceChild(node, ref_node) {\n\t    this.insertBefore(node, ref_node);\n\t    this.removeChild(ref_node);\n\t    return node;\n\t  },\n\t\n\t  // TODO(sorvell): consider doing native QSA and filtering results.\n\t  querySelector: function querySelector(selector) {\n\t    // match selector and halt on first result.\n\t    var result = mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    }, function(n) {\n\t      return Boolean(n);\n\t    })[0];\n\t    return result || null;\n\t  },\n\t\n\t  querySelectorAll: function querySelectorAll(selector) {\n\t    return mixinImpl.query(this, function(n) {\n\t      return matchesSelector(n, selector);\n\t    });\n\t  },\n\t\n\t  cloneNode: function cloneNode(deep) {\n\t    if (this.localName == 'template') {\n\t      return nativeCloneNode.call(this, deep);\n\t    } else {\n\t      var n = nativeCloneNode.call(this, false);\n\t      if (deep) {\n\t        var c$ = this.childNodes;\n\t        for (var i=0, nc; i < c$.length; i++) {\n\t          nc = c$[i].cloneNode(true);\n\t          n.appendChild(nc);\n\t        }\n\t      }\n\t      return n;\n\t    }\n\t  },\n\t\n\t  importNode: function importNode(externalNode, deep) {\n\t    // for convenience use this node's ownerDoc if the node isn't a document\n\t    var doc = this instanceof Document ? this :\n\t      this.ownerDocument;\n\t    var n = nativeImportNode.call(doc, externalNode, false);\n\t    if (deep) {\n\t      var c$ = tree.Logical.getChildNodes(externalNode);\n\t      common.patchNode(n);\n\t      for (var i=0, nc; i < c$.length; i++) {\n\t        nc = doc.importNode(c$[i], true);\n\t        n.appendChild(nc);\n\t      }\n\t    }\n\t    return n;\n\t  }\n\t};\n\t\n\tObject.defineProperties(FragmentMixin, {\n\t\n\t  childNodes: {\n\t    get: function get$7() {\n\t      var c$ = tree.Logical.getChildNodes(this);\n\t      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  children: {\n\t    get: function get$8() {\n\t      if (tree.Logical.hasChildNodes(this)) {\n\t        return Array.prototype.filter.call(this.childNodes, function(n) {\n\t          return (n.nodeType === Node.ELEMENT_NODE);\n\t        });\n\t      } else {\n\t        return tree.arrayCopyChildren(this);\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstChild: {\n\t    get: function get$9() {\n\t      return tree.Logical.getFirstChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastChild: {\n\t    get: function get$10() {\n\t      return tree.Logical.getLastChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  firstElementChild: {\n\t    get: function get$11() {\n\t      return tree.Logical.getFirstElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  lastElementChild: {\n\t    get: function get$12() {\n\t      return tree.Logical.getLastElementChild(this);\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  // TODO(srovell): strictly speaking fragments do not have textContent\n\t  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n\t  // textContent / innerHTML\n\t  textContent: {\n\t    get: function get$13() {\n\t      if (this.childNodes) {\n\t        var tc = [];\n\t        for (var i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n\t          if (c.nodeType !== Node.COMMENT_NODE) {\n\t            tc.push(c.textContent);\n\t          }\n\t        }\n\t        return tc.join('');\n\t      }\n\t      return '';\n\t    },\n\t    set: function set(text) {\n\t      mixinImpl.clearNode(this);\n\t      if (text) {\n\t        this.appendChild(document.createTextNode(text));\n\t      }\n\t    },\n\t    configurable: true\n\t  },\n\t\n\t  innerHTML: {\n\t    get: function get$14() {\n\t      return getInnerHTML(this);\n\t    },\n\t    set: function set$1(text) {\n\t      var this$1 = this;\n\t\n\t      mixinImpl.clearNode(this);\n\t      var d = document.createElement('div');\n\t      d.innerHTML = text;\n\t      // here, appendChild may move nodes async so we cannot rely\n\t      // on node position when copying\n\t      var c$ = tree.arrayCopyChildNodes(d);\n\t      for (var i=0; i < c$.length; i++) {\n\t        this$1.appendChild(c$[i]);\n\t      }\n\t    },\n\t    configurable: true\n\t  }\n\t\n\t});\n\t\n\tvar ElementMixin = {\n\t\n\t  // TODO(sorvell): should only exist on <slot>\n\t  assignedNodes: function assignedNodes(options) {\n\t    return (options && options.flatten ? this._distributedNodes :\n\t      this._assignedNodes) || [];\n\t  },\n\t\n\t\n\t  setAttribute: function setAttribute$1(name, value) {\n\t    setAttribute.call(this, name, value);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  },\n\t\n\t  removeAttribute: function removeAttribute(name) {\n\t    nativeRemoveAttribute.call(this, name);\n\t    mixinImpl.maybeDistributeAttributeChange(this, name);\n\t  }\n\t\n\t};\n\t\n\tObject.defineProperties(ElementMixin, {\n\t\n\t  shadowRoot: {\n\t    get: function get$15() {\n\t      return this.shadyRoot;\n\t    }\n\t  },\n\t\n\t  slot: {\n\t    get: function get$16() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set$2(value) {\n\t      this.setAttribute('slot', value);\n\t    }\n\t  }\n\t\n\t});\n\t\n\tvar activeElementDescriptor = {\n\t  get: function get$17() {\n\t    return mixinImpl.activeElementForNode(this);\n\t  }\n\t}\n\t\n\tvar ActiveElementMixin = {};\n\tObject.defineProperties(ActiveElementMixin, {\n\t  activeElement: activeElementDescriptor\n\t});\n\t\n\tvar UnderActiveElementMixin = {};\n\tObject.defineProperties(UnderActiveElementMixin, {\n\t  _activeElement: activeElementDescriptor\n\t});\n\t\n\tvar Mixins = {\n\t\n\t  Node: extendAll({__patched: 'Node'}, NodeMixin),\n\t\n\t  Fragment: extendAll({__patched: 'Fragment'},\n\t    NodeMixin, FragmentMixin, ActiveElementMixin),\n\t\n\t  Element: extendAll({__patched: 'Element'},\n\t    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\t\n\t  // Note: activeElement cannot be patched on document!\n\t  Document: extendAll({__patched: 'Document'},\n\t    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\t\n\t};\n\t\n\tvar getRootNode = function(node) {\n\t  return mixinImpl.getRootNode(node);\n\t}\n\t\n\tfunction filterMutations(mutations, target) {\n\t  var targetRootNode = getRootNode(target);\n\t  return mutations.filter(function(mutation) {\n\t    var mutationInScope = (targetRootNode === getRootNode(mutation.target));\n\t    if (mutationInScope && mutation.addedNodes) {\n\t      var nodes = Array.from(mutation.addedNodes).filter(function(n) {\n\t        return (targetRootNode === getRootNode(n));\n\t      });\n\t      Object.defineProperty(mutation, 'addedNodes', {\n\t        value: nodes,\n\t        configurable: true\n\t      });\n\t    }\n\t    return mutationInScope &&\n\t      (!mutation.addedNodes || mutation.addedNodes.length);\n\t  });\n\t}\n\t\n\t// const promise = Promise.resolve();\n\t\n\tvar AsyncObserver = function AsyncObserver() {\n\t  this._scheduled = false;\n\t  this.addedNodes = [];\n\t  this.removedNodes = [];\n\t  this.callbacks = new Set();\n\t};\n\t\n\tAsyncObserver.prototype.schedule = function schedule () {\n\t    var this$1 = this;\n\t\n\t  if (!this._scheduled) {\n\t    this._scheduled = true;\n\t    promish.then(function () {\n\t      this$1.flush();\n\t    });\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.flush = function flush () {\n\t  if (this._scheduled) {\n\t    this._scheduled = false;\n\t    var mutations = this.takeRecords();\n\t    if (mutations.length) {\n\t      this.callbacks.forEach(function(cb) {\n\t        cb(mutations);\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\tAsyncObserver.prototype.takeRecords = function takeRecords () {\n\t  if (this.addedNodes.length || this.removedNodes.length) {\n\t    var mutations = [{\n\t      addedNodes: this.addedNodes,\n\t      removedNodes: this.removedNodes\n\t    }];\n\t    this.addedNodes = [];\n\t    this.removedNodes = [];\n\t    return mutations;\n\t  }\n\t  return [];\n\t};\n\t\n\t// TODO(sorvell): consider instead polyfilling MutationObserver\n\t// directly so that users do not have to fork their code.\n\t// Supporting the entire api may be challenging: e.g. filtering out\n\t// removed nodes in the wrong scope and seeing non-distributing\n\t// subtree child mutations.\n\tvar observeChildren = function(node, callback) {\n\t  common.patchNode(node);\n\t  if (!node.__dom.observer) {\n\t    node.__dom.observer = new AsyncObserver();\n\t  }\n\t  node.__dom.observer.callbacks.add(callback);\n\t  var observer = node.__dom.observer;\n\t  return {\n\t    _callback: callback,\n\t    _observer: observer,\n\t    _node: node,\n\t    takeRecords: function takeRecords() {\n\t      return observer.takeRecords()\n\t    }\n\t  };\n\t}\n\t\n\tvar unobserveChildren = function(handle) {\n\t  var observer = handle && handle._observer;\n\t  if (observer) {\n\t    observer.callbacks.delete(handle._callback);\n\t    if (!observer.callbacks.size) {\n\t      handle._node.__dom.observer = null;\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tvar patchedCount = 0;\n\t\n\tvar log = false;\n\t\n\tvar patchImpl = {\n\t\n\t  canPatchNode: function(node) {\n\t    switch (node) {\n\t      case document.head:\n\t      case document.documentElement:\n\t        return false;\n\t      default:\n\t        return true;\n\t    }\n\t  },\n\t\n\t  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n\t    window.Node.prototype, 'textContent')),\n\t\n\t  patch: function(node) {\n\t    patchedCount++;\n\t    log && window.console.warn('patch node', node);\n\t    if (this.hasPrototypeDescriptors) {\n\t      patchPrototype(node, this.mixinForObject(node));\n\t    } else {\n\t      window.console.warn('Patching instance rather than prototype', node);\n\t      extend(node, this.mixinForNode(node));\n\t    }\n\t  },\n\t\n\t  mixinForObject: function(obj) {\n\t    switch (obj.nodeType) {\n\t      case Node.ELEMENT_NODE:\n\t        return Mixins.Element;\n\t      case Node.DOCUMENT_FRAGMENT_NODE:\n\t        return Mixins.Fragment;\n\t      case Node.DOCUMENT_NODE:\n\t        return Mixins.Document;\n\t      case Node.TEXT_NODE:\n\t      case Node.COMMENT_NODE:\n\t        return Mixins.Node;\n\t    }\n\t  },\n\t\n\t  unpatch: function(obj) {\n\t    if (obj.__sourceProto) {\n\t      obj.__proto__ = obj.__sourceProto;\n\t\n\t    }\n\t    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n\t  }\n\t\n\t};\n\t\n\tfunction patchNode(node) {\n\t  if (!settings.inUse) {\n\t    return;\n\t  }\n\t  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n\t    tree.saveChildNodes(node);\n\t    patchImpl.patch(node);\n\t  }\n\t}\n\t\n\tfunction unpatchNode(node) {\n\t  patchImpl.unpatch(node);\n\t}\n\t\n\tfunction isNodePatched(node) {\n\t  return Boolean(node.__patched);\n\t}\n\t\n\t// TODO(sorvell): fake export\n\tcommon.patchNode = patchNode;\n\tcommon.isNodePatched = isNodePatched;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar origAddEventListener = Element.prototype.addEventListener;\n\tvar origRemoveEventListener = Element.prototype.removeEventListener;\n\t\n\t// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\tvar alwaysComposed = {\n\t  blur: true,\n\t  focus: true,\n\t  focusin: true,\n\t  focusout: true,\n\t  click: true,\n\t  dblclick: true,\n\t  mousedown: true,\n\t  mouseenter: true,\n\t  mouseleave: true,\n\t  mousemove: true,\n\t  mouseout: true,\n\t  mouseover: true,\n\t  mouseup: true,\n\t  wheel: true,\n\t  beforeinput: true,\n\t  input: true,\n\t  keydown: true,\n\t  keyup: true,\n\t  compositionstart: true,\n\t  compositionupdate: true,\n\t  compositionend: true,\n\t  touchstart: true,\n\t  touchend: true,\n\t  touchmove: true,\n\t  touchcancel: true,\n\t  pointerover: true,\n\t  pointerenter: true,\n\t  pointerdown: true,\n\t  pointermove: true,\n\t  pointerup: true,\n\t  pointercancel: true,\n\t  pointerout: true,\n\t  pointerleave: true,\n\t  gotpointercapture: true,\n\t  lostpointercapture: true,\n\t  dragstart: true,\n\t  drag: true,\n\t  dragenter: true,\n\t  dragleave: true,\n\t  dragover: true,\n\t  drop: true,\n\t  dragend: true,\n\t  DOMActivate: true,\n\t  DOMFocusIn: true,\n\t  DOMFocusOut: true,\n\t  keypress: true\n\t};\n\t\n\tfunction pathComposer(startNode, composed) {\n\t  var composedPath = [];\n\t  var current = startNode;\n\t  var startRoot = startNode === window ? window : startNode.getRootNode();\n\t  while (current) {\n\t    composedPath.push(current);\n\t    if (current.assignedSlot) {\n\t      current = current.assignedSlot;\n\t    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n\t      current = current.host;\n\t    } else {\n\t      current = current.parentNode;\n\t    }\n\t  }\n\t  // event composedPath includes window when startNode's ownerRoot is document\n\t  if (composedPath[composedPath.length - 1] === document) {\n\t    composedPath.push(window);\n\t  }\n\t  return composedPath;\n\t}\n\t\n\tfunction retarget(refNode, path) {\n\t  if (!isShadyRoot) {\n\t    return refNode;\n\t  }\n\t  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n\t  // shadow-including inclusive ancestor, return ANCESTOR.\n\t  var refNodePath = pathComposer(refNode, true);\n\t  var p$ = path;\n\t  for (var i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n\t    ancestor = p$[i];\n\t    root = ancestor === window ? window : ancestor.getRootNode();\n\t    if (root !== lastRoot) {\n\t      rootIdx = refNodePath.indexOf(root);\n\t      lastRoot = root;\n\t    }\n\t    if (!isShadyRoot(root) || rootIdx > -1) {\n\t      return ancestor;\n\t    }\n\t  }\n\t}\n\t\n\tvar EventMixin = {\n\t\n\t  __patched: 'Event',\n\t\n\t  get composed() {\n\t    if (this.isTrusted && this.__composed === undefined) {\n\t      this.__composed = alwaysComposed[this.type];\n\t    }\n\t    return this.__composed || false;\n\t  },\n\t\n\t  composedPath: function composedPath() {\n\t    if (!this.__composedPath) {\n\t      this.__composedPath = pathComposer(this.__target, this.composed);\n\t    }\n\t    return this.__composedPath;\n\t  },\n\t\n\t  get target() {\n\t    return retarget(this.currentTarget, this.composedPath());\n\t  },\n\t\n\t  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\t  get relatedTarget() {\n\t    if (!this.__relatedTarget) {\n\t      return null;\n\t    }\n\t    if (!this.__relatedTargetComposedPath) {\n\t      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n\t    }\n\t    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\t    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n\t  },\n\t  stopPropagation: function stopPropagation() {\n\t    Event.prototype.stopPropagation.call(this);\n\t    this.__propagationStopped = true;\n\t  },\n\t  stopImmediatePropagation: function stopImmediatePropagation() {\n\t    Event.prototype.stopImmediatePropagation.call(this);\n\t    this.__immediatePropagationStopped = true;\n\t    this.__propagationStopped = true;\n\t  }\n\t\n\t};\n\t\n\tfunction mixinComposedFlag(Base) {\n\t  // NOTE: avoiding use of `class` here so that transpiled output does not\n\t  // try to do `Base.call` with a dom construtor.\n\t  var klazz = function(type, options) {\n\t    var event = new Base(type, options);\n\t    event.__composed = options && Boolean(options.composed);\n\t    return event;\n\t  }\n\t  // put constructor properties on subclass\n\t  mixin(klazz, Base);\n\t  klazz.prototype = Base.prototype;\n\t  return klazz;\n\t}\n\t\n\tvar nonBubblingEventsToRetarget = {\n\t  focus: true,\n\t  blur: true\n\t};\n\t\n\tfunction fireHandlers(event, node, phase) {\n\t  var hs = node.__handlers && node.__handlers[event.type] &&\n\t    node.__handlers[event.type][phase];\n\t  if (hs) {\n\t    for (var i = 0, fn; (fn = hs[i]); i++) {\n\t      fn.call(node, event);\n\t      if (event.__immediatePropagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction retargetNonBubblingEvent(e) {\n\t  var path = e.composedPath();\n\t  var node;\n\t  // override `currentTarget` to let patched `target` calculate correctly\n\t  Object.defineProperty(e, 'currentTarget', {\n\t    get: function() {\n\t      return node;\n\t    },\n\t    configurable: true\n\t  });\n\t  for (var i = path.length - 1; i >= 0; i--) {\n\t    node = path[i];\n\t    // capture phase fires all capture handlers\n\t    fireHandlers(e, node, 'capture');\n\t    if (e.__propagationStopped) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  // set the event phase to `AT_TARGET` as in spec\n\t  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\t\n\t  // the event only needs to be fired when owner roots change when iterating the event path\n\t  // keep track of the last seen owner root\n\t  var lastFiredRoot;\n\t  for (var i$1 = 0; i$1 < path.length; i$1++) {\n\t    node = path[i$1];\n\t    if (i$1 === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n\t      fireHandlers(e, node, 'bubble');\n\t      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\t      if (node !== window) {\n\t        lastFiredRoot = node.getRootNode();\n\t      }\n\t      if (e.__propagationStopped) {\n\t        return;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction addEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // The callback `fn` might be used for multiple nodes/events. Since we generate\n\t  // a wrapper function, we need to keep track of it when we remove the listener.\n\t  // It's more efficient to store the node/type/options information as Array in\n\t  // `fn` itself rather than the node (we assume that the same callback is used\n\t  // for few nodes at most, whereas a node will likely have many event listeners).\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  if (fn.__eventWrappers) {\n\t    // Stop if the wrapper function has already been created.\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        return;\n\t      }\n\t    }\n\t  } else {\n\t    fn.__eventWrappers = [];\n\t  }\n\t\n\t  var wrapperFn = function(e) {\n\t    // Support `once` option.\n\t    if (once) {\n\t      this.removeEventListener(type, fn, optionsOrCapture);\n\t    }\n\t    if (!e.__target) {\n\t      e.__target = e.target;\n\t      e.__relatedTarget = e.relatedTarget;\n\t      patchPrototype(e, EventMixin);\n\t    }\n\t    // There are two critera that should stop events from firing on this node\n\t    // 1. the event is not composed and the current node is not in the same root as the target\n\t    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\t    if (e.composed || e.composedPath().indexOf(this) > -1) {\n\t      if (e.eventPhase === Event.BUBBLING_PHASE) {\n\t        if (e.target === e.relatedTarget) {\n\t          e.stopImmediatePropagation();\n\t          return;\n\t        }\n\t      }\n\t      return fn(e);\n\t    }\n\t  };\n\t  // Store the wrapper information.\n\t  fn.__eventWrappers.push({\n\t    node: this,\n\t    type: type,\n\t    capture: capture,\n\t    once: once,\n\t    passive: passive,\n\t    wrapperFn: wrapperFn\n\t  });\n\t\n\t  if (nonBubblingEventsToRetarget[type]) {\n\t    this.__handlers = this.__handlers || {};\n\t    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n\t    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n\t  } else {\n\t    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n\t  }\n\t}\n\t\n\tfunction removeEventListener(type, fn, optionsOrCapture) {\n\t  var this$1 = this;\n\t\n\t  if (!fn) {\n\t    return;\n\t  }\n\t\n\t  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\t  var capture, once, passive;\n\t  if (typeof optionsOrCapture === 'object') {\n\t    capture = Boolean(optionsOrCapture.capture);\n\t    once = Boolean(optionsOrCapture.once);\n\t    passive = Boolean(optionsOrCapture.passive);\n\t  } else {\n\t    capture = Boolean(optionsOrCapture);\n\t    once = false;\n\t    passive = false;\n\t  }\n\t  // Search the wrapped function.\n\t  var wrapperFn = undefined;\n\t  if (fn.__eventWrappers) {\n\t    for (var i = 0; i < fn.__eventWrappers.length; i++) {\n\t      if (fn.__eventWrappers[i].node === this$1 &&\n\t          fn.__eventWrappers[i].type === type &&\n\t          fn.__eventWrappers[i].capture === capture &&\n\t          fn.__eventWrappers[i].once === once &&\n\t          fn.__eventWrappers[i].passive === passive) {\n\t        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n\t        // Cleanup.\n\t        if (!fn.__eventWrappers.length) {\n\t          fn.__eventWrappers = undefined;\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n\t  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n\t      this.__handlers && this.__handlers[type]) {\n\t    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\t    var idx = arr.indexOf(wrapperFn);\n\t    if (idx > -1) {\n\t      arr.splice(idx, 1);\n\t    }\n\t  }\n\t}\n\t\n\tfunction activateFocusEventOverrides() {\n\t  for (var ev in nonBubblingEventsToRetarget) {\n\t    window.addEventListener(ev, function(e) {\n\t      if (!e.__target) {\n\t        e.__target = e.target;\n\t        e.__relatedTarget = e.relatedTarget;\n\t        patchPrototype(e, EventMixin);\n\t        retargetNonBubblingEvent(e);\n\t        e.stopImmediatePropagation();\n\t      }\n\t    }, true);\n\t  }\n\t}\n\t\n\t\n\tvar PatchedEvent = mixinComposedFlag(Event);\n\tvar PatchedCustomEvent = mixinComposedFlag(CustomEvent);\n\tvar PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/**\n\t * Patches elements that interacts with ShadyDOM\n\t * such that tree traversal and mutation apis act like they would under\n\t * ShadowDOM.\n\t *\n\t * This import enables seemless interaction with ShadyDOM powered\n\t * custom elements, enabling better interoperation with 3rd party code,\n\t * libraries, and frameworks that use DOM tree manipulation apis.\n\t */\n\t\n\tif (settings.inUse) {\n\t\n\t  window.ShadyDOM = {\n\t    tree: tree,\n\t    getNativeProperty: getNativeProperty,\n\t    patch: patchNode,\n\t    isPatched: isNodePatched,\n\t    unpatch: unpatchNode,\n\t    isShadyRoot: isShadyRoot,\n\t    enqueue: enqueue,\n\t    flush: flush$1,\n\t    inUse: settings.inUse,\n\t    filterMutations: filterMutations,\n\t    observeChildren: observeChildren,\n\t    unobserveChildren: unobserveChildren\n\t  };\n\t\n\t  var createRootAndEnsurePatched = function(node) {\n\t    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n\t    // a timing problem with gathering composed children.\n\t    // (1) currently the child list is crawled and patched when patching occurs\n\t    // (this needs to change)\n\t    // (2) we can only patch when an element has received its parsed children\n\t    // because we cannot detect them when inserted by parser.\n\t    // let ancestor = node;\n\t    // while (ancestor) {\n\t    //   patchNode(ancestor);\n\t    //   ancestor = ancestor.parentNode || ancestor.host;\n\t    // }\n\t    patchNode(node);\n\t    var root = new ShadyRoot(node);\n\t    patchNode(root);\n\t    return root;\n\t  }\n\t\n\t  Element.prototype.attachShadow = function() {\n\t    return createRootAndEnsurePatched(this);\n\t  }\n\t\n\t  Node.prototype.addEventListener = addEventListener;\n\t  Node.prototype.removeEventListener = removeEventListener;\n\t  Event = PatchedEvent;\n\t  CustomEvent = PatchedCustomEvent;\n\t  MouseEvent = PatchedMouseEvent;\n\t  activateFocusEventOverrides();\n\t\n\t  Object.defineProperty(Node.prototype, 'isConnected', {\n\t    get: function get() {\n\t      return document.documentElement.contains(this);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Node.prototype.getRootNode = function(options) {\n\t    return getRootNode(this, options);\n\t  }\n\t\n\t  Object.defineProperty(Element.prototype, 'slot', {\n\t    get: function get$1() {\n\t      return this.getAttribute('slot');\n\t    },\n\t    set: function set(value) {\n\t      this.setAttribute('slot', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Object.defineProperty(Node.prototype, 'assignedSlot', {\n\t    get: function get$2() {\n\t      return this._assignedSlot || null;\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Element.prototype.setAttribute = setAttribute;\n\t\n\t  Object.defineProperty(Element.prototype, 'className', {\n\t    get: function get$3() {\n\t      return this.getAttribute('class');\n\t    },\n\t    set: function set$1(value) {\n\t      this.setAttribute('class', value);\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  // TODO(sorvell): super experimental auto patching of document fragment\n\t  // via appendChild. This either needs to be expanded or contracted.\n\t  // DocumentFragment.prototype.appendChild = function(node) {\n\t  //   patchNode(this);\n\t  //   return this.appendChild(node);\n\t  // }\n\t\n\t}\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadydom.min.js.map\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t(function () {\n\t'use strict';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tExtremely simple css parser. Intended to be not more than what we need\n\tand definitely not necessarily correct =).\n\t*/\n\t\n\t// given a string of css, return a simple rule tree\n\t\n\tfunction parse(text) {\n\t  text = clean(text);\n\t  return parseCss(lex(text), text);\n\t}\n\t\n\t// remove stuff we don't care about that may hinder parsing\n\tfunction clean(cssText) {\n\t  return cssText.replace(RX.comments, '').replace(RX.port, '');\n\t}\n\t\n\t// super simple {...} lexer that returns a node tree\n\tfunction lex(text) {\n\t  var root = {\n\t    start: 0,\n\t    end: text.length\n\t  };\n\t  var n = root;\n\t  for (var i = 0, l = text.length; i < l; i++) {\n\t    if (text[i] === OPEN_BRACE) {\n\t      if (!n.rules) {\n\t        n.rules = [];\n\t      }\n\t      var p = n;\n\t      var previous = p.rules[p.rules.length - 1];\n\t      n = {\n\t        start: i + 1,\n\t        parent: p,\n\t        previous: previous\n\t      };\n\t      p.rules.push(n);\n\t    } else if (text[i] === CLOSE_BRACE) {\n\t      n.end = i + 1;\n\t      n = n.parent || root;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// add selectors/cssText to node tree\n\tfunction parseCss(node, text) {\n\t  var t = text.substring(node.start, node.end - 1);\n\t  node.parsedCssText = node.cssText = t.trim();\n\t  if (node.parent) {\n\t    var ss = node.previous ? node.previous.end : node.parent.start;\n\t    t = text.substring(ss, node.start - 1);\n\t    t = _expandUnicodeEscapes(t);\n\t    t = t.replace(RX.multipleSpaces, ' ');\n\t    // TODO(sorvell): ad hoc; make selector include only after last ;\n\t    // helps with mixin syntax\n\t    t = t.substring(t.lastIndexOf(';') + 1);\n\t    var s = node.parsedSelector = node.selector = t.trim();\n\t    node.atRule = s.indexOf(AT_START) === 0;\n\t    // note, support a subset of rule types...\n\t    if (node.atRule) {\n\t      if (s.indexOf(MEDIA_START) === 0) {\n\t        node.type = types.MEDIA_RULE;\n\t      } else if (s.match(RX.keyframesRule)) {\n\t        node.type = types.KEYFRAMES_RULE;\n\t        node.keyframesName = node.selector.split(RX.multipleSpaces).pop();\n\t      }\n\t    } else {\n\t      if (s.indexOf(VAR_START) === 0) {\n\t        node.type = types.MIXIN_RULE;\n\t      } else {\n\t        node.type = types.STYLE_RULE;\n\t      }\n\t    }\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      parseCss(r, text);\n\t    }\n\t  }\n\t  return node;\n\t}\n\t\n\t// conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n\t// expanded form that doesn't require trailing space `\\000033`\n\tfunction _expandUnicodeEscapes(s) {\n\t  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n\t    var code = arguments[1],\n\t        repeat = 6 - code.length;\n\t    while (repeat--) {\n\t      code = '0' + code;\n\t    }\n\t    return '\\\\' + code;\n\t  });\n\t}\n\t\n\t// stringify parsed css.\n\tfunction stringify(node, preserveProperties, text) {\n\t  text = text || '';\n\t  // calc rule cssText\n\t  var cssText = '';\n\t  if (node.cssText || node.rules) {\n\t    var r$ = node.rules;\n\t    if (r$ && !_hasMixinRules(r$)) {\n\t      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t        cssText = stringify(r, preserveProperties, cssText);\n\t      }\n\t    } else {\n\t      cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);\n\t      cssText = cssText.trim();\n\t      if (cssText) {\n\t        cssText = '  ' + cssText + '\\n';\n\t      }\n\t    }\n\t  }\n\t  // emit rule if there is cssText\n\t  if (cssText) {\n\t    if (node.selector) {\n\t      text += node.selector + ' ' + OPEN_BRACE + '\\n';\n\t    }\n\t    text += cssText;\n\t    if (node.selector) {\n\t      text += CLOSE_BRACE + '\\n\\n';\n\t    }\n\t  }\n\t  return text;\n\t}\n\t\n\tfunction _hasMixinRules(rules) {\n\t  return rules[0].selector.indexOf(VAR_START) === 0;\n\t}\n\t\n\tfunction removeCustomProps(cssText) {\n\t  cssText = removeCustomPropAssignment(cssText);\n\t  return removeCustomPropApply(cssText);\n\t}\n\t\n\tfunction removeCustomPropAssignment(cssText) {\n\t  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n\t}\n\t\n\tfunction removeCustomPropApply(cssText) {\n\t  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n\t}\n\t\n\tvar types = {\n\t  STYLE_RULE: 1,\n\t  KEYFRAMES_RULE: 7,\n\t  MEDIA_RULE: 4,\n\t  MIXIN_RULE: 1000\n\t};\n\t\n\tvar OPEN_BRACE = '{';\n\tvar CLOSE_BRACE = '}';\n\t\n\t// helper regexp's\n\tvar RX = {\n\t  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n\t  port: /@import[^;]*;/gim,\n\t  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n\t  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n\t  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n\t  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n\t  keyframesRule: /^@[^\\s]*keyframes/,\n\t  multipleSpaces: /\\s+/g\n\t};\n\t\n\tvar VAR_START = '--';\n\tvar MEDIA_START = '@media';\n\tvar AT_START = '@';\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar nativeShadow = !(window.ShadyDOM && window.ShadyDOM.inUse);\n\t// chrome 49 has semi-working css vars, check if box-shadow works\n\t// safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n\tvar nativeCssVariables = !navigator.userAgent.match('AppleWebKit/601') && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)');\n\t\n\t// experimental support for native @apply\n\tfunction detectNativeApply() {\n\t  var style = document.createElement('style');\n\t  style.textContent = '.foo { @apply --foo }';\n\t  document.head.appendChild(style);\n\t  var nativeCssApply = style.sheet.cssRules[0].cssText.indexOf('apply') >= 0;\n\t  document.head.removeChild(style);\n\t  return nativeCssApply;\n\t}\n\t\n\tvar nativeCssApply = false && detectNativeApply();\n\t\n\tfunction parseSettings(settings) {\n\t  if (settings) {\n\t    nativeCssVariables = nativeCssVariables && !settings.shimcssproperties;\n\t    nativeShadow = nativeShadow && !settings.shimshadow;\n\t  }\n\t}\n\t\n\tif (window.ShadyCSS) {\n\t  parseSettings(window.ShadyCSS);\n\t} else if (window.WebComponents) {\n\t  parseSettings(window.WebComponents.flags);\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tfunction toCssText(rules, callback) {\n\t  if (typeof rules === 'string') {\n\t    rules = parse(rules);\n\t  }\n\t  if (callback) {\n\t    forEachRule(rules, callback);\n\t  }\n\t  return stringify(rules, nativeCssVariables);\n\t}\n\t\n\tfunction rulesForStyle(style) {\n\t  if (!style.__cssRules && style.textContent) {\n\t    style.__cssRules = parse(style.textContent);\n\t  }\n\t  return style.__cssRules;\n\t}\n\t\n\t// Tests if a rule is a keyframes selector, which looks almost exactly\n\t// like a normal selector but is not (it has nothing to do with scoping\n\t// for example).\n\tfunction isKeyframesSelector(rule) {\n\t  return rule.parent && rule.parent.type === types.KEYFRAMES_RULE;\n\t}\n\t\n\tfunction forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\n\t  if (!node) {\n\t    return;\n\t  }\n\t  var skipRules = false;\n\t  if (onlyActiveRules) {\n\t    if (node.type === types.MEDIA_RULE) {\n\t      var matchMedia = node.selector.match(rx.MEDIA_MATCH);\n\t      if (matchMedia) {\n\t        // if rule is a non matching @media rule, skip subrules\n\t        if (!window.matchMedia(matchMedia[1]).matches) {\n\t          skipRules = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\t  if (node.type === types.STYLE_RULE) {\n\t    styleRuleCallback(node);\n\t  } else if (keyframesRuleCallback && node.type === types.KEYFRAMES_RULE) {\n\t    keyframesRuleCallback(node);\n\t  } else if (node.type === types.MIXIN_RULE) {\n\t    skipRules = true;\n\t  }\n\t  var r$ = node.rules;\n\t  if (r$ && !skipRules) {\n\t    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n\t      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n\t    }\n\t  }\n\t}\n\t\n\t// add a string of cssText to the document.\n\tfunction applyCss(cssText, moniker, target, contextNode) {\n\t  var style = createScopeStyle(cssText, moniker);\n\t  return applyStyle$1(style, target, contextNode);\n\t}\n\t\n\tfunction applyStyle$1(style, target, contextNode) {\n\t  target = target || document.head;\n\t  var after = contextNode && contextNode.nextSibling || target.firstChild;\n\t  lastHeadApplyNode = style;\n\t  return target.insertBefore(style, after);\n\t}\n\t\n\tfunction createScopeStyle(cssText, moniker) {\n\t  var style = document.createElement('style');\n\t  if (moniker) {\n\t    style.setAttribute('scope', moniker);\n\t  }\n\t  style.textContent = cssText;\n\t  return style;\n\t}\n\t\n\tvar lastHeadApplyNode = null;\n\t\n\t// insert a comment node as a styling position placeholder.\n\tfunction applyStylePlaceHolder(moniker) {\n\t  var placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\n\t  var after = lastHeadApplyNode ? lastHeadApplyNode.nextSibling : null;\n\t  var scope = document.head;\n\t  scope.insertBefore(placeHolder, after || scope.firstChild);\n\t  lastHeadApplyNode = placeHolder;\n\t  return placeHolder;\n\t}\n\t\n\t\n\t\n\t// cssBuildTypeForModule: function (module) {\n\t//   let dm = Polymer.DomModule.import(module);\n\t//   if (dm) {\n\t//     return getCssBuildType(dm);\n\t//   }\n\t// },\n\t//\n\t\n\t\n\t// Walk from text[start] matching parens\n\t// returns position of the outer end paren\n\tfunction findMatchingParen(text, start) {\n\t  var level = 0;\n\t  for (var i = start, l = text.length; i < l; i++) {\n\t    if (text[i] === '(') {\n\t      level++;\n\t    } else if (text[i] === ')') {\n\t      if (--level === 0) {\n\t        return i;\n\t      }\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tfunction processVariableAndFallback(str, callback) {\n\t  // find 'var('\n\t  var start = str.indexOf('var(');\n\t  if (start === -1) {\n\t    // no var?, everything is prefix\n\t    return callback(str, '', '', '');\n\t  }\n\t  //${prefix}var(${inner})${suffix}\n\t  var end = findMatchingParen(str, start + 3);\n\t  var inner = str.substring(start + 4, end);\n\t  var prefix = str.substring(0, start);\n\t  // suffix may have other variables\n\t  var suffix = processVariableAndFallback(str.substring(end + 1), callback);\n\t  var comma = inner.indexOf(',');\n\t  // value and fallback args should be trimmed to match in property lookup\n\t  if (comma === -1) {\n\t    // variable, no fallback\n\t    return callback(prefix, inner.trim(), '', suffix);\n\t  }\n\t  // var(${value},${fallback})\n\t  var value = inner.substring(0, comma).trim();\n\t  var fallback = inner.substring(comma + 1).trim();\n\t  return callback(prefix, value, fallback, suffix);\n\t}\n\t\n\tvar rx = {\n\t  VAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\n\t  MIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\n\t  VAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\n\t  ANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\n\t  MEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\n\t  IS_VAR: /^--/,\n\t  BRACKETED: /\\{[^}]*\\}/g,\n\t  HOST_PREFIX: '(?:^|[^.#[:])',\n\t  HOST_SUFFIX: '($|[.:[\\\\s>+~])'\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/* Transforms ShadowDOM styling into ShadyDOM styling\n\t\n\t* scoping:\n\t\n\t  * elements in scope get scoping selector class=\"x-foo-scope\"\n\t  * selectors re-written as follows:\n\t\n\t    div button -> div.x-foo-scope button.x-foo-scope\n\t\n\t* :host -> scopeName\n\t\n\t* :host(...) -> scopeName...\n\t\n\t* ::slotted(...) -> scopeName > ...\n\t\n\t* ...:dir(ltr|rtl) -> [dir=\"ltr|rtl\"] ..., ...[dir=\"ltr|rtl\"]\n\t\n\t* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir=\"rtl\"] scopeName, scopeName[dir=\"rtl\"]\n\t\n\t*/\n\tvar SCOPE_NAME = 'style-scope';\n\t\n\tvar StyleTransformer = {\n\t\n\t  // Given a node and scope name, add a scoping class to each node\n\t  // in the tree. This facilitates transforming css into scoped rules.\n\t  dom: function dom(node, scope, shouldRemoveScope) {\n\t    // one time optimization to skip scoping...\n\t    if (node.__styleScoped) {\n\t      node.__styleScoped = null;\n\t    } else {\n\t      this._transformDom(node, scope || '', shouldRemoveScope);\n\t    }\n\t  },\n\t\n\t  _transformDom: function _transformDom(node, selector, shouldRemoveScope) {\n\t    if (node.classList) {\n\t      this.element(node, selector, shouldRemoveScope);\n\t    }\n\t    var c$ = node.localName === 'template' ? (node.content || node._content).childNodes : node.children || node.childNodes;\n\t    if (c$) {\n\t      for (var i = 0; i < c$.length; i++) {\n\t        this._transformDom(c$[i], selector, shouldRemoveScope);\n\t      }\n\t    }\n\t  },\n\t\n\t  element: function element(_element, scope, shouldRemoveScope) {\n\t    // note: if using classes, we add both the general 'style-scope' class\n\t    // as well as the specific scope. This enables easy filtering of all\n\t    // `style-scope` elements\n\t    if (scope) {\n\t      // note: svg on IE does not have classList so fallback to class\n\t      if (_element.classList) {\n\t        if (shouldRemoveScope) {\n\t          _element.classList.remove(SCOPE_NAME);\n\t          _element.classList.remove(scope);\n\t        } else {\n\t          _element.classList.add(SCOPE_NAME);\n\t          _element.classList.add(scope);\n\t        }\n\t      } else if (_element.getAttribute) {\n\t        var c = _element.getAttribute(CLASS);\n\t        if (shouldRemoveScope) {\n\t          if (c) {\n\t            _element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n\t          }\n\t        } else {\n\t          _element.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t  elementStyles: function elementStyles(element, styleRules, callback) {\n\t    var cssBuildType = element.__cssBuild;\n\t    // no need to shim selectors if settings.useNativeShadow, also\n\t    // a shady css build will already have transformed selectors\n\t    // NOTE: This method may be called as part of static or property shimming.\n\t    // When there is a targeted build it will not be called for static shimming,\n\t    // but when the property shim is used it is called and should opt out of\n\t    // static shimming work when a proper build exists.\n\t    var cssText = nativeShadow || cssBuildType === 'shady' ? toCssText(styleRules, callback) : this.css(styleRules, element.is, element.extends, callback) + '\\n\\n';\n\t    return cssText.trim();\n\t  },\n\t\n\t  // Given a string of cssText and a scoping string (scope), returns\n\t  // a string of scoped css where each selector is transformed to include\n\t  // a class created from the scope. ShadowDOM selectors are also transformed\n\t  // (e.g. :host) to use the scoping selector.\n\t  css: function css(rules, scope, ext, callback) {\n\t    var hostScope = this._calcHostScope(scope, ext);\n\t    scope = this._calcElementScope(scope);\n\t    var self = this;\n\t    return toCssText(rules, function (rule) {\n\t      if (!rule.isScoped) {\n\t        self.rule(rule, scope, hostScope);\n\t        rule.isScoped = true;\n\t      }\n\t      if (callback) {\n\t        callback(rule, scope, hostScope);\n\t      }\n\t    });\n\t  },\n\t\n\t  _calcElementScope: function _calcElementScope(scope) {\n\t    if (scope) {\n\t      return CSS_CLASS_PREFIX + scope;\n\t    } else {\n\t      return '';\n\t    }\n\t  },\n\t\n\t  _calcHostScope: function _calcHostScope(scope, ext) {\n\t    return ext ? '[is=' + scope + ']' : scope;\n\t  },\n\t\n\t  rule: function rule(_rule, scope, hostScope) {\n\t    this._transformRule(_rule, this._transformComplexSelector, scope, hostScope);\n\t  },\n\t\n\t  // transforms a css rule to a scoped rule.\n\t  _transformRule: function _transformRule(rule, transformer, scope, hostScope) {\n\t    // NOTE: save transformedSelector for subsequent matching of elements\n\t    // against selectors (e.g. when calculating style properties)\n\t    rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n\t  },\n\t\n\t  _transformRuleCss: function _transformRuleCss(rule, transformer, scope, hostScope) {\n\t    var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\n\t    // we want to skip transformation of rules that appear in keyframes,\n\t    // because they are keyframe selectors, not element selectors.\n\t    if (!isKeyframesSelector(rule)) {\n\t      for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\n\t        p$[i] = transformer.call(this, p, scope, hostScope);\n\t      }\n\t    }\n\t    return p$.join(COMPLEX_SELECTOR_SEP);\n\t  },\n\t\n\t  _transformComplexSelector: function _transformComplexSelector(selector, scope, hostScope) {\n\t    var _this = this;\n\t\n\t    var stop = false;\n\t    selector = selector.trim();\n\t    // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP\n\t    selector = selector.replace(NTH, function (m, type, inner) {\n\t      return ':' + type + '(' + inner.replace(/\\s/g, '') + ')';\n\t    });\n\t    selector = selector.replace(SLOTTED_START, HOST + ' $1');\n\t    selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\n\t      if (!stop) {\n\t        var info = _this._transformCompoundSelector(s, c, scope, hostScope);\n\t        stop = stop || info.stop;\n\t        c = info.combinator;\n\t        s = info.value;\n\t      }\n\t      return c + s;\n\t    });\n\t    return selector;\n\t  },\n\t\n\t  _transformCompoundSelector: function _transformCompoundSelector(selector, combinator, scope, hostScope) {\n\t    // replace :host with host scoping class\n\t    var slottedIndex = selector.indexOf(SLOTTED);\n\t    if (selector.indexOf(HOST) >= 0) {\n\t      selector = this._transformHostSelector(selector, hostScope);\n\t      // replace other selectors with scoping class\n\t    } else if (slottedIndex !== 0) {\n\t      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n\t    }\n\t    // mark ::slotted() scope jump to replace with descendant selector + arg\n\t    // also ignore left-side combinator\n\t    var slotted = false;\n\t    if (slottedIndex >= 0) {\n\t      combinator = '';\n\t      slotted = true;\n\t    }\n\t    // process scope jumping selectors up to the scope jump and then stop\n\t    var stop = void 0;\n\t    if (slotted) {\n\t      stop = true;\n\t      if (slotted) {\n\t        // .zonk ::slotted(.foo) -> .zonk.scope > .foo\n\t        selector = selector.replace(SLOTTED_PAREN, function (m, paren) {\n\t          return ' > ' + paren;\n\t        });\n\t      }\n\t    }\n\t    selector = selector.replace(DIR_PAREN, function (m, before, dir) {\n\t      return '[dir=\"' + dir + '\"] ' + before + ', ' + before + '[dir=\"' + dir + '\"]';\n\t    });\n\t    return { value: selector, combinator: combinator, stop: stop };\n\t  },\n\t\n\t  _transformSimpleSelector: function _transformSimpleSelector(selector, scope) {\n\t    var p$ = selector.split(PSEUDO_PREFIX);\n\t    p$[0] += scope;\n\t    return p$.join(PSEUDO_PREFIX);\n\t  },\n\t\n\t  // :host(...) -> scopeName...\n\t  _transformHostSelector: function _transformHostSelector(selector, hostScope) {\n\t    var m = selector.match(HOST_PAREN);\n\t    var paren = m && m[2].trim() || '';\n\t    if (paren) {\n\t      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\n\t        // paren starts with a type selector\n\t        var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\n\t        // if the type selector is our hostScope then avoid pre-pending it\n\t        if (typeSelector === hostScope) {\n\t          return paren;\n\t          // otherwise, this selector should not match in this scope so\n\t          // output a bogus selector.\n\t        } else {\n\t          return SELECTOR_NO_MATCH;\n\t        }\n\t      } else {\n\t        // make sure to do a replace here to catch selectors like:\n\t        // `:host(.foo)::before`\n\t        return selector.replace(HOST_PAREN, function (m, host, paren) {\n\t          return hostScope + paren;\n\t        });\n\t      }\n\t      // if no paren, do a straight :host replacement.\n\t      // TODO(sorvell): this should not strictly be necessary but\n\t      // it's needed to maintain support for `:host[foo]` type selectors\n\t      // which have been improperly used under Shady DOM. This should be\n\t      // deprecated.\n\t    } else {\n\t      return selector.replace(HOST, hostScope);\n\t    }\n\t  },\n\t\n\t  documentRule: function documentRule(rule) {\n\t    // reset selector in case this is redone.\n\t    rule.selector = rule.parsedSelector;\n\t    this.normalizeRootSelector(rule);\n\t    this._transformRule(rule, this._transformDocumentSelector);\n\t  },\n\t\n\t  normalizeRootSelector: function normalizeRootSelector(rule) {\n\t    if (rule.selector === ROOT) {\n\t      rule.selector = 'html';\n\t    }\n\t  },\n\t\n\t  _transformDocumentSelector: function _transformDocumentSelector(selector) {\n\t    return selector.match(SLOTTED) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n\t  },\n\t  SCOPE_NAME: SCOPE_NAME\n\t};\n\t\n\tvar NTH = /:(nth[-\\w]+)\\(([^)]+)\\)/;\n\tvar SCOPE_DOC_SELECTOR = ':not(.' + SCOPE_NAME + ')';\n\tvar COMPLEX_SELECTOR_SEP = ',';\n\tvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\n\tvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\n\tvar HOST = ':host';\n\tvar ROOT = ':root';\n\tvar SLOTTED = '::slotted';\n\tvar SLOTTED_START = new RegExp('^(' + SLOTTED + ')');\n\t// NOTE: this supports 1 nested () pair for things like\n\t// :host(:not([selected]), more general support requires\n\t// parsing which seems like overkill\n\tvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\t// similar to HOST_PAREN\n\tvar SLOTTED_PAREN = /(?:::slotted)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\n\tvar DIR_PAREN = /(.*):dir\\((?:(ltr|rtl))\\)/;\n\tvar CSS_CLASS_PREFIX = '.';\n\tvar PSEUDO_PREFIX = ':';\n\tvar CLASS = 'class';\n\tvar SELECTOR_NO_MATCH = 'should_not_match';\n\t\n\tvar classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\t\n\tvar createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar toConsumableArray = function (arr) {\n\t  if (Array.isArray(arr)) {\n\t    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t    return arr2;\n\t  } else {\n\t    return Array.from(arr);\n\t  }\n\t};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar StyleInfo = function () {\n\t  createClass(StyleInfo, null, [{\n\t    key: 'get',\n\t    value: function get(node) {\n\t      return node.__styleInfo;\n\t    }\n\t  }, {\n\t    key: 'set',\n\t    value: function set(node, styleInfo) {\n\t      node.__styleInfo = styleInfo;\n\t      return styleInfo;\n\t    }\n\t  }]);\n\t\n\t  function StyleInfo(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {\n\t    classCallCheck(this, StyleInfo);\n\t\n\t    this.styleRules = ast || null;\n\t    this.placeholder = placeholder || null;\n\t    this.ownStylePropertyNames = ownStylePropertyNames || [];\n\t    this.overrideStyleProperties = {};\n\t    this.elementName = elementName || '';\n\t    this.cssBuild = cssBuild || '';\n\t    this.typeExtension = typeExtension || '';\n\t    this.styleProperties = null;\n\t    this.scopeSelector = null;\n\t    this.customStyle = null;\n\t  }\n\t\n\t  return StyleInfo;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO: dedupe with shady\n\tvar p = window.Element.prototype;\n\tvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\t\n\tvar IS_IE = navigator.userAgent.match('Trident');\n\t\n\tvar StyleProperties = {\n\t\n\t  // decorates styles with rule info and returns an array of used style\n\t  // property names\n\t  decorateStyles: function decorateStyles(rules) {\n\t    var self = this,\n\t        props = {},\n\t        keyframes = [],\n\t        ruleIndex = 0;\n\t    forEachRule(rules, function (rule) {\n\t      self.decorateRule(rule);\n\t      // mark in-order position of ast rule in styles block, used for cache key\n\t      rule.index = ruleIndex++;\n\t      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n\t    }, function onKeyframesRule(rule) {\n\t      keyframes.push(rule);\n\t    });\n\t    // Cache all found keyframes rules for later reference:\n\t    rules._keyframes = keyframes;\n\t    // return this list of property names *consumes* in these styles.\n\t    var names = [];\n\t    for (var i in props) {\n\t      names.push(i);\n\t    }\n\t    return names;\n\t  },\n\t\n\t  // decorate a single rule with property info\n\t  decorateRule: function decorateRule(rule) {\n\t    if (rule.propertyInfo) {\n\t      return rule.propertyInfo;\n\t    }\n\t    var info = {},\n\t        properties = {};\n\t    var hasProperties = this.collectProperties(rule, properties);\n\t    if (hasProperties) {\n\t      info.properties = properties;\n\t      // TODO(sorvell): workaround parser seeing mixins as additional rules\n\t      rule.rules = null;\n\t    }\n\t    info.cssText = this.collectCssText(rule);\n\t    rule.propertyInfo = info;\n\t    return info;\n\t  },\n\t\n\t  // collects the custom properties from a rule's cssText\n\t  collectProperties: function collectProperties(rule, properties) {\n\t    var info = rule.propertyInfo;\n\t    if (info) {\n\t      if (info.properties) {\n\t        Object.assign(properties, info.properties);\n\t        return true;\n\t      }\n\t    } else {\n\t      var m = void 0,\n\t          rx$$1 = this.rx.VAR_ASSIGN;\n\t      var cssText = rule.parsedCssText;\n\t      var value = void 0;\n\t      var any = void 0;\n\t      while (m = rx$$1.exec(cssText)) {\n\t        // note: group 2 is var, 3 is mixin\n\t        value = (m[2] || m[3]).trim();\n\t        // value of 'inherit' or 'unset' is equivalent to not setting the property here\n\t        if (value !== 'inherit' || value !== 'unset') {\n\t          properties[m[1].trim()] = value;\n\t        }\n\t        any = true;\n\t      }\n\t      return any;\n\t    }\n\t  },\n\t\n\t  // returns cssText of properties that consume variables/mixins\n\t  collectCssText: function collectCssText(rule) {\n\t    return this.collectConsumingCssText(rule.parsedCssText);\n\t  },\n\t\n\t  // NOTE: we support consumption inside mixin assignment\n\t  // but not production, so strip out {...}\n\t  collectConsumingCssText: function collectConsumingCssText(cssText) {\n\t    return cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n\t  },\n\t\n\t  collectPropertiesInCssText: function collectPropertiesInCssText(cssText, props) {\n\t    var m = void 0;\n\t    while (m = this.rx.VAR_CONSUMED.exec(cssText)) {\n\t      var name = m[1];\n\t      // This regex catches all variable names, and following non-whitespace char\n\t      // If next char is not ':', then variable is a consumer\n\t      if (m[2] !== ':') {\n\t        props[name] = true;\n\t      }\n\t    }\n\t  },\n\t\n\t  // turns custom properties into realized values.\n\t  reify: function reify(props) {\n\t    // big perf optimization here: reify only *own* properties\n\t    // since this object has __proto__ of the element's scope properties\n\t    var names = Object.getOwnPropertyNames(props);\n\t    for (var i = 0, n; i < names.length; i++) {\n\t      n = names[i];\n\t      props[n] = this.valueForProperty(props[n], props);\n\t    }\n\t  },\n\t\n\t  // given a property value, returns the reified value\n\t  // a property value may be:\n\t  // (1) a literal value like: red or 5px;\n\t  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or\n\t  // var(--a, var(--b));\n\t  // (3) a literal mixin value like { properties }. Each of these properties\n\t  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.\n\t  valueForProperty: function valueForProperty(property, props) {\n\t    var _this = this;\n\t\n\t    // case (1) default\n\t    // case (3) defines a mixin and we have to reify the internals\n\t    if (property) {\n\t      if (property.indexOf(';') >= 0) {\n\t        property = this.valueForProperties(property, props);\n\t      } else {\n\t        (function () {\n\t          // case (2) variable\n\t          var self = _this;\n\t          var fn = function fn(prefix, value, fallback, suffix) {\n\t            if (!value) {\n\t              return prefix + suffix;\n\t            }\n\t            var propertyValue = self.valueForProperty(props[value], props);\n\t            // if value is \"initial\", then the variable should be treated as unset\n\t            if (!propertyValue || propertyValue === 'initial') {\n\t              // fallback may be --a or var(--a) or literal\n\t              propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n\t            } else if (propertyValue === 'apply-shim-inherit') {\n\t              // CSS build will replace `inherit` with `apply-shim-inherit`\n\t              // for use with native css variables.\n\t              // Since we have full control, we can use `inherit` directly.\n\t              propertyValue = 'inherit';\n\t            }\n\t            return prefix + (propertyValue || '') + suffix;\n\t          };\n\t          property = processVariableAndFallback(property, fn);\n\t        })();\n\t      }\n\t    }\n\t    return property && property.trim() || '';\n\t  },\n\t\n\t  // note: we do not yet support mixin within mixin\n\t  valueForProperties: function valueForProperties(property, props) {\n\t    var parts = property.split(';');\n\t    for (var i = 0, _p, m; i < parts.length; i++) {\n\t      if (_p = parts[i]) {\n\t        this.rx.MIXIN_MATCH.lastIndex = 0;\n\t        m = this.rx.MIXIN_MATCH.exec(_p);\n\t        if (m) {\n\t          _p = this.valueForProperty(props[m[1]], props);\n\t        } else {\n\t          var colon = _p.indexOf(':');\n\t          if (colon !== -1) {\n\t            var pp = _p.substring(colon);\n\t            pp = pp.trim();\n\t            pp = this.valueForProperty(pp, props) || pp;\n\t            _p = _p.substring(0, colon) + pp;\n\t          }\n\t        }\n\t        parts[i] = _p && _p.lastIndexOf(';') === _p.length - 1 ?\n\t        // strip trailing ;\n\t        _p.slice(0, -1) : _p || '';\n\t      }\n\t    }\n\t    return parts.join(';');\n\t  },\n\t\n\t  applyProperties: function applyProperties(rule, props) {\n\t    var output = '';\n\t    // dynamically added sheets may not be decorated so ensure they are.\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (rule.propertyInfo.cssText) {\n\t      output = this.valueForProperties(rule.propertyInfo.cssText, props);\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Apply keyframe transformations to the cssText of a given rule. The\n\t  // keyframeTransforms object is a map of keyframe names to transformer\n\t  // functions which take in cssText and spit out transformed cssText.\n\t  applyKeyframeTransforms: function applyKeyframeTransforms(rule, keyframeTransforms) {\n\t    var input = rule.cssText;\n\t    var output = rule.cssText;\n\t    if (rule.hasAnimations == null) {\n\t      // Cache whether or not the rule has any animations to begin with:\n\t      rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n\t    }\n\t    // If there are no animations referenced, we can skip transforms:\n\t    if (rule.hasAnimations) {\n\t      var transform = void 0;\n\t      // If we haven't transformed this rule before, we iterate over all\n\t      // transforms:\n\t      if (rule.keyframeNamesToTransform == null) {\n\t        rule.keyframeNamesToTransform = [];\n\t        for (var keyframe in keyframeTransforms) {\n\t          transform = keyframeTransforms[keyframe];\n\t          output = transform(input);\n\t          // If the transform actually changed the CSS text, we cache the\n\t          // transform name for future use:\n\t          if (input !== output) {\n\t            input = output;\n\t            rule.keyframeNamesToTransform.push(keyframe);\n\t          }\n\t        }\n\t      } else {\n\t        // If we already have a list of keyframe names that apply to this\n\t        // rule, we apply only those keyframe name transforms:\n\t        for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\n\t          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\n\t          input = transform(input);\n\t        }\n\t        output = input;\n\t      }\n\t    }\n\t    rule.cssText = output;\n\t  },\n\t\n\t  // Test if the rules in these styles matches the given `element` and if so,\n\t  // collect any custom properties into `props`.\n\t  propertyDataFromStyles: function propertyDataFromStyles(rules, element) {\n\t    var props = {},\n\t        self = this;\n\t    // generates a unique key for these matches\n\t    var o = [];\n\t    // note: active rules excludes non-matching @media rules\n\t    forEachRule(rules, function (rule) {\n\t      // TODO(sorvell): we could trim the set of rules at declaration\n\t      // time to only include ones that have properties\n\t      if (!rule.propertyInfo) {\n\t        self.decorateRule(rule);\n\t      }\n\t      // match element against transformedSelector: selector may contain\n\t      // unwanted uniquification and parsedSelector does not directly match\n\t      // for :host selectors.\n\t      var selectorToMatch = rule.transformedSelector || rule.parsedSelector;\n\t      if (element && rule.propertyInfo.properties && selectorToMatch) {\n\t        if (matchesSelector.call(element, selectorToMatch)) {\n\t          self.collectProperties(rule, props);\n\t          // produce numeric key for these matches for lookup\n\t          addToBitMask(rule.index, o);\n\t        }\n\t      }\n\t    }, null, true);\n\t    return { properties: props, key: o };\n\t  },\n\t\n\t  whenHostOrRootRule: function whenHostOrRootRule(scope, rule, cssBuild, callback) {\n\t    if (!rule.propertyInfo) {\n\t      this.decorateRule(rule);\n\t    }\n\t    if (!rule.propertyInfo.properties) {\n\t      return;\n\t    }\n\t    var hostScope = scope.is ? StyleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\n\t    var parsedSelector = rule.parsedSelector;\n\t    var isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t    var isHost = parsedSelector.indexOf(':host') === 0 && !isRoot;\n\t    // build info is either in scope (when scope is an element) or in the style\n\t    // when scope is the default scope; note: this allows default scope to have\n\t    // mixed mode built and unbuilt styles.\n\t    if (cssBuild === 'shady') {\n\t      // :root -> x-foo > *.x-foo for elements and html for custom-style\n\t      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\n\t      // :host -> x-foo for elements, but sub-rules have .x-foo in them\n\t      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n\t    }\n\t    if (cssBuild === 'shadow') {\n\t      isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\n\t      isHost = isHost && !isRoot;\n\t    }\n\t    if (!isRoot && !isHost) {\n\t      return;\n\t    }\n\t    var selectorToMatch = hostScope;\n\t    if (isHost) {\n\t      // need to transform :host under ShadowDOM because `:host` does not work with `matches`\n\t      if (nativeShadow && !rule.transformedSelector) {\n\t        // transform :host into a matchable selector\n\t        rule.transformedSelector = StyleTransformer._transformRuleCss(rule, StyleTransformer._transformComplexSelector, StyleTransformer._calcElementScope(scope.is), hostScope);\n\t      }\n\t      selectorToMatch = rule.transformedSelector || hostScope;\n\t    }\n\t    callback({\n\t      selector: selectorToMatch,\n\t      isHost: isHost,\n\t      isRoot: isRoot\n\t    });\n\t  },\n\t\n\t  hostAndRootPropertiesForScope: function hostAndRootPropertiesForScope(scope, rules) {\n\t    var hostProps = {},\n\t        rootProps = {},\n\t        self = this;\n\t    // note: active rules excludes non-matching @media rules\n\t    var cssBuild = rules && rules.__cssBuild;\n\t    forEachRule(rules, function (rule) {\n\t      // if scope is StyleDefaults, use _element for matchesSelector\n\t      self.whenHostOrRootRule(scope, rule, cssBuild, function (info) {\n\t        var element = scope._element || scope;\n\t        if (matchesSelector.call(element, info.selector)) {\n\t          if (info.isHost) {\n\t            self.collectProperties(rule, hostProps);\n\t          } else {\n\t            self.collectProperties(rule, rootProps);\n\t          }\n\t        }\n\t      });\n\t    }, null, true);\n\t    return { rootProps: rootProps, hostProps: hostProps };\n\t  },\n\t\n\t  transformStyles: function transformStyles(element, properties, scopeSelector) {\n\t    var self = this;\n\t    var hostSelector = StyleTransformer._calcHostScope(element.is, element.extends);\n\t    var rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\n\t    var hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\n\t    var rules = StyleInfo.get(element).styleRules;\n\t    var keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);\n\t    return StyleTransformer.elementStyles(element, rules, function (rule) {\n\t      self.applyProperties(rule, properties);\n\t      if (!nativeShadow && !isKeyframesSelector(rule) && rule.cssText) {\n\t        // NOTE: keyframe transforms only scope munge animation names, so it\n\t        // is not necessary to apply them in ShadowDOM.\n\t        self.applyKeyframeTransforms(rule, keyframeTransforms);\n\t        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);\n\t      }\n\t    });\n\t  },\n\t\n\t  _elementKeyframeTransforms: function _elementKeyframeTransforms(element, rules, scopeSelector) {\n\t    var keyframesRules = rules._keyframes;\n\t    var keyframeTransforms = {};\n\t    if (!nativeShadow && keyframesRules) {\n\t      // For non-ShadowDOM, we transform all known keyframes rules in\n\t      // advance for the current scope. This allows us to catch keyframes\n\t      // rules that appear anywhere in the stylesheet:\n\t      for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\n\t        this._scopeKeyframes(keyframesRule, scopeSelector);\n\t        keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n\t      }\n\t    }\n\t    return keyframeTransforms;\n\t  },\n\t\n\t  // Generate a factory for transforming a chunk of CSS text to handle a\n\t  // particular scoped keyframes rule.\n\t  _keyframesRuleTransformer: function _keyframesRuleTransformer(keyframesRule) {\n\t    return function (cssText) {\n\t      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n\t    };\n\t  },\n\t\n\t  // Transforms `@keyframes` names to be unique for the current host.\n\t  // Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0\n\t  _scopeKeyframes: function _scopeKeyframes(rule, scopeId) {\n\t    rule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\n\t    rule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n\t  },\n\t\n\t  // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):\n\t  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo\n\t  // host selector: x-foo.wide -> .x-foo-42.wide\n\t  // note: we use only the scope class (.x-foo-42) and not the hostSelector\n\t  // (x-foo) to scope :host rules; this helps make property host rules\n\t  // have low specificity. They are overrideable by class selectors but,\n\t  // unfortunately, not by type selectors (e.g. overriding via\n\t  // `.special` is ok, but not by `x-foo`).\n\t  _scopeSelector: function _scopeSelector(rule, hostRx, hostSelector, scopeId) {\n\t    rule.transformedSelector = rule.transformedSelector || rule.selector;\n\t    var selector = rule.transformedSelector;\n\t    var scope = '.' + scopeId;\n\t    var parts = selector.split(',');\n\t    for (var i = 0, l = parts.length, _p2; i < l && (_p2 = parts[i]); i++) {\n\t      parts[i] = _p2.match(hostRx) ? _p2.replace(hostSelector, scope) : scope + ' ' + _p2;\n\t    }\n\t    rule.selector = parts.join(',');\n\t  },\n\t\n\t  applyElementScopeSelector: function applyElementScopeSelector(element, selector, old) {\n\t    var c = element.getAttribute('class') || '';\n\t    var v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\n\t    if (c !== v) {\n\t      element.setAttribute('class', v);\n\t    }\n\t  },\n\t\n\t  applyElementStyle: function applyElementStyle(element, properties, selector, style) {\n\t    // calculate cssText to apply\n\t    var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\n\t    // if shady and we have a cached style that is not style, decrement\n\t    var styleInfo = StyleInfo.get(element);\n\t    var s = styleInfo.customStyle;\n\t    if (s && !nativeShadow && s !== style) {\n\t      s._useCount--;\n\t      if (s._useCount <= 0 && s.parentNode) {\n\t        s.parentNode.removeChild(s);\n\t      }\n\t    }\n\t    // apply styling always under native or if we generated style\n\t    // or the cached style is not in document(!)\n\t    if (nativeShadow) {\n\t      // update existing style only under native\n\t      if (styleInfo.customStyle) {\n\t        styleInfo.customStyle.textContent = cssText;\n\t        style = styleInfo.customStyle;\n\t        // otherwise, if we have css to apply, do so\n\t      } else if (cssText) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);\n\t      }\n\t    } else {\n\t      // shady and no cache hit\n\t      if (!style) {\n\t        // apply css after the scope style of the element to help with\n\t        // style precedence rules.\n\t        if (cssText) {\n\t          style = applyCss(cssText, selector, null, styleInfo.placeholder);\n\t        }\n\t        // shady and cache hit but not in document\n\t      } else if (!style.parentNode) {\n\t        applyStyle$1(style, null, styleInfo.placeholder);\n\t      }\n\t    }\n\t    // ensure this style is our custom style and increment its use count.\n\t    if (style) {\n\t      style._useCount = style._useCount || 0;\n\t      // increment use count if we changed styles\n\t      if (styleInfo.customStyle != style) {\n\t        style._useCount++;\n\t      }\n\t      styleInfo.customStyle = style;\n\t    }\n\t    // @media rules may be stale in IE 10 and 11\n\t    if (IS_IE) {\n\t      style.textContent = style.textContent;\n\t    }\n\t    return style;\n\t  },\n\t\n\t  applyCustomStyle: function applyCustomStyle(style, properties) {\n\t    var rules = rulesForStyle(style);\n\t    var self = this;\n\t    style.textContent = toCssText(rules, function (rule) {\n\t      var css = rule.cssText = rule.parsedCssText;\n\t      if (rule.propertyInfo && rule.propertyInfo.cssText) {\n\t        // remove property assignments\n\t        // so next function isn't confused\n\t        // NOTE: we have 3 categories of css:\n\t        // (1) normal properties,\n\t        // (2) custom property assignments (--foo: red;),\n\t        // (3) custom property usage: border: var(--foo); @apply(--foo);\n\t        // In elements, 1 and 3 are separated for efficiency; here they\n\t        // are not and this makes this case unique.\n\t        css = removeCustomPropAssignment(css);\n\t        // replace with reified properties, scenario is same as mixin\n\t        rule.cssText = self.valueForProperties(css, properties);\n\t      }\n\t    });\n\t  },\n\t\n\t  rx: rx,\n\t  XSCOPE_NAME: 'x-scope'\n\t};\n\t\n\tfunction addToBitMask(n, bits) {\n\t  var o = parseInt(n / 32);\n\t  var v = 1 << n % 32;\n\t  bits[o] = (bits[o] || 0) | v;\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar templateMap = {};\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar placeholderMap = {};\n\t\n\tvar ce = window.customElements;\n\tif (ce && !nativeShadow) {\n\t  (function () {\n\t    var origDefine = ce.define;\n\t    ce.define = function (name, clazz, options) {\n\t      placeholderMap[name] = applyStylePlaceHolder(name);\n\t      return origDefine.call(ce, name, clazz, options);\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\tvar StyleCache = function () {\n\t  function StyleCache() {\n\t    var typeMax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n\t    classCallCheck(this, StyleCache);\n\t\n\t    // map element name -> [{properties, styleElement, scopeSelector}]\n\t    this.cache = {};\n\t    this.typeMax = typeMax;\n\t  }\n\t\n\t  createClass(StyleCache, [{\n\t    key: '_validate',\n\t    value: function _validate(cacheEntry, properties, ownPropertyNames) {\n\t      for (var idx = 0; idx < ownPropertyNames.length; idx++) {\n\t        var pn = ownPropertyNames[idx];\n\t        if (cacheEntry.properties[pn] !== properties[pn]) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'store',\n\t    value: function store(tagname, properties, styleElement, scopeSelector) {\n\t      var list = this.cache[tagname] || [];\n\t      list.push({ properties: properties, styleElement: styleElement, scopeSelector: scopeSelector });\n\t      if (list.length > this.typeMax) {\n\t        list.shift();\n\t      }\n\t      this.cache[tagname] = list;\n\t    }\n\t  }, {\n\t    key: 'fetch',\n\t    value: function fetch(tagname, properties, ownPropertyNames) {\n\t      var list = this.cache[tagname];\n\t      if (!list) {\n\t        return;\n\t      }\n\t      // reverse list for most-recent lookups\n\t      for (var idx = list.length - 1; idx >= 0; idx--) {\n\t        var entry = list[idx];\n\t        if (this._validate(entry, properties, ownPropertyNames)) {\n\t          return entry;\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t  return StyleCache;\n\t}();\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/**\n\t * The apply shim simulates the behavior of `@apply` proposed at\n\t * https://tabatkins.github.io/specs/css-apply-rule/.\n\t * The approach is to convert a property like this:\n\t *\n\t *    --foo: {color: red; background: blue;}\n\t *\n\t * to this:\n\t *\n\t *    --foo_-_color: red;\n\t *    --foo_-_background: blue;\n\t *\n\t * Then where `@apply --foo` is used, that is converted to:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background);\n\t *\n\t * This approach generally works but there are some issues and limitations.\n\t * Consider, for example, that somewhere *between* where `--foo` is set and used,\n\t * another element sets it to:\n\t *\n\t *    --foo: { border: 2px solid red; }\n\t *\n\t * We must now ensure that the color and background from the previous setting\n\t * do not apply. This is accomplished by changing the property set to this:\n\t *\n\t *    --foo_-_border: 2px solid red;\n\t *    --foo_-_color: initial;\n\t *    --foo_-_background: initial;\n\t *\n\t * This works but introduces one new issue.\n\t * Consider this setup at the point where the `@apply` is used:\n\t *\n\t *    background: orange;\n\t *    @apply --foo;\n\t *\n\t * In this case the background will be unset (initial) rather than the desired\n\t * `orange`. We address this by altering the property set to use a fallback\n\t * value like this:\n\t *\n\t *    color: var(--foo_-_color);\n\t *    background: var(--foo_-_background, orange);\n\t *    border: var(--foo_-_border);\n\t *\n\t * Note that the default is retained in the property set and the `background` is\n\t * the desired `orange`. This leads us to a limitation.\n\t *\n\t * Limitation 1:\n\t\n\t * Only properties in the rule where the `@apply`\n\t * is used are considered as default values.\n\t * If another rule matches the element and sets `background` with\n\t * less specificity than the rule in which `@apply` appears,\n\t * the `background` will not be set.\n\t *\n\t * Limitation 2:\n\t *\n\t * When using Polymer's `updateStyles` api, new properties may not be set for\n\t * `@apply` properties.\n\t\n\t*/\n\t\n\tvar MIXIN_MATCH = rx.MIXIN_MATCH;\n\tvar VAR_ASSIGN = rx.VAR_ASSIGN;\n\t\n\tvar APPLY_NAME_CLEAN = /;\\s*/m;\n\tvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\n\t\n\t// separator used between mixin-name and mixin-property-name when producing properties\n\t// NOTE: plain '-' may cause collisions in user styles\n\tvar MIXIN_VAR_SEP = '_-_';\n\t\n\t// map of mixin to property names\n\t// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\t\n\tvar MixinMap = function () {\n\t  function MixinMap() {\n\t    classCallCheck(this, MixinMap);\n\t\n\t    this._map = {};\n\t  }\n\t\n\t  createClass(MixinMap, [{\n\t    key: 'set',\n\t    value: function set(name, props) {\n\t      name = name.trim();\n\t      this._map[name] = {\n\t        properties: props,\n\t        dependants: {}\n\t      };\n\t    }\n\t  }, {\n\t    key: 'get',\n\t    value: function get(name) {\n\t      name = name.trim();\n\t      return this._map[name];\n\t    }\n\t  }]);\n\t  return MixinMap;\n\t}();\n\t\n\tvar ApplyShim = function () {\n\t  function ApplyShim() {\n\t    var _this = this;\n\t\n\t    classCallCheck(this, ApplyShim);\n\t\n\t    this._currentTemplate = null;\n\t    this._measureElement = null;\n\t    this._map = new MixinMap();\n\t    this._separator = MIXIN_VAR_SEP;\n\t    this._boundProduceCssProperties = function (matchText, propertyName, valueProperty, valueMixin) {\n\t      return _this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin);\n\t    };\n\t  }\n\t\n\t  createClass(ApplyShim, [{\n\t    key: 'transformStyle',\n\t    value: function transformStyle(style, elementName) {\n\t      var ast = rulesForStyle(style);\n\t      this.transformRules(ast, elementName);\n\t      return ast;\n\t    }\n\t  }, {\n\t    key: 'transformRules',\n\t    value: function transformRules(rules, elementName) {\n\t      var _this2 = this;\n\t\n\t      this._currentTemplate = templateMap[elementName];\n\t      forEachRule(rules, function (r) {\n\t        _this2.transformRule(r);\n\t      });\n\t      if (this._currentTemplate) {\n\t        this._currentTemplate.__applyShimInvalid = false;\n\t      }\n\t      this._currentTemplate = null;\n\t    }\n\t  }, {\n\t    key: 'transformRule',\n\t    value: function transformRule(rule) {\n\t      rule.cssText = this.transformCssText(rule.parsedCssText);\n\t      // :root was only used for variable assignment in property shim,\n\t      // but generates invalid selectors with real properties.\n\t      // replace with `:host > *`, which serves the same effect\n\t      if (rule.selector === ':root') {\n\t        rule.selector = ':host > *';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'transformCssText',\n\t    value: function transformCssText(cssText) {\n\t      // produce variables\n\t      cssText = cssText.replace(VAR_ASSIGN, this._boundProduceCssProperties);\n\t      // consume mixins\n\t      return this._consumeCssProperties(cssText);\n\t    }\n\t  }, {\n\t    key: '_getInitialValueForProperty',\n\t    value: function _getInitialValueForProperty(property) {\n\t      if (!this._measureElement) {\n\t        this._measureElement = document.createElement('meta');\n\t        this._measureElement.style.all = 'initial';\n\t        document.head.appendChild(this._measureElement);\n\t      }\n\t      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n\t    }\n\t    // replace mixin consumption with variable consumption\n\t\n\t  }, {\n\t    key: '_consumeCssProperties',\n\t    value: function _consumeCssProperties(text) {\n\t      var m = void 0;\n\t      // loop over text until all mixins with defintions have been applied\n\t      while (m = MIXIN_MATCH.exec(text)) {\n\t        var matchText = m[0];\n\t        var mixinName = m[1];\n\t        var idx = m.index;\n\t        // collect properties before apply to be \"defaults\" if mixin might override them\n\t        // match includes a \"prefix\", so find the start and end positions of @apply\n\t        var applyPos = idx + matchText.indexOf('@apply');\n\t        var afterApplyPos = idx + matchText.length;\n\t        // find props defined before this @apply\n\t        var textBeforeApply = text.slice(0, applyPos);\n\t        var textAfterApply = text.slice(afterApplyPos);\n\t        var defaults$$1 = this._cssTextToMap(textBeforeApply);\n\t        var replacement = this._atApplyToCssProperties(mixinName, defaults$$1);\n\t        // use regex match position to replace mixin, keep linear processing time\n\t        text = [textBeforeApply, replacement, textAfterApply].join('');\n\t        // move regex search to _after_ replacement\n\t        MIXIN_MATCH.lastIndex = idx + replacement.length;\n\t      }\n\t      return text;\n\t    }\n\t    // produce variable consumption at the site of mixin consumption\n\t    // @apply --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n\t    // Example:\n\t    // border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n\t\n\t  }, {\n\t    key: '_atApplyToCssProperties',\n\t    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n\t      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n\t      var vars = [];\n\t      var mixinEntry = this._map.get(mixinName);\n\t      // if we depend on a mixin before it is created\n\t      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\t      if (!mixinEntry) {\n\t        this._map.set(mixinName, {});\n\t        mixinEntry = this._map.get(mixinName);\n\t      }\n\t      if (mixinEntry) {\n\t        if (this._currentTemplate) {\n\t          mixinEntry.dependants[this._currentTemplate.name] = this._currentTemplate;\n\t        }\n\t        var p = void 0,\n\t            parts = void 0,\n\t            f = void 0;\n\t        for (p in mixinEntry.properties) {\n\t          f = fallbacks && fallbacks[p];\n\t          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\t          if (f) {\n\t            parts.push(',', f);\n\t          }\n\t          parts.push(')');\n\t          vars.push(parts.join(''));\n\t        }\n\t      }\n\t      return vars.join('; ');\n\t    }\n\t  }, {\n\t    key: '_replaceInitialOrInherit',\n\t    value: function _replaceInitialOrInherit(property, value) {\n\t      var match = INITIAL_INHERIT.exec(value);\n\t      if (match) {\n\t        if (match[1]) {\n\t          // initial\n\t          // replace `initial` with the concrete initial value for this property\n\t          value = ApplyShim._getInitialValueForProperty(property);\n\t        } else {\n\t          // inherit\n\t          // with this purposfully illegal value, the variable will be invalid at\n\t          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n\t          // and for inheriting values, will behave similarly\n\t          // we cannot support the same behavior for non inheriting values like 'border'\n\t          value = 'apply-shim-inherit';\n\t        }\n\t      }\n\t      return value;\n\t    }\n\t\n\t    // \"parse\" a mixin definition into a map of properties and values\n\t    // cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n\t\n\t  }, {\n\t    key: '_cssTextToMap',\n\t    value: function _cssTextToMap(text) {\n\t      var props = text.split(';');\n\t      var property = void 0,\n\t          value = void 0;\n\t      var out = {};\n\t      for (var i = 0, p, sp; i < props.length; i++) {\n\t        p = props[i];\n\t        if (p) {\n\t          sp = p.split(':');\n\t          // ignore lines that aren't definitions like @media\n\t          if (sp.length > 1) {\n\t            property = sp[0].trim();\n\t            // some properties may have ':' in the value, like data urls\n\t            value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));\n\t            out[property] = value;\n\t          }\n\t        }\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_invalidateMixinEntry',\n\t    value: function _invalidateMixinEntry(mixinEntry) {\n\t      for (var elementName in mixinEntry.dependants) {\n\t        if (elementName !== this._currentTemplate) {\n\t          mixinEntry.dependants[elementName].__applyShimInvalid = true;\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_produceCssProperties',\n\t    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\n\t      var _this3 = this;\n\t\n\t      // handle case where property value is a mixin\n\t      if (valueProperty) {\n\t        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n\t        processVariableAndFallback(valueProperty, function (prefix, value) {\n\t          if (value && _this3._map.get(value)) {\n\t            valueMixin = '@apply ' + value + ';';\n\t          }\n\t        });\n\t      }\n\t      if (!valueMixin) {\n\t        return matchText;\n\t      }\n\t      var mixinAsProperties = this._consumeCssProperties(valueMixin);\n\t      var prefix = matchText.slice(0, matchText.indexOf('--'));\n\t      var mixinValues = this._cssTextToMap(mixinAsProperties);\n\t      var combinedProps = mixinValues;\n\t      var mixinEntry = this._map.get(propertyName);\n\t      var oldProps = mixinEntry && mixinEntry.properties;\n\t      if (oldProps) {\n\t        // NOTE: since we use mixin, the map of properties is updated here\n\t        // and this is what we want.\n\t        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n\t      } else {\n\t        this._map.set(propertyName, combinedProps);\n\t      }\n\t      var out = [];\n\t      var p = void 0,\n\t          v = void 0;\n\t      // set variables defined by current mixin\n\t      var needToInvalidate = false;\n\t      for (p in combinedProps) {\n\t        v = mixinValues[p];\n\t        // if property not defined by current mixin, set initial\n\t        if (v === undefined) {\n\t          v = 'initial';\n\t        }\n\t        if (oldProps && !(p in oldProps)) {\n\t          needToInvalidate = true;\n\t        }\n\t        out.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n\t      }\n\t      if (needToInvalidate) {\n\t        this._invalidateMixinEntry(mixinEntry);\n\t      }\n\t      if (mixinEntry) {\n\t        mixinEntry.properties = combinedProps;\n\t      }\n\t      // because the mixinMap is global, the mixin might conflict with\n\t      // a different scope's simple variable definition:\n\t      // Example:\n\t      // some style somewhere:\n\t      // --mixin1:{ ... }\n\t      // --mixin2: var(--mixin1);\n\t      // some other element:\n\t      // --mixin1: 10px solid red;\n\t      // --foo: var(--mixin1);\n\t      // In this case, we leave the original variable definition in place.\n\t      if (valueProperty) {\n\t        prefix = matchText + ';' + prefix;\n\t      }\n\t      return prefix + out.join('; ') + ';';\n\t    }\n\t  }]);\n\t  return ApplyShim;\n\t}();\n\t\n\tvar applyShim = new ApplyShim();\n\twindow['ApplyShim'] = applyShim;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\tvar flush = function flush() {};\n\t\n\tif (!nativeShadow) {\n\t  (function () {\n\t    var handler = function handler(mxns) {\n\t      for (var x = 0; x < mxns.length; x++) {\n\t        var mxn = mxns[x];\n\t        for (var i = 0; i < mxn.addedNodes.length; i++) {\n\t          var n = mxn.addedNodes[i];\n\t          if (n.nodeType === Node.ELEMENT_NODE && !n.classList.contains(StyleTransformer.SCOPE_NAME)) {\n\t            var root = n.getRootNode();\n\t            if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t              // may no longer be in a shadowroot\n\t              var host = root.host;\n\t              if (host) {\n\t                var scope = host.is || host.localName;\n\t                StyleTransformer.dom(n, scope);\n\t              }\n\t            }\n\t          }\n\t        }\n\t        for (var _i = 0; _i < mxn.removedNodes.length; _i++) {\n\t          var _n = mxn.removedNodes[_i];\n\t          if (_n.nodeType === Node.ELEMENT_NODE) {\n\t            var classIdx = Array.from(_n.classList).indexOf(StyleTransformer.SCOPE_NAME);\n\t            if (classIdx >= 0) {\n\t              // NOTE: relies on the scoping class always being adjacent to the\n\t              // SCOPE_NAME class.\n\t              var _scope = _n.classList[classIdx + 1];\n\t              if (_scope) {\n\t                StyleTransformer.dom(_n, _scope, true);\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    var observer = new MutationObserver(handler);\n\t    var startState = 'interactive';\n\t\n\t    var start = function start() {\n\t      return observer.observe(document.body, { childList: true, subtree: true });\n\t    };\n\t    if (window.HTMLImports) {\n\t      window.HTMLImports.whenReady(start);\n\t    } else if (document.readyState === startState) {\n\t      requestAnimationFrame(start);\n\t    } else {\n\t      document.addEventListener('readystatechange', function () {\n\t        if (document.readyState === startState) {\n\t          start();\n\t        }\n\t      });\n\t    }\n\t\n\t    flush = function flush() {\n\t      handler(observer.takeRecords());\n\t    };\n\t  })();\n\t}\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t// TODO(dfreedm): consider spliting into separate global\n\tvar styleCache = new StyleCache();\n\t\n\tvar ShadyCSS = {\n\t  flush: flush,\n\t  scopeCounter: {},\n\t  nativeShadow: nativeShadow,\n\t  nativeCss: nativeCssVariables,\n\t  nativeCssApply: nativeCssApply,\n\t  _documentOwner: document.documentElement,\n\t  _documentOwnerStyleInfo: StyleInfo.set(document.documentElement, new StyleInfo({ rules: [] })),\n\t  _generateScopeSelector: function _generateScopeSelector(name) {\n\t    var id = this.scopeCounter[name] = (this.scopeCounter[name] || 0) + 1;\n\t    return name + '-' + id;\n\t  },\n\t  getStyleAst: function getStyleAst(style) {\n\t    return rulesForStyle(style);\n\t  },\n\t  styleAstToString: function styleAstToString(ast) {\n\t    return toCssText(ast);\n\t  },\n\t  _gatherStyles: function _gatherStyles(template) {\n\t    var styles = template.content.querySelectorAll('style');\n\t    var cssText = [];\n\t    for (var i = 0; i < styles.length; i++) {\n\t      var s = styles[i];\n\t      cssText.push(s.textContent);\n\t      s.parentNode.removeChild(s);\n\t    }\n\t    return cssText.join('').trim();\n\t  },\n\t  _getCssBuild: function _getCssBuild(template) {\n\t    var style = template.content.querySelector('style');\n\t    if (!style) {\n\t      return '';\n\t    }\n\t    return style.getAttribute('css-build') || '';\n\t  },\n\t  prepareTemplate: function prepareTemplate(template, elementName, typeExtension) {\n\t    if (template._prepared) {\n\t      return;\n\t    }\n\t    template._prepared = true;\n\t    template.name = elementName;\n\t    template.extends = typeExtension;\n\t    templateMap[elementName] = template;\n\t    var cssBuild = this._getCssBuild(template);\n\t    var cssText = this._gatherStyles(template);\n\t    var info = {\n\t      is: elementName,\n\t      extends: typeExtension,\n\t      __cssBuild: cssBuild\n\t    };\n\t    if (!this.nativeShadow) {\n\t      StyleTransformer.dom(template.content, elementName);\n\t    }\n\t    var ast = parse(cssText);\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      applyShim.transformRules(ast, elementName);\n\t    }\n\t    template._styleAst = ast;\n\t\n\t    var ownPropertyNames = [];\n\t    if (!this.nativeCss) {\n\t      ownPropertyNames = StyleProperties.decorateStyles(template._styleAst, info);\n\t    }\n\t    if (!ownPropertyNames.length || this.nativeCss) {\n\t      var root = this.nativeShadow ? template.content : null;\n\t      var placeholder = placeholderMap[elementName];\n\t      var style = this._generateStaticStyle(info, template._styleAst, root, placeholder);\n\t      template._style = style;\n\t    }\n\t    template._ownPropertyNames = ownPropertyNames;\n\t  },\n\t  _generateStaticStyle: function _generateStaticStyle(info, rules, shadowroot, placeholder) {\n\t    var cssText = StyleTransformer.elementStyles(info, rules);\n\t    if (cssText.length) {\n\t      return applyCss(cssText, info.is, shadowroot, placeholder);\n\t    }\n\t  },\n\t  _prepareHost: function _prepareHost(host) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var typeExtension = void 0;\n\t    if (is !== host.localName) {\n\t      typeExtension = host.localName;\n\t    }\n\t    var placeholder = placeholderMap[is];\n\t    var template = templateMap[is];\n\t    var ast = void 0;\n\t    var ownStylePropertyNames = void 0;\n\t    var cssBuild = void 0;\n\t    if (template) {\n\t      ast = template._styleAst;\n\t      ownStylePropertyNames = template._ownPropertyNames;\n\t      cssBuild = template._cssBuild;\n\t    }\n\t    return StyleInfo.set(host, new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild));\n\t  },\n\t  applyStyle: function applyStyle(host, overrideProps) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    if (window.CustomStyle) {\n\t      var CS = window.CustomStyle;\n\t      if (CS._documentDirty) {\n\t        CS.findStyles();\n\t        if (!this.nativeCss) {\n\t          this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);\n\t        } else if (!this.nativeCssApply) {\n\t          CS._revalidateApplyShim();\n\t        }\n\t        CS.applyStyles();\n\t        CS._documentDirty = false;\n\t      }\n\t    }\n\t    var styleInfo = StyleInfo.get(host);\n\t    if (!styleInfo) {\n\t      styleInfo = this._prepareHost(host);\n\t    }\n\t    Object.assign(styleInfo.overrideStyleProperties, overrideProps);\n\t    if (this.nativeCss) {\n\t      var template = templateMap[is];\n\t      if (template && template.__applyShimInvalid && template._style) {\n\t        // update template\n\t        applyShim.transformRules(template._styleAst, is);\n\t        template._style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        // update instance if native shadowdom\n\t        if (this.nativeShadow) {\n\t          var style = host.shadowRoot.querySelector('style');\n\t          style.textContent = StyleTransformer.elementStyles(host, styleInfo.styleRules);\n\t        }\n\t        styleInfo.styleRules = template._styleAst;\n\t      }\n\t      this._updateNativeProperties(host, styleInfo.overrideStyleProperties);\n\t    } else {\n\t      this._updateProperties(host, styleInfo);\n\t      if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {\n\t        // TODO: use caching\n\t        this._applyStyleProperties(host, styleInfo);\n\t      }\n\t    }\n\t    var root = this._isRootOwner(host) ? host : host.shadowRoot;\n\t    // note: some elements may not have a root!\n\t    if (root) {\n\t      this._applyToDescendants(root);\n\t    }\n\t  },\n\t  _applyToDescendants: function _applyToDescendants(root) {\n\t    var c$ = root.children;\n\t    for (var i = 0, c; i < c$.length; i++) {\n\t      c = c$[i];\n\t      if (c.shadowRoot) {\n\t        this.applyStyle(c);\n\t      }\n\t      this._applyToDescendants(c);\n\t    }\n\t  },\n\t  _styleOwnerForNode: function _styleOwnerForNode(node) {\n\t    var root = node.getRootNode();\n\t    var host = root.host;\n\t    if (host) {\n\t      if (StyleInfo.get(host)) {\n\t        return host;\n\t      } else {\n\t        return this._styleOwnerForNode(host);\n\t      }\n\t    }\n\t    return this._documentOwner;\n\t  },\n\t  _isRootOwner: function _isRootOwner(node) {\n\t    return node === this._documentOwner;\n\t  },\n\t  _applyStyleProperties: function _applyStyleProperties(host, styleInfo) {\n\t    var is = host.getAttribute('is') || host.localName;\n\t    var cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);\n\t    var cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;\n\t    var cachedStyle = cacheEntry ? cacheEntry.styleElement : null;\n\t    var oldScopeSelector = styleInfo.scopeSelector;\n\t    // only generate new scope if cached style is not found\n\t    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);\n\t    var style = StyleProperties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);\n\t    if (!this.nativeShadow) {\n\t      StyleProperties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);\n\t    }\n\t    if (!cacheEntry) {\n\t      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);\n\t    }\n\t    return style;\n\t  },\n\t  _updateProperties: function _updateProperties(host, styleInfo) {\n\t    var owner = this._styleOwnerForNode(host);\n\t    var ownerStyleInfo = StyleInfo.get(owner);\n\t    var ownerProperties = ownerStyleInfo.styleProperties;\n\t    var props = Object.create(ownerProperties || null);\n\t    var hostAndRootProps = StyleProperties.hostAndRootPropertiesForScope(host, styleInfo.styleRules);\n\t    var propertyData = StyleProperties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);\n\t    var propertiesMatchingHost = propertyData.properties;\n\t    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);\n\t    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);\n\t    StyleProperties.reify(props);\n\t    styleInfo.styleProperties = props;\n\t  },\n\t  _mixinOverrideStyles: function _mixinOverrideStyles(props, overrides) {\n\t    for (var p in overrides) {\n\t      var v = overrides[p];\n\t      // skip override props if they are not truthy or 0\n\t      // in order to fall back to inherited values\n\t      if (v || v === 0) {\n\t        props[p] = v;\n\t      }\n\t    }\n\t  },\n\t  _updateNativeProperties: function _updateNativeProperties(element, properties) {\n\t    // remove previous properties\n\t    for (var p in properties) {\n\t      // NOTE: for bc with shim, don't apply null values.\n\t      if (p === null) {\n\t        element.style.removeProperty(p);\n\t      } else {\n\t        element.style.setProperty(p, properties[p]);\n\t      }\n\t    }\n\t  },\n\t  updateStyles: function updateStyles(properties) {\n\t    if (window.CustomStyle) {\n\t      window.CustomStyle._documentDirty = true;\n\t    }\n\t    this.applyStyle(this._documentOwner, properties);\n\t  },\n\t\n\t  /* Custom Style operations */\n\t  _transformCustomStyleForDocument: function _transformCustomStyleForDocument(style) {\n\t    var _this = this;\n\t\n\t    var ast = rulesForStyle(style);\n\t    forEachRule(ast, function (rule) {\n\t      if (nativeShadow) {\n\t        StyleTransformer.normalizeRootSelector(rule);\n\t      } else {\n\t        StyleTransformer.documentRule(rule);\n\t      }\n\t      if (_this.nativeCss && !_this.nativeCssApply) {\n\t        applyShim.transformRule(rule);\n\t      }\n\t    });\n\t    if (this.nativeCss) {\n\t      style.textContent = toCssText(ast);\n\t    } else {\n\t      this._documentOwnerStyleInfo.styleRules.rules.push(ast);\n\t    }\n\t  },\n\t  _revalidateApplyShim: function _revalidateApplyShim(style) {\n\t    if (this.nativeCss && !this.nativeCssApply) {\n\t      var ast = rulesForStyle(style);\n\t      applyShim.transformRules(ast);\n\t      style.textContent = toCssText(ast);\n\t    }\n\t  },\n\t  _applyCustomStyleToDocument: function _applyCustomStyleToDocument(style) {\n\t    if (!this.nativeCss) {\n\t      StyleProperties.applyCustomStyle(style, this._documentOwnerStyleInfo.styleProperties);\n\t    }\n\t  },\n\t  getComputedStyleValue: function getComputedStyleValue(element, property) {\n\t    var value = void 0;\n\t    if (!this.nativeCss) {\n\t      // element is either a style host, or an ancestor of a style host\n\t      var styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));\n\t      value = styleInfo.styleProperties[property];\n\t    }\n\t    // fall back to the property value from the computed styling\n\t    value = value || window.getComputedStyle(element).getPropertyValue(property);\n\t    // trim whitespace that can come after the `:` in css\n\t    // example: padding: 2px -> \" 2px\"\n\t    return value.trim();\n\t  },\n\t\n\t  // given an element and a classString, replaces\n\t  // the element's class with the provided classString and adds\n\t  // any necessary ShadyCSS static and property based scoping selectors\n\t  // NOTE: this method is suitable to be called in an environment in which\n\t  // setAttribute('class', ...) and className setter have been overridden so\n\t  // it cannot rely on those methods.\n\t  setElementClass: function setElementClass(element, classString) {\n\t    var _element$classList;\n\t\n\t    // use classList to clear existing classes\n\t    while (element.classList.length) {\n\t      element.classList.remove(element.classList[0]);\n\t    }\n\t    // add user classString\n\t    (_element$classList = element.classList).add.apply(_element$classList, toConsumableArray(classString.split(' ')));\n\t    // add static scoping: scope by shadyRoot\n\t    var root = element.getRootNode();\n\t    if (root.host) {\n\t      element.classList.add(StyleTransformer.SCOPE_NAME, root.host.localName);\n\t    }\n\t    // add property scoping: scope by special selector\n\t    if (!this.nativeCss) {\n\t      var styleInfo = StyleInfo.get(element);\n\t      if (styleInfo && styleInfo.scopeSelector) {\n\t        element.classList.add(StyleProperties.XSCOPE_NAME, styleInfo.scopeSelector);\n\t      }\n\t    }\n\t  },\n\t  _styleInfoForNode: function _styleInfoForNode(node) {\n\t    return StyleInfo.get(node);\n\t  }\n\t};\n\t\n\twindow['ShadyCSS'] = ShadyCSS;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t\n\t/*\n\tWrapper over <style> elements to co-operate with ShadyCSS\n\t\n\tExample:\n\t<shady-style>\n\t  <style>\n\t  ...\n\t  </style>\n\t</shady-style>\n\t*/\n\t\n\tvar ShadyCSS$1 = window.ShadyCSS;\n\t\n\tvar enqueued = false;\n\t\n\tvar customStyles = [];\n\t\n\tvar hookFn = null;\n\t\n\t/*\n\tIf a page only has <custom-style> elements, it will flash unstyled content,\n\tas all the instances will boot asynchronously after page load.\n\t\n\tCalling ShadyCSS.updateStyles() will force the work to happen synchronously\n\t*/\n\tfunction enqueueDocumentValidation() {\n\t  if (enqueued) {\n\t    return;\n\t  }\n\t  enqueued = true;\n\t  if (window.HTMLImports) {\n\t    window.HTMLImports.whenReady(validateDocument);\n\t  } else if (document.readyState === 'complete') {\n\t    requestAnimationFrame(validateDocument);\n\t  } else {\n\t    document.addEventListener('readystatechange', function () {\n\t      if (document.readyState === 'complete') {\n\t        validateDocument();\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t// NOTE: Make sure to enqueue eagerly. This is an optimization that\n\t// helps ensure that the first run of validateDocument will actually\n\t// have access to all the custom-style's created via loading imports.\n\t// If the first created custom-style calls enqueue and HTMLImports.ready\n\t// is true at that time (which is the case when HTMLImports are polyfilled),\n\t// then the enqueue immediately calls validateDocument and work that could be\n\t// batched is not.\n\tenqueueDocumentValidation();\n\t\n\tfunction validateDocument() {\n\t  if (enqueued) {\n\t    ShadyCSS$1.updateStyles();\n\t    enqueued = false;\n\t  }\n\t}\n\t\n\tfunction CustomStyle() {\n\t  /*\n\t  Use Reflect to invoke the HTMLElement constructor, or rely on the\n\t  CustomElement polyfill replacement that can be `.call`ed\n\t  */\n\t  var self = window.Reflect && Reflect.construct ? Reflect.construct(HTMLElement, [], this.constructor || CustomStyle) : HTMLElement.call(this);\n\t  customStyles.push(self);\n\t  enqueueDocumentValidation();\n\t  return self;\n\t}\n\t\n\tObject.defineProperties(CustomStyle, {\n\t  /*\n\t  CustomStyle.processHook is provided to customize the <style> element child of\n\t  a <custom-style> element before the <style> is processed by ShadyCSS\n\t   The function must take a <style> element as input, and return nothing.\n\t  */\n\t  processHook: {\n\t    get: function get() {\n\t      return hookFn;\n\t    },\n\t    set: function set(fn) {\n\t      hookFn = fn;\n\t      return fn;\n\t    }\n\t  },\n\t  _customStyles: {\n\t    get: function get() {\n\t      return customStyles;\n\t    }\n\t  },\n\t  _documentDirty: {\n\t    get: function get() {\n\t      return enqueued;\n\t    },\n\t    set: function set(value) {\n\t      enqueued = value;\n\t      return value;\n\t    }\n\t  }\n\t});\n\t\n\tCustomStyle.findStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._findStyle();\n\t  }\n\t};\n\t\n\tCustomStyle._revalidateApplyShim = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    var s = customStyles[i];\n\t    if (s._style) {\n\t      ShadyCSS$1._revalidateApplyShim(s._style);\n\t    }\n\t  }\n\t};\n\t\n\tCustomStyle.applyStyles = function () {\n\t  for (var i = 0; i < customStyles.length; i++) {\n\t    customStyles[i]._applyStyle();\n\t  }\n\t};\n\t\n\tCustomStyle.prototype = Object.create(HTMLElement.prototype, {\n\t  'constructor': {\n\t    value: CustomStyle,\n\t    configurable: true,\n\t    writable: true\n\t  }\n\t});\n\t\n\tCustomStyle.prototype._findStyle = function () {\n\t  if (!this._style) {\n\t    var style = this.querySelector('style');\n\t    if (!style) {\n\t      return;\n\t    }\n\t    // HTMLImports polyfill may have cloned the style into the main document,\n\t    // which is referenced with __appliedElement.\n\t    // Also, we must copy over the attributes.\n\t    if (style.__appliedElement) {\n\t      for (var i = 0; i < style.attributes.length; i++) {\n\t        var attr = style.attributes[i];\n\t        style.__appliedElement.setAttribute(attr.name, attr.value);\n\t      }\n\t    }\n\t    this._style = style.__appliedElement || style;\n\t    if (hookFn) {\n\t      hookFn(this._style);\n\t    }\n\t    ShadyCSS$1._transformCustomStyleForDocument(this._style);\n\t  }\n\t};\n\t\n\tCustomStyle.prototype._applyStyle = function () {\n\t  if (this._style) {\n\t    ShadyCSS$1._applyCustomStyleToDocument(this._style);\n\t  }\n\t};\n\t\n\twindow.customElements.define('custom-style', CustomStyle);\n\twindow['CustomStyle'] = CustomStyle;\n\t\n\t/**\n\t@license\n\tCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\n\tThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n\tThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n\tThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n\tCode distributed by Google as part of the polymer project is also\n\tsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\t*/\n\t/*\n\tSmall module to load ShadyCSS and CustomStyle together\n\t*/\n\t\n\t}());\n\t\n\t//# sourceMappingURL=shadycss.min.js.map\n\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=index.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-web-components/dist/index.js\n// module id = 1\n// module chunks = 0","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('incremental-dom'), require('window-or-global')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'window-or-global'], factory) :\n  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.windowOrGlobal));\n}(this, (function (exports,incrementalDom,root) {\n\nroot = 'default' in root ? root['default'] : root;\n\nfunction keys() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref$enumOnly = _ref.enumOnly;\n  var enumOnly = _ref$enumOnly === undefined ? false : _ref$enumOnly;\n\n  var listOfKeys = Object[enumOnly ? 'keys' : 'getOwnPropertyNames'](obj);\n  return typeof Object.getOwnPropertySymbols === 'function' ? listOfKeys.concat(Object.getOwnPropertySymbols(obj)) : listOfKeys;\n}\n\n// We are not using Object.assign if it is defined since it will cause problems when Symbol is polyfilled.\n// Apparently Object.assign (or any polyfill for this method) does not copy non-native Symbols.\nvar assign = (function (obj) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  args.forEach(function (arg) {\n    return keys(arg).forEach(function (name) {\n      return obj[name] = arg[name];\n    });\n  }); // eslint-disable-line no-return-assign\n  return obj;\n});\n\nvar empty = function (val) {\n  return typeof val === 'undefined' || val === null;\n};\n\n/**\n * Attributes value can only be null or string;\n */\nvar toNullOrString = function toNullOrString(val) {\n  return empty(val) ? null : String(val);\n};\n\nfunction create(def) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args.unshift({}, def);\n    return assign.apply(undefined, args);\n  };\n}\n\nvar array = create({\n  coerce: function coerce(val) {\n    return Array.isArray(val) ? val : empty(val) ? null : [val];\n  },\n  default: function _default() {\n    return [];\n  },\n  deserialize: function deserialize(val) {\n    return empty(val) ? null : JSON.parse(val);\n  },\n  serialize: JSON.stringify\n});\n\nvar boolean = create({\n  coerce: function coerce(val) {\n    return !!val;\n  },\n  default: false,\n  // todo: 'false' string must deserialize to false for angular 1.x to work\n  // This breaks one existing test.\n  // deserialize: val => !(val === null || val === 'false'),\n  deserialize: function deserialize(val) {\n    return !(val === null);\n  },\n  serialize: function serialize(val) {\n    return val ? '' : null;\n  }\n});\n\n// defaults empty to 0 and allows NaN\nvar zeroIfEmptyOrNumberIncludesNaN = function zeroIfEmptyOrNumberIncludesNaN(val) {\n  return empty(val) ? 0 : Number(val);\n};\n\nvar number = create({\n  default: 0,\n  coerce: zeroIfEmptyOrNumberIncludesNaN,\n  deserialize: zeroIfEmptyOrNumberIncludesNaN,\n  serialize: toNullOrString\n});\n\nvar string = create({\n  default: '',\n  coerce: toNullOrString,\n  deserialize: toNullOrString,\n  serialize: toNullOrString\n});\n\nvar prop = Object.freeze({\n\tcreate: create,\n\tarray: array,\n\tboolean: boolean,\n\tnumber: number,\n\tstring: string\n});\n\nvar connected = '____skate_connected';\nvar created = '____skate_created';\n\n// DEPRECATED\n//\n// This is the only \"symbol\" that must stay a string. This is because it is\n// relied upon across several versions. We should remove it, but ensure that\n// it's considered a breaking change that whatever version removes it cannot\n// be passed to vdom functions as tag names.\nvar name = '____skate_name';\n\n// Used on the Constructor\nvar ctorCreateInitProps = '____skate_ctor_createInitProps';\nvar ctorObservedAttributes = '____skate_ctor_observedAttributes';\nvar ctorProps = '____skate_ctor_props';\nvar ctorPropsMap = '____skate_ctor_propsMap';\n\n// Used on the Element\nvar props = '____skate_props';\nvar ref$1 = '____skate_ref';\nvar renderer$1 = '____skate_renderer';\nvar rendering = '____skate_rendering';\nvar rendererDebounced = '____skate_rendererDebounced';\nvar updated$1 = '____skate_updated';\n\n// DEPRECTAED\n//\n// We should not be relying on internals for symbols as this creates version\n// coupling. We will move forward with platform agnostic ways of doing this.\n\n\nvar symbols$1 = Object.freeze({\n\tname: name\n});\n\nfunction enter(object, props) {\n  var saved = {};\n  Object.keys(props).forEach(function (key) {\n    saved[key] = object[key];\n    object[key] = props[key];\n  });\n  return saved;\n}\n\nfunction exit(object, saved) {\n  assign(object, saved);\n}\n\n// Decorates a function with a side effect that changes the properties of an\n// object during its execution, and restores them after. There is no error\n// handling here, if the wrapped function throws an error, properties are not\n// restored and all bets are off.\nvar propContext = function (object, props) {\n  return function (func) {\n    return function () {\n      var saved = enter(object, props);\n      var result = func.apply(undefined, arguments);\n      exit(object, saved);\n      return result;\n    };\n  };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/* eslint no-plusplus: 0 */\n\nvar customElements = root.customElements;\nvar HTMLElement = root.HTMLElement;\n\nvar applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\n// A stack of children that corresponds to the current function helper being\n// executed.\nvar stackChren = [];\n\nvar $skip = '__skip';\nvar $currentEventHandlers = '__events';\nvar $stackCurrentHelperProps = '__props';\n\n// The current function helper in the stack.\nvar stackCurrentHelper = void 0;\n\n// This is used for the Incremental DOM overrides to keep track of what args\n// to pass the main elementOpen() function.\nvar overrideArgs = void 0;\n\n// The number of levels deep after skipping a tree.\nvar skips = 0;\n\nvar noop = function noop() {};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent(elem, ename, newFunc) {\n  var events = elem[$currentEventHandlers];\n\n  if (!events) {\n    events = elem[$currentEventHandlers] = {};\n  }\n\n  // Undefined indicates that there is no listener yet.\n  if (typeof events[ename] === 'undefined') {\n    // We only add a single listener once. Originally this was a workaround for\n    // the Webcomponents ShadyDOM polyfill not removing listeners, but it's\n    // also a simpler model for binding / unbinding events because you only\n    // have a single handler you need to worry about and a single place where\n    // you only store one event handler\n    elem.addEventListener(ename, function (e) {\n      if (events[ename]) {\n        events[ename].call(this, e);\n      }\n    });\n  }\n\n  // Not undefined indicates that we have set a listener, so default to null.\n  events[ename] = typeof newFunc === 'function' ? newFunc : null;\n}\n\nvar attributesContext = propContext(incrementalDom.attributes, defineProperty({\n  // Attributes that shouldn't be applied to the DOM.\n  key: noop,\n  statics: noop,\n\n  // Attributes that *must* be set via a property on all elements.\n  checked: incrementalDom.applyProp,\n  className: incrementalDom.applyProp,\n  disabled: incrementalDom.applyProp,\n  value: incrementalDom.applyProp,\n\n  // Ref handler.\n  ref: function ref(elem, name$$1, value) {\n    elem[ref$1] = value;\n  },\n\n\n  // Skip handler.\n  skip: function skip(elem, name$$1, value) {\n    if (value) {\n      elem[$skip] = true;\n    } else {\n      delete elem[$skip];\n    }\n  }\n}, incrementalDom.symbols.default, function (elem, name$$1, value) {\n  var _ref = customElements.get(elem.localName) || {\n    props: {},\n    prototype: {}\n  };\n\n  var props$$1 = _ref.props;\n  var prototype = _ref.prototype;\n\n  // TODO when refactoring properties to not have to workaround the old\n  // WebKit bug we can remove the \"name in props\" check below.\n  //\n  // NOTE: That the \"name in elem\" check won't work for polyfilled custom\n  // elements that set a property that isn't explicitly specified in \"props\"\n  // or \"prototype\" unless it is added to the element explicitly as a\n  // property prior to passing the prop to the vdom function. For example, if\n  // it were added in a lifecycle callback because it wouldn't have been\n  // upgraded yet.\n  //\n  // We prefer setting props, so we do this if there's a property matching\n  // name that was passed. However, certain props on SVG elements are\n  // readonly and error when you try to set them.\n\n  if ((name$$1 in props$$1 || name$$1 in elem || name$$1 in prototype) && !('ownerSVGElement' in elem)) {\n    incrementalDom.applyProp(elem, name$$1, value);\n    return;\n  }\n\n  // Explicit false removes the attribute.\n  if (value === false) {\n    applyDefault(elem, name$$1);\n    return;\n  }\n\n  // Handle built-in and custom events.\n  if (name$$1.indexOf('on') === 0) {\n    var firstChar = name$$1[2];\n    var eventName = void 0;\n\n    if (firstChar === '-') {\n      eventName = name$$1.substring(3);\n    } else if (firstChar === firstChar.toUpperCase()) {\n      eventName = firstChar.toLowerCase() + name$$1.substring(3);\n    }\n\n    if (eventName) {\n      applyEvent(elem, eventName, value);\n      return;\n    }\n  }\n\n  applyDefault(elem, name$$1, value);\n}));\n\nfunction resolveTagName(name$$1) {\n  // We return falsy values as some wrapped IDOM functions allow empty values.\n  if (!name$$1) {\n    return name$$1;\n  }\n\n  // We try and return the cached tag name, if one exists.\n  if (name$$1[name]) {\n    return name$$1[name];\n  }\n\n  // If it's a custom element, we get the tag name by constructing it and\n  // caching it.\n  if (name$$1.prototype instanceof HTMLElement) {\n    // eslint-disable-next-line\n    var elem = new name$$1();\n    return name$$1[name] = elem.localName;\n  }\n\n  // Pass all other values through so IDOM gets what it's expecting.\n  return name$$1;\n}\n\n// Incremental DOM's elementOpen is where the hooks in `attributes` are applied,\n// so it's the only function we need to execute in the context of our attributes.\nvar elementOpen$1 = attributesContext(incrementalDom.elementOpen);\n\nfunction elementOpenStart(tag) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var statics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  overrideArgs = [tag, key, statics];\n}\n\nfunction elementOpenEnd() {\n  var node = newElementOpen.apply(undefined, toConsumableArray(overrideArgs)); // eslint-disable-line no-use-before-define\n  overrideArgs = null;\n  return node;\n}\n\nfunction wrapIdomFunc(func) {\n  var tnameFuncHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n  return function wrap() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    args[0] = resolveTagName(args[0]);\n    stackCurrentHelper = null;\n    if (typeof args[0] === 'function') {\n      // If we've encountered a function, handle it according to the type of\n      // function that is being wrapped.\n      stackCurrentHelper = args[0];\n      return tnameFuncHandler.apply(undefined, args);\n    } else if (stackChren.length) {\n      // We pass the wrap() function in here so that when it's called as\n      // children, it will queue up for the next stack, if there is one.\n      stackChren[stackChren.length - 1].push([wrap, args]);\n    } else {\n      if (func === elementOpen$1) {\n        if (skips) {\n          return ++skips;\n        }\n\n        var elem = func.apply(undefined, args);\n\n        if (elem[$skip]) {\n          ++skips;\n        }\n\n        return elem;\n      }\n\n      if (func === incrementalDom.elementClose) {\n        if (skips === 1) {\n          incrementalDom.skip();\n        }\n\n        // We only want to skip closing if it's not the last closing tag in the\n        // skipped tree because we keep the element that initiated the skpping.\n        if (skips && --skips) {\n          return;\n        }\n\n        var _elem = func.apply(undefined, args);\n        var ref$$1 = _elem[ref$1];\n\n        // We delete so that it isn't called again for the same element. If the\n        // ref changes, or the element changes, this will be defined again.\n        delete _elem[ref$1];\n\n        // Execute the saved ref after esuring we've cleand up after it.\n        if (typeof ref$$1 === 'function') {\n          ref$$1(_elem);\n        }\n\n        return _elem;\n      }\n\n      // We must call elementOpenStart and elementOpenEnd even if we are\n      // skipping because they queue up attributes and then call elementClose.\n      if (!skips || func === elementOpenStart || func === elementOpenEnd) {\n        return func.apply(undefined, args);\n      }\n    }\n  };\n}\n\nfunction newAttr() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (stackCurrentHelper) {\n    stackCurrentHelper[$stackCurrentHelperProps][args[0]] = args[1];\n  } else if (stackChren.length) {\n    stackChren[stackChren.length - 1].push([newAttr, args]);\n  } else {\n    overrideArgs.push(args[0]);\n    overrideArgs.push(args[1]);\n  }\n}\n\nfunction stackOpen(tname, key, statics) {\n  var props$$1 = { key: key, statics: statics };\n\n  for (var _len3 = arguments.length, attrs = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n    attrs[_key3 - 3] = arguments[_key3];\n  }\n\n  for (var a = 0; a < attrs.length; a += 2) {\n    props$$1[attrs[a]] = attrs[a + 1];\n  }\n  tname[$stackCurrentHelperProps] = props$$1;\n  stackChren.push([]);\n}\n\nfunction stackClose(tname) {\n  var chren = stackChren.pop();\n  var props$$1 = tname[$stackCurrentHelperProps];\n  delete tname[$stackCurrentHelperProps];\n  var elemOrFn = tname(props$$1, function () {\n    return chren.forEach(function (args) {\n      return args[0].apply(args, toConsumableArray(args[1]));\n    });\n  });\n  return typeof elemOrFn === 'function' ? elemOrFn() : elemOrFn;\n}\n\n// Incremental DOM overrides\n// -------------------------\n\n// We must override internal functions that call internal Incremental DOM\n// functions because we can't override the internal references. This means\n// we must roughly re-implement their behaviour. Luckily, they're fairly\n// simple.\nvar newElementOpenStart = wrapIdomFunc(elementOpenStart, stackOpen);\nvar newElementOpenEnd = wrapIdomFunc(elementOpenEnd);\n\n// Standard open / closed overrides don't need to reproduce internal behaviour\n// because they are the ones referenced from *End and *Start.\nvar newElementOpen = wrapIdomFunc(elementOpen$1, stackOpen);\nvar newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\n// Ensure we call our overridden functions instead of the internal ones.\nfunction newElementVoid(tag) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  newElementOpen.apply(undefined, [tag].concat(args));\n  return newElementClose(tag);\n}\n\n// Text override ensures their calls can queue if using function helpers.\nvar newText = wrapIdomFunc(incrementalDom.text);\n\n// Convenience function for declaring an Incremental DOM element using\n// hyperscript-style syntax.\nfunction element(tname, attrs) {\n  var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\n  // If attributes are a function, then they should be treated as children.\n\n  for (var _len5 = arguments.length, chren = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n    chren[_key5 - 2] = arguments[_key5];\n  }\n\n  if (atype === 'function' || atype === 'string' || atype === 'number') {\n    chren.unshift(attrs);\n  }\n\n  // Ensure the attributes are an object. Null is considered an object so we\n  // have to test for this explicitly.\n  if (attrs === null || atype !== 'object') {\n    attrs = {};\n  }\n\n  // We open the element so we can set attrs after.\n  newElementOpenStart(tname, attrs.key, attrs.statics);\n\n  // Delete so special attrs don't actually get set.\n  delete attrs.key;\n  delete attrs.statics;\n\n  // Set attributes.\n  Object.keys(attrs).forEach(function (name$$1) {\n    return newAttr(name$$1, attrs[name$$1]);\n  });\n\n  // Close before we render the descendant tree.\n  newElementOpenEnd(tname);\n\n  chren.forEach(function (ch) {\n    var ctype = typeof ch === 'undefined' ? 'undefined' : _typeof(ch);\n    if (ctype === 'function') {\n      ch();\n    } else if (ctype === 'string' || ctype === 'number') {\n      newText(ch);\n    } else if (Array.isArray(ch)) {\n      ch.forEach(function (sch) {\n        return sch();\n      });\n    }\n  });\n\n  return newElementClose(tname);\n}\n\n// Even further convenience for building a DSL out of JavaScript functions or hooking into standard\n// transpiles for JSX (React.createElement() / h).\nfunction builder() {\n  for (var _len6 = arguments.length, tags = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    tags[_key6] = arguments[_key6];\n  }\n\n  if (tags.length === 0) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      return element.bind.apply(element, [null].concat(args));\n    };\n  }\n  return tags.map(function (tag) {\n    return function () {\n      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      return element.bind.apply(element, [null, tag].concat(args));\n    };\n  });\n}\n\n\n\nvar vdom = Object.freeze({\n\telement: element,\n\tbuilder: builder,\n\tattr: newAttr,\n\telementClose: newElementClose,\n\telementOpen: newElementOpen,\n\telementOpenEnd: newElementOpenEnd,\n\telementOpenStart: newElementOpenStart,\n\telementVoid: newElementVoid,\n\ttext: newText\n});\n\nfunction createSymbol(description) {\n  return typeof Symbol === 'function' ? Symbol(description) : description;\n}\n\nvar data = function (element) {\n  var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data; // eslint-disable-line no-mixed-operators\n};\n\nvar nativeHints = ['native code', '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\nvar native = (function (fn) {\n  return nativeHints.map(function (hint) {\n    return (fn || '').toString().indexOf([hint]) > -1;\n  }).reduce(function (a, b) {\n    return a || b;\n  });\n});\n\nvar MutationObserver = root.MutationObserver;\n\n\nfunction microtaskDebounce(cbFunc) {\n  var scheduled = false;\n  var i = 0;\n  var cbArgs = [];\n  var elem = document.createElement('span');\n  var observer = new MutationObserver(function () {\n    cbFunc.apply(undefined, toConsumableArray(cbArgs));\n    scheduled = false;\n    cbArgs = null;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = '' + i;\n      i += 1;\n    }\n  };\n}\n\n// We have to use setTimeout() for IE9 and 10 because the Mutation Observer\n// polyfill requires that the element be in the document to trigger Mutation\n// Events. Mutation Events are also synchronous and thus wouldn't debounce.\n//\n// The soonest we can set the timeout for in IE is 1 as they have issues when\n// setting to 0.\nfunction taskDebounce(cbFunc) {\n  var scheduled = false;\n  var cbArgs = [];\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    cbArgs = args;\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        cbFunc.apply(undefined, toConsumableArray(cbArgs));\n      }, 1);\n    }\n  };\n}\nvar debounce = native(MutationObserver) ? microtaskDebounce : taskDebounce;\n\nvar isFunction = function isFunction(val) {\n  return typeof val === 'function';\n};\nvar isUndefined = function isUndefined(val) {\n  return typeof val === 'undefined';\n};\n\n/**\n * @internal\n * Attributes Manager\n *\n * Postpones attributes updates until when connected.\n */\n\nvar AttributesManager = function () {\n  function AttributesManager(elem) {\n    classCallCheck(this, AttributesManager);\n\n    this.elem = elem;\n    this.connected = false;\n    this.pendingValues = {};\n    this.lastSetValues = {};\n  }\n\n  /**\n   * Called from disconnectedCallback\n   */\n\n\n  createClass(AttributesManager, [{\n    key: 'suspendAttributesUpdates',\n    value: function suspendAttributesUpdates() {\n      this.connected = false;\n    }\n\n    /**\n     * Called from connectedCallback\n     */\n\n  }, {\n    key: 'resumeAttributesUpdates',\n    value: function resumeAttributesUpdates() {\n      var _this = this;\n\n      this.connected = true;\n      var names = Object.keys(this.pendingValues);\n      names.forEach(function (name) {\n        var value = _this.pendingValues[name];\n        // Skip if already cleared\n        if (!isUndefined(value)) {\n          delete _this.pendingValues[name];\n          _this._syncAttrValue(name, value);\n        }\n      });\n    }\n\n    /**\n     * Returns true if the value is different from the one set internally\n     * using setAttrValue()\n     */\n\n  }, {\n    key: 'onAttributeChanged',\n    value: function onAttributeChanged(name, value) {\n      value = toNullOrString(value);\n\n      // A new attribute value voids the pending one\n      this._clearPendingValue(name);\n\n      var changed = this.lastSetValues[name] !== value;\n      this.lastSetValues[name] = value;\n      return changed;\n    }\n\n    /**\n     * Updates or removes the attribute if value === null.\n     *\n     * When the component is not connected the value is saved and\n     * the attribute is only updated when the component is re-connected.\n     */\n\n  }, {\n    key: 'setAttrValue',\n    value: function setAttrValue(name, value) {\n      value = toNullOrString(value);\n\n      this.lastSetValues[name] = value;\n\n      if (this.connected) {\n        this._clearPendingValue(name);\n        this._syncAttrValue(name, value);\n      } else {\n        this.pendingValues[name] = value;\n      }\n    }\n  }, {\n    key: '_syncAttrValue',\n    value: function _syncAttrValue(name, value) {\n      var currAttrValue = toNullOrString(this.elem.getAttribute(name));\n      if (value !== currAttrValue) {\n        if (value === null) {\n          this.elem.removeAttribute(name);\n        } else {\n          this.elem.setAttribute(name, value);\n        }\n      }\n    }\n  }, {\n    key: '_clearPendingValue',\n    value: function _clearPendingValue(name) {\n      if (name in this.pendingValues) {\n        delete this.pendingValues[name];\n      }\n    }\n  }]);\n  return AttributesManager;\n}();\n\n// Only used by getAttrMgr\n\n\nvar $attributesMgr = '____skate_attributesMgr';\n\n/**\n * @internal\n * Returns attribute manager instance for the given Component\n */\nfunction getAttrMgr(elem) {\n  var mgr = elem[$attributesMgr];\n  if (!mgr) {\n    mgr = new AttributesManager(elem);\n    elem[$attributesMgr] = mgr;\n  }\n  return mgr;\n}\n\nvar getOwnPropertyDescriptors = function () {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  return keys(obj).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n};\n\nvar dashCase = function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return '' + one + dash + two.toLowerCase();\n  });\n};\n\nfunction error$1(message) {\n  var DEBUG = root.DEBUG;\n\n  if (!isUndefined(DEBUG) && DEBUG) {\n    console.error(message);\n  } else {\n    throw new Error(message);\n  }\n}\n\n/**\n * @internal\n * Property Definition\n *\n * Internal meta data and strategies for a property.\n * Created from the options of a PropOptions config object.\n *\n * Once created a PropDefinition should be treated as immutable and final.\n * 'getPropsMap' function memoizes PropDefinitions by Component's Class.\n *\n * The 'attribute' option is normalized into the 'attrName' property.\n */\n\nvar PropDefinition = function () {\n  function PropDefinition(nameOrSymbol, propOptions) {\n    var _this = this;\n\n    classCallCheck(this, PropDefinition);\n\n    this._name = nameOrSymbol;\n\n    propOptions = propOptions || {};\n\n    // default 'attrName': no linked attribute\n    this.attrName = null;\n\n    // default 'coerce': identity function\n    this.coerce = function (value) {\n      return value;\n    };\n\n    // default 'default': set prop to 'null'\n    this.default = null;\n\n    // default 'deserialize': return attribute's value (string or null)\n    this.deserialize = function (value) {\n      return value;\n    };\n\n    // default 'get': no function\n    this.get = null;\n\n    // 'initial' default: unspecified\n    // 'initial' option is truly optional and it cannot be initialized.\n    // Its presence is tested using: ('initial' in propDef)\n\n    // 'serialize' default: return string value or null\n    this.serialize = function (value) {\n      return empty(value) ? null : String(value);\n    };\n\n    // default 'set': no function\n    this.set = null;\n\n    // Note: option key is always a string (no symbols here)\n    Object.keys(propOptions).forEach(function (option) {\n      var optVal = propOptions[option];\n\n      // Only accept documented options and perform minimal input validation.\n      switch (option) {\n        case 'attribute':\n          _this.attrName = resolveAttrName(optVal, nameOrSymbol);\n          break;\n        case 'coerce':\n        case 'deserialize':\n        case 'get':\n        case 'serialize':\n        case 'set':\n          if (isFunction(optVal)) {\n            _this[option] = optVal;\n          } else {\n            error$1(option + ' must be a function.');\n          }\n          break;\n        case 'default':\n        case 'initial':\n          _this[option] = optVal;\n          break;\n        default:\n          error$1(option + ' is not a valid option. Options are: attribute, initial, default, coerce, deserialize, serialize.');\n          break;\n      }\n    });\n  }\n\n  createClass(PropDefinition, [{\n    key: 'name',\n    get: function get() {\n      return this._name;\n    }\n  }]);\n  return PropDefinition;\n}();\n\nfunction resolveAttrName(attrOption, nameOrSymbol) {\n  if ((typeof nameOrSymbol === 'undefined' ? 'undefined' : _typeof(nameOrSymbol)) === 'symbol') {\n    error$1(nameOrSymbol.toString() + ' symbol property cannot have an attribute.');\n  } else {\n    if (attrOption === true) {\n      return dashCase(String(nameOrSymbol));\n    }\n    if (typeof attrOption === 'string') {\n      return attrOption;\n    }\n  }\n  return null;\n}\n\n/**\n * This is needed to avoid IE11 \"stack size errors\" when creating\n * a new property on the constructor of an HTMLElement\n */\nfunction setCtorNativeProperty(Ctor, propName, value) {\n  Object.defineProperty(Ctor, propName, { configurable: true, value: value });\n}\n\n/**\n * Memoizes a map of PropDefinition for the given component class.\n * Keys in the map are the properties name which can a string or a symbol.\n *\n * The map is created from the result of: static get props\n */\nfunction getPropsMap(Ctor) {\n  // Must be defined on constructor and not from a superclass\n  if (!Ctor.hasOwnProperty(ctorPropsMap)) {\n    (function () {\n      var props$$1 = Ctor.props || {};\n\n      var propsMap = keys(props$$1).reduce(function (result, propNameOrSymbol) {\n        result[propNameOrSymbol] = new PropDefinition(propNameOrSymbol, props$$1[propNameOrSymbol]);\n        return result;\n      }, {});\n      setCtorNativeProperty(Ctor, ctorPropsMap, propsMap);\n    })();\n  }\n\n  return Ctor[ctorPropsMap];\n}\n\nfunction get$2(elem) {\n  var props$$1 = {};\n\n  keys(getPropsMap(elem.constructor)).forEach(function (propNameOrSymbol) {\n    props$$1[propNameOrSymbol] = elem[propNameOrSymbol];\n  });\n\n  return props$$1;\n}\n\nfunction set$2(elem, newProps) {\n  assign(elem, newProps);\n  if (elem[renderer$1]) {\n    elem[renderer$1]();\n  }\n}\n\nvar props$1 = function (elem, newProps) {\n  return typeof newProps === 'undefined' ? get$2(elem) : set$2(elem, newProps);\n};\n\nfunction getDefaultValue(elem, propDef) {\n  return typeof propDef.default === 'function' ? propDef.default(elem, { name: propDef.name }) : propDef.default;\n}\n\nfunction getInitialValue(elem, propDef) {\n  return typeof propDef.initial === 'function' ? propDef.initial(elem, { name: propDef.name }) : propDef.initial;\n}\n\nfunction getPropData(elem, name) {\n  var elemData = data(elem, 'props');\n  return elemData[name] || (elemData[name] = {});\n}\n\nfunction createNativePropertyDescriptor(propDef) {\n  var nameOrSymbol = propDef.name;\n\n  var prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.beforeDefineProperty = function (elem) {\n    var propData = getPropData(elem, nameOrSymbol);\n    var attrName = propDef.attrName;\n\n    // Store attribute to property link.\n    if (attrName) {\n      data(elem, 'attributeLinks')[attrName] = nameOrSymbol;\n    }\n\n    // prop value before upgrading\n    var initialValue = elem[nameOrSymbol];\n\n    // Set up initial value if it wasn't specified.\n    var valueFromAttribute = false;\n    if (empty(initialValue)) {\n      if (attrName && elem.hasAttribute(attrName)) {\n        valueFromAttribute = true;\n        initialValue = propDef.deserialize(elem.getAttribute(attrName));\n      } else if ('initial' in propDef) {\n        initialValue = getInitialValue(elem, propDef);\n      } else {\n        initialValue = getDefaultValue(elem, propDef);\n      }\n    }\n\n    initialValue = propDef.coerce(initialValue);\n\n    propData.internalValue = initialValue;\n\n    // Reflect to attribute unless valueFromAttribute\n    if (!valueFromAttribute && attrName && !empty(initialValue)) {\n      var serializedValue = propDef.serialize(initialValue);\n      getAttrMgr(elem).setAttrValue(propDef.attrName, serializedValue);\n    }\n  };\n\n  prop.get = function get() {\n    var propData = getPropData(this, nameOrSymbol);\n    var internalValue = propData.internalValue;\n\n    return propDef.get ? propDef.get(this, { name: nameOrSymbol, internalValue: internalValue }) : internalValue;\n  };\n\n  prop.set = function set(newValue) {\n    var propData = getPropData(this, nameOrSymbol);\n\n    var useDefaultValue = empty(newValue);\n    if (useDefaultValue) {\n      newValue = getDefaultValue(this, propDef);\n    }\n\n    newValue = propDef.coerce(newValue);\n\n    if (propDef.set) {\n      var oldValue = propData.oldValue;\n\n\n      if (empty(oldValue)) {\n        oldValue = null;\n      }\n      var changeData = { name: nameOrSymbol, newValue: newValue, oldValue: oldValue };\n      propDef.set(this, changeData);\n    }\n\n    // Queue a re-render.\n    this[rendererDebounced](this);\n\n    // Update prop data so we can use it next time.\n    propData.internalValue = propData.oldValue = newValue;\n\n    // Link up the attribute.\n    if (propDef.attrName && !propData.settingProp) {\n      // Note: setting the prop to empty implies the default value\n      // and therefore no attribute should be present!\n      var serializedValue = useDefaultValue ? null : propDef.serialize(newValue);\n      getAttrMgr(this).setAttrValue(propDef.attrName, serializedValue);\n    }\n  };\n\n  return prop;\n}\n\nvar objectIs = (function (x, y) {\n  if (Object.is) {\n    return Object.is(x, y);\n  }\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n});\n\nvar HTMLElement$1 = root.HTMLElement || function () {\n  function _class() {\n    classCallCheck(this, _class);\n  }\n\n  return _class;\n}();\nvar _prevName = createSymbol('prevName');\nvar _prevOldValue = createSymbol('prevOldValue');\nvar _prevNewValue = createSymbol('prevNewValue');\n\nfunction preventDoubleCalling(elem, name$$1, oldValue, newValue) {\n  return name$$1 === elem[_prevName] && oldValue === elem[_prevOldValue] && newValue === elem[_prevNewValue];\n}\n\n// TODO remove when not catering to Safari < 10.\nfunction createNativePropertyDescriptors(Ctor) {\n  var propDefs = getPropsMap(Ctor);\n  return keys(propDefs).reduce(function (propDescriptors, propName) {\n    propDescriptors[propName] = createNativePropertyDescriptor(propDefs[propName]);\n    return propDescriptors;\n  }, {});\n}\n\n// TODO refactor when not catering to Safari < 10.\n//\n// We should be able to simplify this where all we do is Object.defineProperty().\nfunction createInitProps(Ctor) {\n  var propDescriptors = createNativePropertyDescriptors(Ctor);\n\n  return function (elem) {\n    keys(propDescriptors).forEach(function (name$$1) {\n      var propDescriptor = propDescriptors[name$$1];\n      propDescriptor.beforeDefineProperty(elem);\n\n      // We check here before defining to see if the prop was specified prior\n      // to upgrading.\n      var hasPropBeforeUpgrading = name$$1 in elem;\n\n      // This is saved prior to defining so that we can set it after it it was\n      // defined prior to upgrading. We don't want to invoke the getter if we\n      // don't need to, so we only get the value if we need to re-sync.\n      var valueBeforeUpgrading = hasPropBeforeUpgrading && elem[name$$1];\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name$$1, propDescriptor);\n\n      // DEPRECATED\n      //\n      // We'll be removing get / set callbacks on properties. Use the\n      // updatedCallback() instead.\n      //\n      // We re-set the prop if it was specified prior to upgrading because we\n      // need to ensure set() is triggered both in polyfilled environments and\n      // in native where the definition may be registerd after elements it\n      // represents have already been created.\n      if (hasPropBeforeUpgrading) {\n        elem[name$$1] = valueBeforeUpgrading;\n      }\n    });\n  };\n}\n\nvar _class2 = function (_HTMLElement) {\n  inherits(_class2, _HTMLElement);\n  createClass(_class2, null, [{\n    key: 'observedAttributes',\n\n    /**\n     * Returns unique attribute names configured with props and\n     * those set on the Component constructor if any\n     */\n    get: function get() {\n      var attrsOnCtor = this.hasOwnProperty(ctorObservedAttributes) ? this[ctorObservedAttributes] : [];\n      var propDefs = getPropsMap(this);\n\n      // Use Object.keys to skips symbol props since they have no linked attributes\n      var attrsFromLinkedProps = Object.keys(propDefs).map(function (propName) {\n        return propDefs[propName].attrName;\n      }).filter(Boolean);\n\n      var all = attrsFromLinkedProps.concat(attrsOnCtor).concat(get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'observedAttributes', this));\n      return all.filter(function (item, index) {\n        return all.indexOf(item) === index;\n      });\n    },\n    set: function set(value) {\n      value = Array.isArray(value) ? value : [];\n      setCtorNativeProperty(this, 'observedAttributes', value);\n    }\n\n    // Returns superclass props overwritten with this Component props\n\n  }, {\n    key: 'props',\n    get: function get() {\n      return assign({}, get$1(_class2.__proto__ || Object.getPrototypeOf(_class2), 'props', this), this[ctorProps]);\n    },\n    set: function set(value) {\n      setCtorNativeProperty(this, ctorProps, value);\n    }\n\n    // Passing args is designed to work with document-register-element. It's not\n    // necessary for the webcomponents/custom-element polyfill.\n\n  }]);\n\n  function _class2() {\n    var _ref;\n\n    classCallCheck(this, _class2);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = possibleConstructorReturn(this, (_ref = _class2.__proto__ || Object.getPrototypeOf(_class2)).call.apply(_ref, [this].concat(args)));\n\n    var constructor = _this.constructor;\n\n    // Used for the ready() function so it knows when it can call its callback.\n\n    _this[created] = true;\n\n    // TODO refactor to not cater to Safari < 10. This means we can depend on\n    // built-in property descriptors.\n    // Must be defined on constructor and not from a superclass\n    if (!constructor.hasOwnProperty(ctorCreateInitProps)) {\n      setCtorNativeProperty(constructor, ctorCreateInitProps, createInitProps(constructor));\n    }\n\n    // Set up a renderer that is debounced for property sets to call directly.\n    _this[rendererDebounced] = debounce(_this[renderer$1].bind(_this));\n\n    // Set up property lifecycle.\n    var propDefsCount = keys(getPropsMap(constructor)).length;\n    if (propDefsCount && constructor[ctorCreateInitProps]) {\n      constructor[ctorCreateInitProps](_this);\n    }\n\n    // DEPRECATED\n    //\n    // static render()\n    // Note that renderCallback is an optional method!\n    if (!_this.renderCallback && constructor.render) {\n      _this.renderCallback = constructor.render.bind(constructor, _this);\n    }\n\n    // DEPRECATED\n    //\n    // static created()\n    //\n    // Props should be set up before calling this.\n    var created$$1 = constructor.created;\n\n    if (isFunction(created$$1)) {\n      created$$1(_this);\n    }\n\n    // DEPRECATED\n    //\n    // Feature has rarely been used.\n    //\n    // Created should be set before invoking the ready listeners.\n    var elemData = data(_this);\n    var readyCallbacks = elemData.readyCallbacks;\n    if (readyCallbacks) {\n      readyCallbacks.forEach(function (cb) {\n        return cb(_this);\n      });\n      delete elemData.readyCallbacks;\n    }\n    return _this;\n  }\n\n  // Custom Elements v1\n\n\n  createClass(_class2, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      // Reflect attributes pending values\n      getAttrMgr(this).resumeAttributesUpdates();\n\n      // Used to check whether or not the component can render.\n      this[connected] = true;\n\n      // Render!\n      this[rendererDebounced]();\n\n      // DEPRECATED\n      //\n      // static attached()\n      var attached = this.constructor.attached;\n\n      if (isFunction(attached)) {\n        attached(this);\n      }\n\n      // DEPRECATED\n      //\n      // We can remove this once all browsers support :defined.\n      this.setAttribute('defined', '');\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      // Suspend updating attributes until re-connected\n      getAttrMgr(this).suspendAttributesUpdates();\n\n      // Ensures the component can't be rendered while disconnected.\n      this[connected] = false;\n\n      // DEPRECATED\n      //\n      // static detached()\n      var detached = this.constructor.detached;\n\n      if (isFunction(detached)) {\n        detached(this);\n      }\n    }\n\n    // Custom Elements v1\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name$$1, oldValue, newValue) {\n      // Polyfill calls this twice.\n      if (preventDoubleCalling(this, name$$1, oldValue, newValue)) {\n        return;\n      }\n\n      // Set data so we can prevent double calling if the polyfill.\n      this[_prevName] = name$$1;\n      this[_prevOldValue] = oldValue;\n      this[_prevNewValue] = newValue;\n\n      var propNameOrSymbol = data(this, 'attributeLinks')[name$$1];\n      if (propNameOrSymbol) {\n        var changedExternally = getAttrMgr(this).onAttributeChanged(name$$1, newValue);\n        if (changedExternally) {\n          // Sync up the property.\n          var propDef = getPropsMap(this.constructor)[propNameOrSymbol];\n          var newPropVal = newValue !== null && propDef.deserialize ? propDef.deserialize(newValue) : newValue;\n\n          var propData = data(this, 'props')[propNameOrSymbol];\n          propData.settingProp = true;\n          this[propNameOrSymbol] = newPropVal;\n          propData.settingProp = false;\n        }\n      }\n\n      // DEPRECATED\n      //\n      // static attributeChanged()\n      var attributeChanged = this.constructor.attributeChanged;\n\n      if (isFunction(attributeChanged)) {\n        attributeChanged(this, { name: name$$1, newValue: newValue, oldValue: oldValue });\n      }\n    }\n\n    // Skate\n\n  }, {\n    key: 'updatedCallback',\n    value: function updatedCallback(prevProps) {\n      return this.constructor.updated(this, prevProps);\n    }\n\n    // Skate\n\n  }, {\n    key: 'renderedCallback',\n    value: function renderedCallback() {\n      return this.constructor.rendered(this);\n    }\n\n    // Skate\n    //\n    // Maps to the static renderer() callback. That logic should be moved here\n    // when that is finally removed.\n    // todo: finalize how to support different rendering strategies.\n\n  }, {\n    key: 'rendererCallback',\n    value: function rendererCallback() {\n      // todo: cannot move code here because tests expects renderer function to still exist on constructor!\n      return this.constructor.renderer(this);\n    }\n\n    // Skate\n    // @internal\n    // Invokes the complete render lifecycle.\n\n  }, {\n    key: renderer$1,\n    value: function value() {\n      if (this[rendering] || !this[connected]) {\n        return;\n      }\n\n      // Flag as rendering. This prevents anything from trying to render - or\n      // queueing a render - while there is a pending render.\n      this[rendering] = true;\n      if (this[updated$1]() && isFunction(this.renderCallback)) {\n        this.rendererCallback();\n        this.renderedCallback();\n      }\n\n      this[rendering] = false;\n    }\n\n    // Skate\n    // @internal\n    // Calls the updatedCallback() with previous props.\n\n  }, {\n    key: updated$1,\n    value: function value() {\n      var prevProps = this[props];\n      this[props] = props$1(this);\n      return this.updatedCallback(prevProps);\n    }\n\n    // Skate\n\n  }], [{\n    key: 'extend',\n    value: function extend() {\n      var definition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var Base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\n\n      // Create class for the user.\n      var Ctor = function (_Base) {\n        inherits(Ctor, _Base);\n\n        function Ctor() {\n          classCallCheck(this, Ctor);\n          return possibleConstructorReturn(this, (Ctor.__proto__ || Object.getPrototypeOf(Ctor)).apply(this, arguments));\n        }\n\n        return Ctor;\n      }(Base);\n\n      // For inheriting from the object literal.\n\n\n      var opts = getOwnPropertyDescriptors(definition);\n      var prot = getOwnPropertyDescriptors(definition.prototype);\n\n      // Prototype is non configurable (but is writable).\n      delete opts.prototype;\n\n      // Pass on static and instance members from the definition.\n      Object.defineProperties(Ctor, opts);\n      Object.defineProperties(Ctor.prototype, prot);\n\n      return Ctor;\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Stubbed in case any subclasses are calling it.\n\n  }, {\n    key: 'rendered',\n    value: function rendered() {}\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to rendererCallback() before removing.\n\n  }, {\n    key: 'renderer',\n    value: function renderer(elem) {\n      if (!elem.shadowRoot) {\n        elem.attachShadow({ mode: 'open' });\n      }\n      incrementalDom.patchInner(elem.shadowRoot, function () {\n        var possibleFn = elem.renderCallback(elem);\n        if (isFunction(possibleFn)) {\n          possibleFn();\n        } else if (Array.isArray(possibleFn)) {\n          possibleFn.forEach(function (fn) {\n            if (isFunction(fn)) {\n              fn();\n            }\n          });\n        }\n      });\n    }\n\n    // Skate\n    //\n    // DEPRECATED\n    //\n    // Move this to updatedCallback() before removing.\n\n  }, {\n    key: 'updated',\n    value: function updated(elem, prevProps) {\n      // short-circuits if this is the first time\n      if (!prevProps) {\n        return true;\n      }\n\n      // Use getAllKeys to include all props names and Symbols\n      var allKeys = keys(prevProps);\n\n      // Use classic loop because 'for ... of' skips symbols\n      for (var i = 0; i < allKeys.length; i++) {\n        var nameOrSymbol = allKeys[i];\n\n        // Object.is (NaN is equal NaN)\n        if (!objectIs(prevProps[nameOrSymbol], elem[nameOrSymbol])) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }]);\n  return _class2;\n}(HTMLElement$1);\n\nfunction uniqueId(prefix) {\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/2117523#2117523\n  var rand = 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0;\n    // eslint-disable-next-line no-mixed-operators\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return (prefix || 'x') + '-' + rand;\n}\n\nvar define = function () {\n  var customElements = root.customElements;\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var name$$1 = args[0];\n  var Ctor = args[1];\n\n\n  if (!customElements) {\n    throw new Error('Skate requires native custom element support or a polyfill.');\n  }\n\n  // Support passing an anonymous definition.\n  if (args.length === 1) {\n    // We are checking string for now, but once we remove the ability to pass\n    // an object literal, we can change this to check \"function\" and invert the\n    // blocks of logic.\n    if (typeof name$$1 === 'string') {\n      throw new Error('When passing only one argument to define(), it must be a custom element constructor.');\n    } else {\n      Ctor = name$$1;\n      name$$1 = uniqueId();\n    }\n  }\n\n  // Ensure there's no conflicts.\n  if (customElements.get(name$$1)) {\n    name$$1 = uniqueId(name$$1);\n  }\n\n  // DEPRECATED\n  //\n  // Object literals.\n  if ((typeof Ctor === 'undefined' ? 'undefined' : _typeof(Ctor)) === 'object') {\n    Ctor = _class2.extend(Ctor);\n  }\n\n  // This allows us to check this before instantiating the custom element to\n  // find its name from the constructor in the vdom module, thus improving\n  // performance but still falling back to a robust method.\n  Ctor[name] = name$$1;\n\n  // Sipmle define. Not supporting customised built-ins yet.\n  customElements.define(name$$1, Ctor);\n\n  // The spec doesn't return but this allows for a simpler, more concise API.\n  return Ctor;\n};\n\nvar Event = function (TheEvent) {\n  if (TheEvent) {\n    try {\n      new TheEvent('emit-init'); // eslint-disable-line no-new\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return TheEvent;\n}(root.Event);\n\nfunction createCustomEvent(name) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var detail = opts.detail;\n\n  delete opts.detail;\n\n  var e = void 0;\n  if (Event) {\n    e = new Event(name, opts);\n    Object.defineProperty(e, 'detail', { value: detail });\n  } else {\n    e = document.createEvent('CustomEvent');\n    Object.defineProperty(e, 'composed', { value: opts.composed });\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, detail);\n  }\n  return e;\n}\n\nvar emit = function (elem, name) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (opts.bubbles === undefined) {\n    opts.bubbles = true;\n  }\n  if (opts.cancelable === undefined) {\n    opts.cancelable = true;\n  }\n  if (opts.composed === undefined) {\n    opts.composed = true;\n  }\n  return elem.dispatchEvent(createCustomEvent(name, opts));\n};\n\nfunction getValue(elem) {\n  var type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nvar link = function (elem, target) {\n  return function (e) {\n    var value = getValue(e.target);\n    var localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      var parts = localTarget.split('.');\n      var firstPart = parts[0];\n      var propName = parts.pop();\n      var obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      props$1(elem, defineProperty({}, firstPart, elem[firstPart]));\n    } else {\n      props$1(elem, defineProperty({}, localTarget, value));\n    }\n  };\n};\n\nvar ready = function (elem, done) {\n  var info = data(elem);\n  if (elem[created]) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n};\n\nvar h = builder();\n\nexports.Component = _class2;\nexports.define = define;\nexports.emit = emit;\nexports.h = h;\nexports.link = link;\nexports.prop = prop;\nexports.props = props$1;\nexports.ready = ready;\nexports.symbols = symbols$1;\nexports.vdom = vdom;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs/dist/index.js\n// module id = 2\n// module chunks = 0","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/incremental-dom/dist/incremental-dom-cjs.js\n// module id = 3\n// module chunks = 0","'use strict'\nmodule.exports = (typeof self === 'object' && self.self === self && self) ||\n  (typeof global === 'object' && global.global === global && global) ||\n  this\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/window-or-global/lib/index.js\n// module id = 4\n// module chunks = 0","import cssBase from 'todomvc-common/base.css';\nimport cssApp from 'todomvc-app-css/index.css';\n\nconst { head } = document;\nconst cssBaseStyle = document.createElement('style');\nconst cssAppStyle = document.createElement('style');\n\ncssBaseStyle.textContent = cssBase.toString();\ncssAppStyle.textContent = cssApp.toString();\n\nhead.appendChild(cssBaseStyle);\nhead.appendChild(cssAppStyle);\n\nexport default cssBase.toString() + cssApp.toString();\nexport const classes = { ...cssBase.locals, ...cssApp.locals };\n\n\n\n// WEBPACK FOOTER //\n// ./src/style.js","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"hr{margin:20px 0;border:0;border-top:1px dashed #c5c5c5;border-bottom:1px dashed #f7f7f7}.cPEPub0maVFxkzbgWUVOd a{font-weight:400;text-decoration:none;color:#b83f45}.cPEPub0maVFxkzbgWUVOd a:hover{text-decoration:underline;color:#787e7e}.cPEPub0maVFxkzbgWUVOd h3,.cPEPub0maVFxkzbgWUVOd h4,.cPEPub0maVFxkzbgWUVOd h5{margin:10px 0;font-weight:500;line-height:1.2;color:#000}.cPEPub0maVFxkzbgWUVOd h3{font-size:24px}.cPEPub0maVFxkzbgWUVOd h4{font-size:18px}.cPEPub0maVFxkzbgWUVOd h5{margin-bottom:0;font-size:14px}.cPEPub0maVFxkzbgWUVOd ul{padding:0;margin:0 0 30px 25px}.cPEPub0maVFxkzbgWUVOd li{line-height:20px}.cPEPub0maVFxkzbgWUVOd p{font-size:15px;font-weight:300;line-height:1.3;margin-top:0;margin-bottom:0}#_3-nj88w-cbLlFAkd9E0Nbc{display:none}._2L69OI9oxKrr_A0PkWO2KF{border:none;margin:20px 0 60px}._2L69OI9oxKrr_A0PkWO2KF p{font-style:italic}._2L69OI9oxKrr_A0PkWO2KF p:before{content:'\\\\201C';font-size:50px;opacity:.15;position:absolute;top:-20px;left:3px}._2L69OI9oxKrr_A0PkWO2KF p:after{content:'\\\\201D';font-size:50px;opacity:.15;position:absolute;bottom:-42px;right:3px}._2L69OI9oxKrr_A0PkWO2KF footer{position:absolute;bottom:-40px;right:0}._2L69OI9oxKrr_A0PkWO2KF footer img{border-radius:3px}._2L69OI9oxKrr_A0PkWO2KF footer a{margin-left:5px;vertical-align:middle}._1nt1kCjSYEPZou23lObNdv{position:relative;padding:10px;background:rgba(0,0,0,.04);border-radius:5px}._1nt1kCjSYEPZou23lObNdv:after{content:'';position:absolute;top:100%;right:30px;border:13px solid transparent;border-top-color:rgba(0,0,0,.04)}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{position:absolute;width:272px;top:8px;left:-300px;padding:10px;border-radius:5px;background-color:hsla(0,0%,100%,.6);transition-property:left;transition-duration:.5s}@media (min-width:899px){._2vLQrIvSjobb3988bLfSTa{width:auto;padding-left:300px}._2vLQrIvSjobb3988bLfSTa>.cPEPub0maVFxkzbgWUVOd{left:8px}}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\"learn\": \"cPEPub0maVFxkzbgWUVOd\",\n\t\"issue-count\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\"issueCount\": \"_3-nj88w-cbLlFAkd9E0Nbc\",\n\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\"quote\": \"_2L69OI9oxKrr_A0PkWO2KF\",\n\t\"speech-bubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\"speechBubble\": \"_1nt1kCjSYEPZou23lObNdv\",\n\t\"learn-bar\": \"_2vLQrIvSjobb3988bLfSTa\",\n\t\"learnBar\": \"_2vLQrIvSjobb3988bLfSTa\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/todomvc-common/base.css\n// module id = 6\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 7\n// module chunks = 0","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"body,button,html{margin:0;padding:0}button{border:0;background:none;font-size:100%;vertical-align:baseline;font-family:inherit;font-weight:inherit;color:inherit;-webkit-appearance:none;appearance:none;-webkit-font-smoothing:antialiased}body,button{-moz-osx-font-smoothing:grayscale}body{font:14px Helvetica Neue,Helvetica,Arial,sans-serif;line-height:1.4em;background:#f5f5f5;color:#4d4d4d;min-width:230px;max-width:550px;margin:0 auto;-webkit-font-smoothing:antialiased;font-weight:300}:focus{outline:0}.RBzyqGlIYFAdozfNAWX9T{display:none}._2lTeO9Nfd9StmHCibrKyDn{background:#fff;margin:130px 0 40px;position:relative;box-shadow:0 2px 4px 0 rgba(0,0,0,.2),0 25px 50px 0 rgba(0,0,0,.1)}._2lTeO9Nfd9StmHCibrKyDn input::-webkit-input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::-moz-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn input::input-placeholder{font-style:italic;font-weight:300;color:#e6e6e6}._2lTeO9Nfd9StmHCibrKyDn h1{position:absolute;top:-155px;width:100%;font-size:100px;font-weight:100;text-align:center;color:rgba(175,47,47,.15);-webkit-text-rendering:optimizeLegibility;-moz-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility}._3RmQY0IMcqwS7R81Tj0dlC,.vdff5WcLi7yBBYDjtZljm{position:relative;margin:0;width:100%;font-size:24px;font-family:inherit;font-weight:inherit;line-height:1.4em;border:0;color:inherit;padding:6px;border:1px solid #999;box-shadow:inset 0 -1px 5px 0 rgba(0,0,0,.2);box-sizing:border-box;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.vdff5WcLi7yBBYDjtZljm{padding:16px 16px 16px 60px;border:none;background:rgba(0,0,0,.003);box-shadow:inset 0 -2px 1px rgba(0,0,0,.03)}._3dnsc4idur8-yk5Sjjq6VG{position:relative;z-index:2;border-top:1px solid #e6e6e6}label[for=toggle-all]{display:none}.DG0VaCEN4BXUysJd_tTIb{position:absolute;top:-55px;left:-12px;width:60px;height:34px;text-align:center;border:none}.DG0VaCEN4BXUysJd_tTIb:before{content:'\\\\276F';font-size:22px;color:#e6e6e6;padding:10px 27px}.DG0VaCEN4BXUysJd_tTIb:checked:before{color:#737373}._1p_AB3iiKNbxBsOlJi5CVw{margin:0;padding:0;list-style:none}._1p_AB3iiKNbxBsOlJi5CVw li{position:relative;font-size:24px;border-bottom:1px solid #ededed}._1p_AB3iiKNbxBsOlJi5CVw li:last-child{border-bottom:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm{border-bottom:none;padding:0}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm ._3RmQY0IMcqwS7R81Tj0dlC{display:block;width:506px;padding:12px 16px;margin:0 0 0 43px}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm .oksgs4_M9fAGjexFoJHTE{display:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{text-align:center;width:40px;height:auto;position:absolute;top:0;bottom:0;margin:auto 0;border:none;-webkit-appearance:none;appearance:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#ededed\\\" stroke-width=\\\"3\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5:checked:after{content:url('data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"40\\\" height=\\\"40\\\" viewBox=\\\"-10 -18 100 135\\\"><circle cx=\\\"50\\\" cy=\\\"50\\\" r=\\\"50\\\" fill=\\\"none\\\" stroke=\\\"#bddad5\\\" stroke-width=\\\"3\\\"/><path fill=\\\"#5dc2af\\\" d=\\\"M72 25L42 71 27 56l-4 4 20 20 34-52z\\\"/></svg>')}._1p_AB3iiKNbxBsOlJi5CVw li label{word-break:break-all;padding:15px 60px 15px 15px;margin-left:45px;display:block;line-height:1.2;transition:color .4s}._1p_AB3iiKNbxBsOlJi5CVw li._29S5oJEhfUYjuw83RXIvg0 label{color:#d9d9d9;text-decoration:line-through}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE{display:none;position:absolute;top:0;right:10px;bottom:0;width:40px;height:40px;margin:auto 0;font-size:30px;color:#cc9a9a;margin-bottom:11px;transition:color .2s ease-out}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:hover{color:#af5b5e}._1p_AB3iiKNbxBsOlJi5CVw li ._3dDZq0iA7OOgE8KkLYlAeE:after{content:'\\\\D7'}._1p_AB3iiKNbxBsOlJi5CVw li:hover ._3dDZq0iA7OOgE8KkLYlAeE{display:block}._1p_AB3iiKNbxBsOlJi5CVw li ._3RmQY0IMcqwS7R81Tj0dlC{display:none}._1p_AB3iiKNbxBsOlJi5CVw li._1o5HuoUdvYhgC5VxgocNDm:last-child{margin-bottom:-1px}.OfZp78rLkg_PWvZV9RYDG{color:#777;padding:10px 15px;height:20px;text-align:center;border-top:1px solid #e6e6e6}.OfZp78rLkg_PWvZV9RYDG:before{content:'';position:absolute;right:0;bottom:0;left:0;height:50px;overflow:hidden;box-shadow:0 1px 1px rgba(0,0,0,.2),0 8px 0 -3px #f6f6f6,0 9px 1px -3px rgba(0,0,0,.2),0 16px 0 -6px #f6f6f6,0 17px 2px -6px rgba(0,0,0,.2)}._1r5RuM5EHD-zS8b-wG0XPc{float:left;text-align:left}._1r5RuM5EHD-zS8b-wG0XPc strong{font-weight:300}._2tY47NKf597SqoScbkboy0{margin:0;padding:0;list-style:none;position:absolute;right:0;left:0}._2tY47NKf597SqoScbkboy0 li{display:inline}._2tY47NKf597SqoScbkboy0 li a{color:inherit;margin:3px;padding:3px 7px;text-decoration:none;border:1px solid transparent;border-radius:3px}._2tY47NKf597SqoScbkboy0 li a:hover{border-color:rgba(175,47,47,.1)}._2tY47NKf597SqoScbkboy0 li a.a8u8grJpMWz2FTlLtocrT{border-color:rgba(175,47,47,.2)}._1uOFz1y8zCB-ylF3BS8V7J,html ._1uOFz1y8zCB-ylF3BS8V7J:active{float:right;position:relative;line-height:20px;text-decoration:none;cursor:pointer}._1uOFz1y8zCB-ylF3BS8V7J:hover{text-decoration:underline}._3qrb6fjG3vwl0RExKf3l_q{margin:65px auto 0;color:#bfbfbf;font-size:10px;text-shadow:0 1px 0 hsla(0,0%,100%,.5);text-align:center}._3qrb6fjG3vwl0RExKf3l_q p{line-height:1}._3qrb6fjG3vwl0RExKf3l_q a{color:inherit;text-decoration:none;font-weight:400}._3qrb6fjG3vwl0RExKf3l_q a:hover{text-decoration:underline}@media screen and (-webkit-min-device-pixel-ratio:0){._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5,.DG0VaCEN4BXUysJd_tTIb{background:none}._1p_AB3iiKNbxBsOlJi5CVw li ._2gwmEJUdZx5PSoBxelFsO5{height:40px}.DG0VaCEN4BXUysJd_tTIb{-webkit-transform:rotate(90deg);transform:rotate(90deg);-webkit-appearance:none;appearance:none}}@media (max-width:430px){.OfZp78rLkg_PWvZV9RYDG{height:50px}._2tY47NKf597SqoScbkboy0{bottom:10px}}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\"hidden\": \"RBzyqGlIYFAdozfNAWX9T\",\n\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\"todoapp\": \"_2lTeO9Nfd9StmHCibrKyDn\",\n\t\"new-todo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\"newTodo\": \"vdff5WcLi7yBBYDjtZljm\",\n\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\"edit\": \"_3RmQY0IMcqwS7R81Tj0dlC\",\n\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\"main\": \"_3dnsc4idur8-yk5Sjjq6VG\",\n\t\"toggle-all\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\"toggleAll\": \"DG0VaCEN4BXUysJd_tTIb\",\n\t\"todo-list\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\"todoList\": \"_1p_AB3iiKNbxBsOlJi5CVw\",\n\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\"editing\": \"_1o5HuoUdvYhgC5VxgocNDm\",\n\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\"view\": \"oksgs4_M9fAGjexFoJHTE\",\n\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\"toggle\": \"_2gwmEJUdZx5PSoBxelFsO5\",\n\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\"completed\": \"_29S5oJEhfUYjuw83RXIvg0\",\n\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\"destroy\": \"_3dDZq0iA7OOgE8KkLYlAeE\",\n\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\"footer\": \"OfZp78rLkg_PWvZV9RYDG\",\n\t\"todo-count\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\"todoCount\": \"_1r5RuM5EHD-zS8b-wG0XPc\",\n\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\"filters\": \"_2tY47NKf597SqoScbkboy0\",\n\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\"selected\": \"a8u8grJpMWz2FTlLtocrT\",\n\t\"clear-completed\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\"clearCompleted\": \"_1uOFz1y8zCB-ylF3BS8V7J\",\n\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\",\n\t\"info\": \"_3qrb6fjG3vwl0RExKf3l_q\"\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/todomvc-app-css/index.css\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}